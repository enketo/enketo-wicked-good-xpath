// Input 0
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Bootstrap for the Google JS Library (Closure).
 *
 * In uncompiled mode base.js will write out Closure's deps file, unless the
 * global <code>CLOSURE_NO_DEPS</code> is set to true.  This allows projects to
 * include their own deps file(s) from different locations.
 *
 *
 * @provideGoog
 */


/**
 * @define {boolean} Overridden to true by the compiler when --closure_pass
 *     or --mark_as_compiled is specified.
 */
var COMPILED = false;


/**
 * Base namespace for the Closure library.  Checks to see goog is already
 * defined in the current scope before assigning to prevent clobbering if
 * base.js is loaded more than once.
 *
 * @const
 */
var goog = goog || {};


/**
 * Reference to the global context.  In most cases this will be 'window'.
 */
goog.global = this;


/**
 * A hook for overriding the define values in uncompiled mode.
 *
 * In uncompiled mode, {@code CLOSURE_DEFINES} may be defined before loading
 * base.js.  If a key is defined in {@code CLOSURE_DEFINES}, {@code goog.define}
 * will use the value instead of the default value.  This allows flags to be
 * overwritten without compilation (this is normally accomplished with the
 * compiler's "define" flag).
 *
 * Example:
 * <pre>
 *   var CLOSURE_DEFINES = {'goog.DEBUG': false};
 * </pre>
 *
 * @type {Object.<string, (string|number|boolean)>|undefined}
 */
goog.global.CLOSURE_DEFINES;


/**
 * Builds an object structure for the provided namespace path, ensuring that
 * names that already exist are not overwritten. For example:
 * "a.b.c" -> a = {};a.b={};a.b.c={};
 * Used by goog.provide and goog.exportSymbol.
 * @param {string} name name of the object that this file defines.
 * @param {*=} opt_object the object to expose at the end of the path.
 * @param {Object=} opt_objectToExportTo The object to add the path to; default
 *     is |goog.global|.
 * @private
 */
goog.exportPath_ = function (name, opt_object, opt_objectToExportTo) {
    var parts = name.split('.');
    var cur = opt_objectToExportTo || goog.global;

    // Internet Explorer exhibits strange behavior when throwing errors from
    // methods externed in this manner.  See the testExportSymbolExceptions in
    // base_test.html for an example.
    if (!(parts[0] in cur) && cur.execScript) {
        cur.execScript('var ' + parts[0]);
    }

    // Certain browsers cannot parse code in the form for((a in b); c;);
    // This pattern is produced by the JSCompiler when it collapses the
    // statement above into the conditional loop below. To prevent this from
    // happening, use a for-loop and reserve the init logic as below.

    // Parentheses added to eliminate strict JS warning in Firefox.
    for (var part; parts.length && (part = parts.shift());) {
        if (!parts.length && opt_object !== undefined) {
            // last part and we have an object; use it
            cur[part] = opt_object;
        } else if (cur[part]) {
            cur = cur[part];
        } else {
            cur = cur[part] = {};
        }
    }
};


/**
 * Defines a named value. In uncompiled mode, the value is retreived from
 * CLOSURE_DEFINES if the object is defined and has the property specified,
 * and otherwise used the defined defaultValue. When compiled, the default
 * can be overridden using compiler command-line options.
 *
 * @param {string} name The distinguished name to provide.
 * @param {string|number|boolean} defaultValue
 */
goog.define = function (name, defaultValue) {
    var value = defaultValue;
    if (!COMPILED) {
        if (goog.global.CLOSURE_DEFINES && Object.prototype.hasOwnProperty.call(
            goog.global.CLOSURE_DEFINES, name)) {
            value = goog.global.CLOSURE_DEFINES[name];
        }
    }
    goog.exportPath_(name, value);
};


/**
 * @define {boolean} DEBUG is provided as a convenience so that debugging code
 * that should not be included in a production js_binary can be easily stripped
 * by specifying --define goog.DEBUG=false to the JSCompiler. For example, most
 * toString() methods should be declared inside an "if (goog.DEBUG)" conditional
 * because they are generally used for debugging purposes and it is difficult
 * for the JSCompiler to statically determine whether they are used.
 */
goog.DEBUG = true;


/**
 * @define {string} LOCALE defines the locale being used for compilation. It is
 * used to select locale specific data to be compiled in js binary. BUILD rule
 * can specify this value by "--define goog.LOCALE=<locale_name>" as JSCompiler
 * option.
 *
 * Take into account that the locale code format is important. You should use
 * the canonical Unicode format with hyphen as a delimiter. Language must be
 * lowercase, Language Script - Capitalized, Region - UPPERCASE.
 * There are few examples: pt-BR, en, en-US, sr-Latin-BO, zh-Hans-CN.
 *
 * See more info about locale codes here:
 * http://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers
 *
 * For language codes you should use values defined by ISO 693-1. See it here
 * http://www.w3.org/WAI/ER/IG/ert/iso639.htm. There is only one exception from
 * this rule: the Hebrew language. For legacy reasons the old code (iw) should
 * be used instead of the new code (he), see http://wiki/Main/IIISynonyms.
 */
goog.define('goog.LOCALE', 'en');  // default to en


/**
 * @define {boolean} Whether this code is running on trusted sites.
 *
 * On untrusted sites, several native functions can be defined or overridden by
 * external libraries like Prototype, Datejs, and JQuery and setting this flag
 * to false forces closure to use its own implementations when possible.
 *
 * If your JavaScript can be loaded by a third party site and you are wary about
 * relying on non-standard implementations, specify
 * "--define goog.TRUSTED_SITE=false" to the JSCompiler.
 */
goog.define('goog.TRUSTED_SITE', true);


/**
 * Creates object stubs for a namespace.  The presence of one or more
 * goog.provide() calls indicate that the file defines the given
 * objects/namespaces.  Build tools also scan for provide/require statements
 * to discern dependencies, build dependency files (see deps.js), etc.
 * @see goog.require
 * @param {string} name Namespace provided by this file in the form
 *     "goog.package.part".
 */
goog.provide = function (name) {
    if (!COMPILED) {
        // Ensure that the same namespace isn't provided twice. This is intended
        // to teach new developers that 'goog.provide' is effectively a variable
        // declaration. And when JSCompiler transforms goog.provide into a real
        // variable declaration, the compiled JS should work the same as the raw
        // JS--even when the raw JS uses goog.provide incorrectly.
        if (goog.isProvided_(name)) {
            throw Error('Namespace "' + name + '" already declared.');
        }
        delete goog.implicitNamespaces_[name];

        var namespace = name;
        while ((namespace = namespace.substring(0, namespace.lastIndexOf('.')))) {
            if (goog.getObjectByName(namespace)) {
                break;
            }
            goog.implicitNamespaces_[namespace] = true;
        }
    }

    goog.exportPath_(name);
};


/**
 * Marks that the current file should only be used for testing, and never for
 * live code in production.
 *
 * In the case of unit tests, the message may optionally be an exact namespace
 * for the test (e.g. 'goog.stringTest'). The linter will then ignore the extra
 * provide (if not explicitly defined in the code).
 *
 * @param {string=} opt_message Optional message to add to the error that's
 *     raised when used in production code.
 */
goog.setTestOnly = function (opt_message) {
    if (COMPILED && !goog.DEBUG) {
        opt_message = opt_message || '';
        throw Error('Importing test-only code into non-debug environment' +
            opt_message ? ': ' + opt_message : '.');
    }
};


if (!COMPILED) {

    /**
     * Check if the given name has been goog.provided. This will return false for
     * names that are available only as implicit namespaces.
     * @param {string} name name of the object to look for.
     * @return {boolean} Whether the name has been provided.
     * @private
     */
    goog.isProvided_ = function (name) {
        return !goog.implicitNamespaces_[name] && !!goog.getObjectByName(name);
    };

    /**
     * Namespaces implicitly defined by goog.provide. For example,
     * goog.provide('goog.events.Event') implicitly declares that 'goog' and
     * 'goog.events' must be namespaces.
     *
     * @type {Object}
     * @private
     */
    goog.implicitNamespaces_ = {};
}


/**
 * Returns an object based on its fully qualified external name.  If you are
 * using a compilation pass that renames property names beware that using this
 * function will not find renamed properties.
 *
 * @param {string} name The fully qualified name.
 * @param {Object=} opt_obj The object within which to look; default is
 *     |goog.global|.
 * @return {?} The value (object or primitive) or, if not found, null.
 */
goog.getObjectByName = function (name, opt_obj) {
    var parts = name.split('.');
    var cur = opt_obj || goog.global;
    for (var part; part = parts.shift();) {
        if (goog.isDefAndNotNull(cur[part])) {
            cur = cur[part];
        } else {
            return null;
        }
    }
    return cur;
};


/**
 * Globalizes a whole namespace, such as goog or goog.lang.
 *
 * @param {Object} obj The namespace to globalize.
 * @param {Object=} opt_global The object to add the properties to.
 * @deprecated Properties may be explicitly exported to the global scope, but
 *     this should no longer be done in bulk.
 */
goog.globalize = function (obj, opt_global) {
    var global = opt_global || goog.global;
    for (var x in obj) {
        global[x] = obj[x];
    }
};


/**
 * Adds a dependency from a file to the files it requires.
 * @param {string} relPath The path to the js file.
 * @param {Array} provides An array of strings with the names of the objects
 *                         this file provides.
 * @param {Array} requires An array of strings with the names of the objects
 *                         this file requires.
 */
goog.addDependency = function (relPath, provides, requires) {
    if (goog.DEPENDENCIES_ENABLED) {
        var provide, require;
        var path = relPath.replace(/\\/g, '/');
        var deps = goog.dependencies_;
        for (var i = 0; provide = provides[i]; i++) {
            deps.nameToPath[provide] = path;
            if (!(path in deps.pathToNames)) {
                deps.pathToNames[path] = {};
            }
            deps.pathToNames[path][provide] = true;
        }
        for (var j = 0; require = requires[j]; j++) {
            if (!(path in deps.requires)) {
                deps.requires[path] = {};
            }
            deps.requires[path][require] = true;
        }
    }
};


// NOTE(nnaze): The debug DOM loader was included in base.js as an original way
// to do "debug-mode" development.  The dependency system can sometimes be
// confusing, as can the debug DOM loader's asynchronous nature.
//
// With the DOM loader, a call to goog.require() is not blocking -- the script
// will not load until some point after the current script.  If a namespace is
// needed at runtime, it needs to be defined in a previous script, or loaded via
// require() with its registered dependencies.
// User-defined namespaces may need their own deps file.  See http://go/js_deps,
// http://go/genjsdeps, or, externally, DepsWriter.
// http://code.google.com/closure/library/docs/depswriter.html
//
// Because of legacy clients, the DOM loader can't be easily removed from
// base.js.  Work is being done to make it disableable or replaceable for
// different environments (DOM-less JavaScript interpreters like Rhino or V8,
// for example). See bootstrap/ for more information.


/**
 * @define {boolean} Whether to enable the debug loader.
 *
 * If enabled, a call to goog.require() will attempt to load the namespace by
 * appending a script tag to the DOM (if the namespace has been registered).
 *
 * If disabled, goog.require() will simply assert that the namespace has been
 * provided (and depend on the fact that some outside tool correctly ordered
 * the script).
 */
goog.define('goog.ENABLE_DEBUG_LOADER', true);


/**
 * Implements a system for the dynamic resolution of dependencies that works in
 * parallel with the BUILD system. Note that all calls to goog.require will be
 * stripped by the JSCompiler when the --closure_pass option is used.
 * @see goog.provide
 * @param {string} name Namespace to include (as was given in goog.provide()) in
 *     the form "goog.package.part".
 */
goog.require = function (name) {

    // If the object already exists we do not need do do anything.
    // TODO(arv): If we start to support require based on file name this has to
    //            change.
    // TODO(arv): If we allow goog.foo.* this has to change.
    // TODO(arv): If we implement dynamic load after page load we should probably
    //            not remove this code for the compiled output.
    if (!COMPILED) {
        if (goog.isProvided_(name)) {
            return;
        }

        if (goog.ENABLE_DEBUG_LOADER) {
            var path = goog.getPathFromDeps_(name);
            if (path) {
                goog.included_[path] = true;
                goog.writeScripts_();
                return;
            }
        }

        var errorMessage = 'goog.require could not find: ' + name;
        if (goog.global.console) {
            goog.global.console['error'](errorMessage);
        }


        throw Error(errorMessage);

    }
};


/**
 * Path for included scripts.
 * @type {string}
 */
goog.basePath = '';


/**
 * A hook for overriding the base path.
 * @type {string|undefined}
 */
goog.global.CLOSURE_BASE_PATH;


/**
 * Whether to write out Closure's deps file. By default, the deps are written.
 * @type {boolean|undefined}
 */
goog.global.CLOSURE_NO_DEPS;


/**
 * A function to import a single script. This is meant to be overridden when
 * Closure is being run in non-HTML contexts, such as web workers. It's defined
 * in the global scope so that it can be set before base.js is loaded, which
 * allows deps.js to be imported properly.
 *
 * The function is passed the script source, which is a relative URI. It should
 * return true if the script was imported, false otherwise.
 */
goog.global.CLOSURE_IMPORT_SCRIPT;


/**
 * Null function used for default values of callbacks, etc.
 * @return {void} Nothing.
 */
goog.nullFunction = function () {
};


/**
 * The identity function. Returns its first argument.
 *
 * @param {*=} opt_returnValue The single value that will be returned.
 * @param {...*} var_args Optional trailing arguments. These are ignored.
 * @return {?} The first argument. We can't know the type -- just pass it along
 *      without type.
 * @deprecated Use goog.functions.identity instead.
 */
goog.identityFunction = function (opt_returnValue, var_args) {
    return opt_returnValue;
};


/**
 * When defining a class Foo with an abstract method bar(), you can do:
 * Foo.prototype.bar = goog.abstractMethod
 *
 * Now if a subclass of Foo fails to override bar(), an error will be thrown
 * when bar() is invoked.
 *
 * Note: This does not take the name of the function to override as an argument
 * because that would make it more difficult to obfuscate our JavaScript code.
 *
 * @type {!Function}
 * @throws {Error} when invoked to indicate the method should be overridden.
 */
goog.abstractMethod = function () {
    throw Error('unimplemented abstract method');
};


/**
 * Adds a {@code getInstance} static method that always returns the same
 * instance object.
 * @param {!Function} ctor The constructor for the class to add the static
 *     method to.
 */
goog.addSingletonGetter = function (ctor) {
    ctor.getInstance = function () {
        if (ctor.instance_) {
            return ctor.instance_;
        }
        if (goog.DEBUG) {
            // NOTE: JSCompiler can't optimize away Array#push.
            goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = ctor;
        }
        return ctor.instance_ = new ctor;
    };
};


/**
 * All singleton classes that have been instantiated, for testing. Don't read
 * it directly, use the {@code goog.testing.singleton} module. The compiler
 * removes this variable if unused.
 * @type {!Array.<!Function>}
 * @private
 */
goog.instantiatedSingletons_ = [];


/**
 * True if goog.dependencies_ is available.
 * @const {boolean}
 */
goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;


if (goog.DEPENDENCIES_ENABLED) {
    /**
     * Object used to keep track of urls that have already been added. This record
     * allows the prevention of circular dependencies.
     * @type {Object}
     * @private
     */
    goog.included_ = {};


    /**
     * This object is used to keep track of dependencies and other data that is
     * used for loading scripts.
     * @private
     * @type {Object}
     */
    goog.dependencies_ = {
        pathToNames: {}, // 1 to many
        nameToPath: {}, // 1 to 1
        requires: {}, // 1 to many
        // Used when resolving dependencies to prevent us from visiting file twice.
        visited: {},
        written: {} // Used to keep track of script files we have written.
    };


    /**
     * Tries to detect whether is in the context of an HTML document.
     * @return {boolean} True if it looks like HTML document.
     * @private
     */
    goog.inHtmlDocument_ = function () {
        var doc = goog.global.document;
        return typeof doc != 'undefined' &&
            'write' in doc;  // XULDocument misses write.
    };


    /**
     * Tries to detect the base path of base.js script that bootstraps Closure.
     * @private
     */
    goog.findBasePath_ = function () {
        if (goog.global.CLOSURE_BASE_PATH) {
            goog.basePath = goog.global.CLOSURE_BASE_PATH;
            return;
        } else if (!goog.inHtmlDocument_()) {
            return;
        }
        var doc = goog.global.document;
        var scripts = doc.getElementsByTagName('script');
        // Search backwards since the current script is in almost all cases the one
        // that has base.js.
        for (var i = scripts.length - 1; i >= 0; --i) {
            var src = scripts[i].src;
            var qmark = src.lastIndexOf('?');
            var l = qmark == -1 ? src.length : qmark;
            if (src.substr(l - 7, 7) == 'base.js') {
                goog.basePath = src.substr(0, l - 7);
                return;
            }
        }
    };


    /**
     * Imports a script if, and only if, that script hasn't already been imported.
     * (Must be called at execution time)
     * @param {string} src Script source.
     * @private
     */
    goog.importScript_ = function (src) {
        var importScript = goog.global.CLOSURE_IMPORT_SCRIPT ||
            goog.writeScriptTag_;
        if (!goog.dependencies_.written[src] && importScript(src)) {
            goog.dependencies_.written[src] = true;
        }
    };


    /**
     * The default implementation of the import function. Writes a script tag to
     * import the script.
     *
     * @param {string} src The script source.
     * @return {boolean} True if the script was imported, false otherwise.
     * @private
     */
    goog.writeScriptTag_ = function (src) {
        if (goog.inHtmlDocument_()) {
            var doc = goog.global.document;

            // If the user tries to require a new symbol after document load,
            // something has gone terribly wrong. Doing a document.write would
            // wipe out the page.
            if (doc.readyState == 'complete') {
                // Certain test frameworks load base.js multiple times, which tries
                // to write deps.js each time. If that happens, just fail silently.
                // These frameworks wipe the page between each load of base.js, so this
                // is OK.
                var isDeps = /\bdeps.js$/.test(src);
                if (isDeps) {
                    return false;
                } else {
                    throw Error('Cannot write "' + src + '" after document load');
                }
            }

            doc.write(
                '<script type="text/javascript" src="' + src + '"></' + 'script>');
            return true;
        } else {
            return false;
        }
    };


    /**
     * Resolves dependencies based on the dependencies added using addDependency
     * and calls importScript_ in the correct order.
     * @private
     */
    goog.writeScripts_ = function () {
        // The scripts we need to write this time.
        var scripts = [];
        var seenScript = {};
        var deps = goog.dependencies_;

        function visitNode(path) {
            if (path in deps.written) {
                return;
            }

            // We have already visited this one. We can get here if we have cyclic
            // dependencies.
            if (path in deps.visited) {
                if (!(path in seenScript)) {
                    seenScript[path] = true;
                    scripts.push(path);
                }
                return;
            }

            deps.visited[path] = true;

            if (path in deps.requires) {
                for (var requireName in deps.requires[path]) {
                    // If the required name is defined, we assume that it was already
                    // bootstrapped by other means.
                    if (!goog.isProvided_(requireName)) {
                        if (requireName in deps.nameToPath) {
                            visitNode(deps.nameToPath[requireName]);
                        } else {
                            throw Error('Undefined nameToPath for ' + requireName);
                        }
                    }
                }
            }

            if (!(path in seenScript)) {
                seenScript[path] = true;
                scripts.push(path);
            }
        }

        for (var path in goog.included_) {
            if (!deps.written[path]) {
                visitNode(path);
            }
        }

        for (var i = 0; i < scripts.length; i++) {
            if (scripts[i]) {
                goog.importScript_(goog.basePath + scripts[i]);
            } else {
                throw Error('Undefined script input');
            }
        }
    };


    /**
     * Looks at the dependency rules and tries to determine the script file that
     * fulfills a particular rule.
     * @param {string} rule In the form goog.namespace.Class or project.script.
     * @return {?string} Url corresponding to the rule, or null.
     * @private
     */
    goog.getPathFromDeps_ = function (rule) {
        if (rule in goog.dependencies_.nameToPath) {
            return goog.dependencies_.nameToPath[rule];
        } else {
            return null;
        }
    };

    goog.findBasePath_();

    // Allow projects to manage the deps files themselves.
    if (!goog.global.CLOSURE_NO_DEPS) {
        goog.importScript_(goog.basePath + 'deps.js');
    }
}


//==============================================================================
// Language Enhancements
//==============================================================================


/**
 * This is a "fixed" version of the typeof operator.  It differs from the typeof
 * operator in such a way that null returns 'null' and arrays return 'array'.
 * @param {*} value The value to get the type of.
 * @return {string} The name of the type.
 */
goog.typeOf = function (value) {
    var s = typeof value;
    if (s == 'object') {
        if (value) {
            // Check these first, so we can avoid calling Object.prototype.toString if
            // possible.
            //
            // IE improperly marshals tyepof across execution contexts, but a
            // cross-context object will still return false for "instanceof Object".
            if (value instanceof Array) {
                return 'array';
            } else if (value instanceof Object) {
                return s;
            }

            // HACK: In order to use an Object prototype method on the arbitrary
            //   value, the compiler requires the value be cast to type Object,
            //   even though the ECMA spec explicitly allows it.
            var className = Object.prototype.toString.call(
                /** @type {Object} */ (value));
            // In Firefox 3.6, attempting to access iframe window objects' length
            // property throws an NS_ERROR_FAILURE, so we need to special-case it
            // here.
            if (className == '[object Window]') {
                return 'object';
            }

            // We cannot always use constructor == Array or instanceof Array because
            // different frames have different Array objects. In IE6, if the iframe
            // where the array was created is destroyed, the array loses its
            // prototype. Then dereferencing val.splice here throws an exception, so
            // we can't use goog.isFunction. Calling typeof directly returns 'unknown'
            // so that will work. In this case, this function will return false and
            // most array functions will still work because the array is still
            // array-like (supports length and []) even though it has lost its
            // prototype.
            // Mark Miller noticed that Object.prototype.toString
            // allows access to the unforgeable [[Class]] property.
            //  15.2.4.2 Object.prototype.toString ( )
            //  When the toString method is called, the following steps are taken:
            //      1. Get the [[Class]] property of this object.
            //      2. Compute a string value by concatenating the three strings
            //         "[object ", Result(1), and "]".
            //      3. Return Result(2).
            // and this behavior survives the destruction of the execution context.
            if ((className == '[object Array]' ||
                // In IE all non value types are wrapped as objects across window
                // boundaries (not iframe though) so we have to do object detection
                // for this edge case.
                typeof value.length == 'number' &&
                    typeof value.splice != 'undefined' &&
                    typeof value.propertyIsEnumerable != 'undefined' && !value.propertyIsEnumerable('splice')

                )) {
                return 'array';
            }
            // HACK: There is still an array case that fails.
            //     function ArrayImpostor() {}
            //     ArrayImpostor.prototype = [];
            //     var impostor = new ArrayImpostor;
            // this can be fixed by getting rid of the fast path
            // (value instanceof Array) and solely relying on
            // (value && Object.prototype.toString.vall(value) === '[object Array]')
            // but that would require many more function calls and is not warranted
            // unless closure code is receiving objects from untrusted sources.

            // IE in cross-window calls does not correctly marshal the function type
            // (it appears just as an object) so we cannot use just typeof val ==
            // 'function'. However, if the object has a call property, it is a
            // function.
            if ((className == '[object Function]' ||
                typeof value.call != 'undefined' &&
                    typeof value.propertyIsEnumerable != 'undefined' && !value.propertyIsEnumerable('call'))) {
                return 'function';
            }

        } else {
            return 'null';
        }

    } else if (s == 'function' && typeof value.call == 'undefined') {
        // In Safari typeof nodeList returns 'function', and on Firefox typeof
        // behaves similarly for HTML{Applet,Embed,Object}, Elements and RegExps. We
        // would like to return object for those and we can detect an invalid
        // function by making sure that the function object has a call method.
        return 'object';
    }
    return s;
};


/**
 * Returns true if the specified value is not undefined.
 * WARNING: Do not use this to test if an object has a property. Use the in
 * operator instead.  Additionally, this function assumes that the global
 * undefined variable has not been redefined.
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is defined.
 */
goog.isDef = function (val) {
    return val !== undefined;
};


/**
 * Returns true if the specified value is null.
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is null.
 */
goog.isNull = function (val) {
    return val === null;
};


/**
 * Returns true if the specified value is defined and not null.
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is defined and not null.
 */
goog.isDefAndNotNull = function (val) {
    // Note that undefined == null.
    return val != null;
};


/**
 * Returns true if the specified value is an array.
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is an array.
 */
goog.isArray = function (val) {
    return goog.typeOf(val) == 'array';
};


/**
 * Returns true if the object looks like an array. To qualify as array like
 * the value needs to be either a NodeList or an object with a Number length
 * property.
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is an array.
 */
goog.isArrayLike = function (val) {
    var type = goog.typeOf(val);
    return type == 'array' || type == 'object' && typeof val.length == 'number';
};


/**
 * Returns true if the object looks like a Date. To qualify as Date-like the
 * value needs to be an object and have a getFullYear() function.
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is a like a Date.
 */
goog.isDateLike = function (val) {
    return goog.isObject(val) && typeof val.getFullYear == 'function';
};


/**
 * Returns true if the specified value is a string.
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is a string.
 */
goog.isString = function (val) {
    return typeof val == 'string';
};


/**
 * Returns true if the specified value is a boolean.
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is boolean.
 */
goog.isBoolean = function (val) {
    return typeof val == 'boolean';
};


/**
 * Returns true if the specified value is a number.
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is a number.
 */
goog.isNumber = function (val) {
    return typeof val == 'number';
};


/**
 * Returns true if the specified value is a function.
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is a function.
 */
goog.isFunction = function (val) {
    return goog.typeOf(val) == 'function';
};


/**
 * Returns true if the specified value is an object.  This includes arrays and
 * functions.
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is an object.
 */
goog.isObject = function (val) {
    var type = typeof val;
    return type == 'object' && val != null || type == 'function';
    // return Object(val) === val also works, but is slower, especially if val is
    // not an object.
};


/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. The unique ID is
 * guaranteed to be unique across the current session amongst objects that are
 * passed into {@code getUid}. There is no guarantee that the ID is unique or
 * consistent across sessions. It is unsafe to generate unique ID for function
 * prototypes.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {number} The unique ID for the object.
 */
goog.getUid = function (obj) {
    // TODO(arv): Make the type stricter, do not accept null.

    // In Opera window.hasOwnProperty exists but always returns false so we avoid
    // using it. As a consequence the unique ID generated for BaseClass.prototype
    // and SubClass.prototype will be the same.
    return obj[goog.UID_PROPERTY_] ||
        (obj[goog.UID_PROPERTY_] = ++goog.uidCounter_);
};


/**
 * Whether the given object is alreay assigned a unique ID.
 *
 * This does not modify the object.
 *
 * @param {Object} obj The object to check.
 * @return {boolean} Whether there an assigned unique id for the object.
 */
goog.hasUid = function (obj) {
    return !!obj[goog.UID_PROPERTY_];
};


/**
 * Removes the unique ID from an object. This is useful if the object was
 * previously mutated using {@code goog.getUid} in which case the mutation is
 * undone.
 * @param {Object} obj The object to remove the unique ID field from.
 */
goog.removeUid = function (obj) {
    // TODO(arv): Make the type stricter, do not accept null.

    // In IE, DOM nodes are not instances of Object and throw an exception if we
    // try to delete.  Instead we try to use removeAttribute.
    if ('removeAttribute' in obj) {
        obj.removeAttribute(goog.UID_PROPERTY_);
    }
    /** @preserveTry */
    try {
        delete obj[goog.UID_PROPERTY_];
    } catch (ex) {
    }
};


/**
 * Name for unique ID property. Initialized in a way to help avoid collisions
 * with other closure JavaScript on the same page.
 * @type {string}
 * @private
 */
goog.UID_PROPERTY_ = 'closure_uid_' + ((Math.random() * 1e9) >>> 0);


/**
 * Counter for UID.
 * @type {number}
 * @private
 */
goog.uidCounter_ = 0;


/**
 * Adds a hash code field to an object. The hash code is unique for the
 * given object.
 * @param {Object} obj The object to get the hash code for.
 * @return {number} The hash code for the object.
 * @deprecated Use goog.getUid instead.
 */
goog.getHashCode = goog.getUid;


/**
 * Removes the hash code field from an object.
 * @param {Object} obj The object to remove the field from.
 * @deprecated Use goog.removeUid instead.
 */
goog.removeHashCode = goog.removeUid;


/**
 * Clones a value. The input may be an Object, Array, or basic type. Objects and
 * arrays will be cloned recursively.
 *
 * WARNINGS:
 * <code>goog.cloneObject</code> does not detect reference loops. Objects that
 * refer to themselves will cause infinite recursion.
 *
 * <code>goog.cloneObject</code> is unaware of unique identifiers, and copies
 * UIDs created by <code>getUid</code> into cloned results.
 *
 * @param {*} obj The value to clone.
 * @return {*} A clone of the input value.
 * @deprecated goog.cloneObject is unsafe. Prefer the goog.object methods.
 */
goog.cloneObject = function (obj) {
    var type = goog.typeOf(obj);
    if (type == 'object' || type == 'array') {
        if (obj.clone) {
            return obj.clone();
        }
        var clone = type == 'array' ? [] : {};
        for (var key in obj) {
            clone[key] = goog.cloneObject(obj[key]);
        }
        return clone;
    }

    return obj;
};


/**
 * A native implementation of goog.bind.
 * @param {Function} fn A function to partially apply.
 * @param {Object|undefined} selfObj Specifies the object which this should
 *     point to when the function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 * @private
 * @suppress {deprecated} The compiler thinks that Function.prototype.bind is
 *     deprecated because some people have declared a pure-JS version.
 *     Only the pure-JS version is truly deprecated.
 */
goog.bindNative_ = function (fn, selfObj, var_args) {
    return /** @type {!Function} */ (fn.call.apply(fn.bind, arguments));
};


/**
 * A pure-JS implementation of goog.bind.
 * @param {Function} fn A function to partially apply.
 * @param {Object|undefined} selfObj Specifies the object which this should
 *     point to when the function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 * @private
 */
goog.bindJs_ = function (fn, selfObj, var_args) {
    if (!fn) {
        throw new Error();
    }

    if (arguments.length > 2) {
        var boundArgs = Array.prototype.slice.call(arguments, 2);
        return function () {
            // Prepend the bound arguments to the current arguments.
            var newArgs = Array.prototype.slice.call(arguments);
            Array.prototype.unshift.apply(newArgs, boundArgs);
            return fn.apply(selfObj, newArgs);
        };

    } else {
        return function () {
            return fn.apply(selfObj, arguments);
        };
    }
};


/**
 * Partially applies this function to a particular 'this object' and zero or
 * more arguments. The result is a new function with some arguments of the first
 * function pre-filled and the value of this 'pre-specified'.
 *
 * Remaining arguments specified at call-time are appended to the pre-specified
 * ones.
 *
 * Also see: {@link #partial}.
 *
 * Usage:
 * <pre>var barMethBound = bind(myFunction, myObj, 'arg1', 'arg2');
 * barMethBound('arg3', 'arg4');</pre>
 *
 * @param {?function(this:T, ...)} fn A function to partially apply.
 * @param {T} selfObj Specifies the object which this should point to when the
 *     function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 * @template T
 * @suppress {deprecated} See above.
 */
goog.bind = function (fn, selfObj, var_args) {
    // TODO(nicksantos): narrow the type signature.
    if (Function.prototype.bind &&
        // NOTE(nicksantos): Somebody pulled base.js into the default Chrome
        // extension environment. This means that for Chrome extensions, they get
        // the implementation of Function.prototype.bind that calls goog.bind
        // instead of the native one. Even worse, we don't want to introduce a
        // circular dependency between goog.bind and Function.prototype.bind, so
        // we have to hack this to make sure it works correctly.
        Function.prototype.bind.toString().indexOf('native code') != -1) {
        goog.bind = goog.bindNative_;
    } else {
        goog.bind = goog.bindJs_;
    }
    return goog.bind.apply(null, arguments);
};


/**
 * Like bind(), except that a 'this object' is not required. Useful when the
 * target function is already bound.
 *
 * Usage:
 * var g = partial(f, arg1, arg2);
 * g(arg3, arg4);
 *
 * @param {Function} fn A function to partially apply.
 * @param {...*} var_args Additional arguments that are partially applied to fn.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 */
goog.partial = function (fn, var_args) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function () {
        // Clone the array (with slice()) and append additional arguments
        // to the existing arguments.
        var newArgs = args.slice();
        newArgs.push.apply(newArgs, arguments);
        return fn.apply(this, newArgs);
    };
};


/**
 * Copies all the members of a source object to a target object. This method
 * does not work on all browsers for all objects that contain keys such as
 * toString or hasOwnProperty. Use goog.object.extend for this purpose.
 * @param {Object} target Target.
 * @param {Object} source Source.
 */
goog.mixin = function (target, source) {
    for (var x in source) {
        target[x] = source[x];
    }

    // For IE7 or lower, the for-in-loop does not contain any properties that are
    // not enumerable on the prototype object (for example, isPrototypeOf from
    // Object.prototype) but also it will not include 'replace' on objects that
    // extend String and change 'replace' (not that it is common for anyone to
    // extend anything except Object).
};


/**
 * @return {number} An integer value representing the number of milliseconds
 *     between midnight, January 1, 1970 and the current time.
 */
goog.now = (goog.TRUSTED_SITE && Date.now) || (function () {
    // Unary plus operator converts its operand to a number which in the case of
    // a date is done by calling getTime().
    return +new Date();
});


/**
 * Evals JavaScript in the global scope.  In IE this uses execScript, other
 * browsers use goog.global.eval. If goog.global.eval does not evaluate in the
 * global scope (for example, in Safari), appends a script tag instead.
 * Throws an exception if neither execScript or eval is defined.
 * @param {string} script JavaScript string.
 */
goog.globalEval = function (script) {
    if (goog.global.execScript) {
        goog.global.execScript(script, 'JavaScript');
    } else if (goog.global.eval) {
        // Test to see if eval works
        if (goog.evalWorksForGlobals_ == null) {
            goog.global.eval('var _et_ = 1;');
            if (typeof goog.global['_et_'] != 'undefined') {
                delete goog.global['_et_'];
                goog.evalWorksForGlobals_ = true;
            } else {
                goog.evalWorksForGlobals_ = false;
            }
        }

        if (goog.evalWorksForGlobals_) {
            goog.global.eval(script);
        } else {
            var doc = goog.global.document;
            var scriptElt = doc.createElement('script');
            scriptElt.type = 'text/javascript';
            scriptElt.defer = false;
            // Note(user): can't use .innerHTML since "t('<test>')" will fail and
            // .text doesn't work in Safari 2.  Therefore we append a text node.
            scriptElt.appendChild(doc.createTextNode(script));
            doc.body.appendChild(scriptElt);
            doc.body.removeChild(scriptElt);
        }
    } else {
        throw Error('goog.globalEval not available');
    }
};


/**
 * Indicates whether or not we can call 'eval' directly to eval code in the
 * global scope. Set to a Boolean by the first call to goog.globalEval (which
 * empirically tests whether eval works for globals). @see goog.globalEval
 * @type {?boolean}
 * @private
 */
goog.evalWorksForGlobals_ = null;


/**
 * Optional map of CSS class names to obfuscated names used with
 * goog.getCssName().
 * @type {Object|undefined}
 * @private
 * @see goog.setCssNameMapping
 */
goog.cssNameMapping_;


/**
 * Optional obfuscation style for CSS class names. Should be set to either
 * 'BY_WHOLE' or 'BY_PART' if defined.
 * @type {string|undefined}
 * @private
 * @see goog.setCssNameMapping
 */
goog.cssNameMappingStyle_;


/**
 * Handles strings that are intended to be used as CSS class names.
 *
 * This function works in tandem with @see goog.setCssNameMapping.
 *
 * Without any mapping set, the arguments are simple joined with a hyphen and
 * passed through unaltered.
 *
 * When there is a mapping, there are two possible styles in which these
 * mappings are used. In the BY_PART style, each part (i.e. in between hyphens)
 * of the passed in css name is rewritten according to the map. In the BY_WHOLE
 * style, the full css name is looked up in the map directly. If a rewrite is
 * not specified by the map, the compiler will output a warning.
 *
 * When the mapping is passed to the compiler, it will replace calls to
 * goog.getCssName with the strings from the mapping, e.g.
 *     var x = goog.getCssName('foo');
 *     var y = goog.getCssName(this.baseClass, 'active');
 *  becomes:
 *     var x= 'foo';
 *     var y = this.baseClass + '-active';
 *
 * If one argument is passed it will be processed, if two are passed only the
 * modifier will be processed, as it is assumed the first argument was generated
 * as a result of calling goog.getCssName.
 *
 * @param {string} className The class name.
 * @param {string=} opt_modifier A modifier to be appended to the class name.
 * @return {string} The class name or the concatenation of the class name and
 *     the modifier.
 */
goog.getCssName = function (className, opt_modifier) {
    var getMapping = function (cssName) {
        return goog.cssNameMapping_[cssName] || cssName;
    };

    var renameByParts = function (cssName) {
        // Remap all the parts individually.
        var parts = cssName.split('-');
        var mapped = [];
        for (var i = 0; i < parts.length; i++) {
            mapped.push(getMapping(parts[i]));
        }
        return mapped.join('-');
    };

    var rename;
    if (goog.cssNameMapping_) {
        rename = goog.cssNameMappingStyle_ == 'BY_WHOLE' ?
            getMapping : renameByParts;
    } else {
        rename = function (a) {
            return a;
        };
    }

    if (opt_modifier) {
        return className + '-' + rename(opt_modifier);
    } else {
        return rename(className);
    }
};


/**
 * Sets the map to check when returning a value from goog.getCssName(). Example:
 * <pre>
 * goog.setCssNameMapping({
 *   "goog": "a",
 *   "disabled": "b",
 * });
 *
 * var x = goog.getCssName('goog');
 * // The following evaluates to: "a a-b".
 * goog.getCssName('goog') + ' ' + goog.getCssName(x, 'disabled')
 * </pre>
 * When declared as a map of string literals to string literals, the JSCompiler
 * will replace all calls to goog.getCssName() using the supplied map if the
 * --closure_pass flag is set.
 *
 * @param {!Object} mapping A map of strings to strings where keys are possible
 *     arguments to goog.getCssName() and values are the corresponding values
 *     that should be returned.
 * @param {string=} opt_style The style of css name mapping. There are two valid
 *     options: 'BY_PART', and 'BY_WHOLE'.
 * @see goog.getCssName for a description.
 */
goog.setCssNameMapping = function (mapping, opt_style) {
    goog.cssNameMapping_ = mapping;
    goog.cssNameMappingStyle_ = opt_style;
};


/**
 * To use CSS renaming in compiled mode, one of the input files should have a
 * call to goog.setCssNameMapping() with an object literal that the JSCompiler
 * can extract and use to replace all calls to goog.getCssName(). In uncompiled
 * mode, JavaScript code should be loaded before this base.js file that declares
 * a global variable, CLOSURE_CSS_NAME_MAPPING, which is used below. This is
 * to ensure that the mapping is loaded before any calls to goog.getCssName()
 * are made in uncompiled mode.
 *
 * A hook for overriding the CSS name mapping.
 * @type {Object|undefined}
 */
goog.global.CLOSURE_CSS_NAME_MAPPING;


if (!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING) {
    // This does not call goog.setCssNameMapping() because the JSCompiler
    // requires that goog.setCssNameMapping() be called with an object literal.
    goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING;
}


/**
 * Gets a localized message.
 *
 * This function is a compiler primitive. If you give the compiler a localized
 * message bundle, it will replace the string at compile-time with a localized
 * version, and expand goog.getMsg call to a concatenated string.
 *
 * Messages must be initialized in the form:
 * <code>
 * var MSG_NAME = goog.getMsg('Hello {$placeholder}', {'placeholder': 'world'});
 * </code>
 *
 * @param {string} str Translatable string, places holders in the form {$foo}.
 * @param {Object=} opt_values Map of place holder name to value.
 * @return {string} message with placeholders filled.
 */
goog.getMsg = function (str, opt_values) {
    var values = opt_values || {};
    for (var key in values) {
        var value = ('' + values[key]).replace(/\$/g, '$$$$');
        str = str.replace(new RegExp('\\{\\$' + key + '\\}', 'gi'), value);
    }
    return str;
};


/**
 * Gets a localized message. If the message does not have a translation, gives a
 * fallback message.
 *
 * This is useful when introducing a new message that has not yet been
 * translated into all languages.
 *
 * This function is a compiler primtive. Must be used in the form:
 * <code>var x = goog.getMsgWithFallback(MSG_A, MSG_B);</code>
 * where MSG_A and MSG_B were initialized with goog.getMsg.
 *
 * @param {string} a The preferred message.
 * @param {string} b The fallback message.
 * @return {string} The best translated message.
 */
goog.getMsgWithFallback = function (a, b) {
    return a;
};


/**
 * Exposes an unobfuscated global namespace path for the given object.
 * Note that fields of the exported object *will* be obfuscated, unless they are
 * exported in turn via this function or goog.exportProperty.
 *
 * Also handy for making public items that are defined in anonymous closures.
 *
 * ex. goog.exportSymbol('public.path.Foo', Foo);
 *
 * ex. goog.exportSymbol('public.path.Foo.staticFunction', Foo.staticFunction);
 *     public.path.Foo.staticFunction();
 *
 * ex. goog.exportSymbol('public.path.Foo.prototype.myMethod',
 *                       Foo.prototype.myMethod);
 *     new public.path.Foo().myMethod();
 *
 * @param {string} publicPath Unobfuscated name to export.
 * @param {*} object Object the name should point to.
 * @param {Object=} opt_objectToExportTo The object to add the path to; default
 *     is goog.global.
 */
goog.exportSymbol = function (publicPath, object, opt_objectToExportTo) {
    goog.exportPath_(publicPath, object, opt_objectToExportTo);
};


/**
 * Exports a property unobfuscated into the object's namespace.
 * ex. goog.exportProperty(Foo, 'staticFunction', Foo.staticFunction);
 * ex. goog.exportProperty(Foo.prototype, 'myMethod', Foo.prototype.myMethod);
 * @param {Object} object Object whose static property is being exported.
 * @param {string} publicName Unobfuscated name to export.
 * @param {*} symbol Object the name should point to.
 */
goog.exportProperty = function (object, publicName, symbol) {
    object[publicName] = symbol;
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * Usage:
 * <pre>
 * function ParentClass(a, b) { }
 * ParentClass.prototype.foo = function(a) { }
 *
 * function ChildClass(a, b, c) {
 *   goog.base(this, a, b);
 * }
 * goog.inherits(ChildClass, ParentClass);
 *
 * var child = new ChildClass('a', 'b', 'see');
 * child.foo(); // This works.
 * </pre>
 *
 * In addition, a superclass' implementation of a method can be invoked as
 * follows:
 *
 * <pre>
 * ChildClass.prototype.foo = function(a) {
 *   ChildClass.superClass_.foo.call(this, a);
 *   // Other code here.
 * };
 * </pre>
 *
 * @param {Function} childCtor Child class.
 * @param {Function} parentCtor Parent class.
 */
goog.inherits = function (childCtor, parentCtor) {
    /** @constructor */
    function tempCtor() {
    };
    tempCtor.prototype = parentCtor.prototype;
    childCtor.superClass_ = parentCtor.prototype;
    childCtor.prototype = new tempCtor();
    /** @override */
    childCtor.prototype.constructor = childCtor;
};


/**
 * Call up to the superclass.
 *
 * If this is called from a constructor, then this calls the superclass
 * contsructor with arguments 1-N.
 *
 * If this is called from a prototype method, then you must pass the name of the
 * method as the second argument to this function. If you do not, you will get a
 * runtime error. This calls the superclass' method with arguments 2-N.
 *
 * This function only works if you use goog.inherits to express inheritance
 * relationships between your classes.
 *
 * This function is a compiler primitive. At compile-time, the compiler will do
 * macro expansion to remove a lot of the extra overhead that this function
 * introduces. The compiler will also enforce a lot of the assumptions that this
 * function makes, and treat it as a compiler error if you break them.
 *
 * @param {!Object} me Should always be "this".
 * @param {*=} opt_methodName The method name if calling a super method.
 * @param {...*} var_args The rest of the arguments.
 * @return {*} The return value of the superclass method.
 */
goog.base = function (me, opt_methodName, var_args) {
    var caller = arguments.callee.caller;

    if (goog.DEBUG) {
        if (!caller) {
            throw Error('arguments.caller not defined.  goog.base() expects not ' +
                'to be running in strict mode. See ' +
                'http://www.ecma-international.org/ecma-262/5.1/#sec-C');
        }
    }

    if (caller.superClass_) {
        // This is a constructor. Call the superclass constructor.
        return caller.superClass_.constructor.apply(
            me, Array.prototype.slice.call(arguments, 1));
    }

    var args = Array.prototype.slice.call(arguments, 2);
    var foundCaller = false;
    for (var ctor = me.constructor;
         ctor; ctor = ctor.superClass_ && ctor.superClass_.constructor) {
        if (ctor.prototype[opt_methodName] === caller) {
            foundCaller = true;
        } else if (foundCaller) {
            return ctor.prototype[opt_methodName].apply(me, args);
        }
    }

    // If we did not find the caller in the prototype chain, then one of two
    // things happened:
    // 1) The caller is an instance method.
    // 2) This method was not called by the right caller.
    if (me[opt_methodName] === caller) {
        return me.constructor.prototype[opt_methodName].apply(me, args);
    } else {
        throw Error(
            'goog.base called from a method of one name ' +
                'to a method of a different name');
    }
};


/**
 * Allow for aliasing within scope functions.  This function exists for
 * uncompiled code - in compiled code the calls will be inlined and the aliases
 * applied.  In uncompiled code the function is simply run since the aliases as
 * written are valid JavaScript.
 * @param {function()} fn Function to call.  This function can contain aliases
 *     to namespaces (e.g. "var dom = goog.dom") or classes
 *     (e.g. "var Timer = goog.Timer").
 */
goog.scope = function (fn) {
    fn.call(goog.global);
};


// Input 1
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview Context information about nodes in their nodeset.
 */

goog.provide('wgxpath.Context');


/**
 * Provides information for where something is in the DOM.
 *
 * @param {!wgxpath.Node} node A node in the DOM.
 * @param {number=} opt_position The position of this node in its nodeset,
 *     defaults to 1.
 * @param {number=} opt_last Index of the last node in this nodeset,
 *     defaults to 1.
 * @constructor
 */
wgxpath.Context = function (node, opt_position, opt_last) {

    /**
     * @private
     * @type {!wgxpath.Node}
     */
    this.node_ = node;

    /**
     * @private
     * @type {number}
     */
    this.position_ = opt_position || 1;

    /**
     * @private
     * @type {number} opt_last
     */
    this.last_ = opt_last || 1;
};


/**
 * Returns the node for this context object.
 *
 * @return {!wgxpath.Node} The node for this context object.
 */
wgxpath.Context.prototype.getNode = function () {
    return this.node_;
};


/**
 * Returns the position for this context object.
 *
 * @return {number} The position for this context object.
 */
wgxpath.Context.prototype.getPosition = function () {
    return this.position_;
};


/**
 * Returns the last field for this context object.
 *
 * @return {number} The last field for this context object.
 */
wgxpath.Context.prototype.getLast = function () {
    return this.last_;
};

// Input 2
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition of goog.dom.NodeType.
 */

goog.provide('goog.dom.NodeType');


/**
 * Constants for the nodeType attribute in the Node interface.
 *
 * These constants match those specified in the Node interface. These are
 * usually present on the Node object in recent browsers, but not in older
 * browsers (specifically, early IEs) and thus are given here.
 *
 * In some browsers (early IEs), these are not defined on the Node object,
 * so they are provided here.
 *
 * See http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-1950641247
 * @enum {number}
 */
goog.dom.NodeType = {
    ELEMENT: 1,
    ATTRIBUTE: 2,
    TEXT: 3,
    CDATA_SECTION: 4,
    ENTITY_REFERENCE: 5,
    ENTITY: 6,
    PROCESSING_INSTRUCTION: 7,
    COMMENT: 8,
    DOCUMENT: 9,
    DOCUMENT_TYPE: 10,
    DOCUMENT_FRAGMENT: 11,
    NOTATION: 12
};

// Input 3
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for string manipulation.
 */


/**
 * Namespace for string utilities
 */
goog.provide('goog.string');
goog.provide('goog.string.Unicode');


/**
 * Common Unicode string characters.
 * @enum {string}
 */
goog.string.Unicode = {
    NBSP: '\xa0'
};


/**
 * Fast prefix-checker.
 * @param {string} str The string to check.
 * @param {string} prefix A string to look for at the start of {@code str}.
 * @return {boolean} True if {@code str} begins with {@code prefix}.
 */
goog.string.startsWith = function (str, prefix) {
    return str.lastIndexOf(prefix, 0) == 0;
};


/**
 * Fast suffix-checker.
 * @param {string} str The string to check.
 * @param {string} suffix A string to look for at the end of {@code str}.
 * @return {boolean} True if {@code str} ends with {@code suffix}.
 */
goog.string.endsWith = function (str, suffix) {
    var l = str.length - suffix.length;
    return l >= 0 && str.indexOf(suffix, l) == l;
};


/**
 * Case-insensitive prefix-checker.
 * @param {string} str The string to check.
 * @param {string} prefix  A string to look for at the end of {@code str}.
 * @return {boolean} True if {@code str} begins with {@code prefix} (ignoring
 *     case).
 */
goog.string.caseInsensitiveStartsWith = function (str, prefix) {
    return goog.string.caseInsensitiveCompare(
        prefix, str.substr(0, prefix.length)) == 0;
};


/**
 * Case-insensitive suffix-checker.
 * @param {string} str The string to check.
 * @param {string} suffix A string to look for at the end of {@code str}.
 * @return {boolean} True if {@code str} ends with {@code suffix} (ignoring
 *     case).
 */
goog.string.caseInsensitiveEndsWith = function (str, suffix) {
    return goog.string.caseInsensitiveCompare(
        suffix, str.substr(str.length - suffix.length, suffix.length)) == 0;
};


/**
 * Case-insensitive equality checker.
 * @param {string} str1 First string to check.
 * @param {string} str2 Second string to check.
 * @return {boolean} True if {@code str1} and {@code str2} are the same string,
 *     ignoring case.
 */
goog.string.caseInsensitiveEquals = function (str1, str2) {
    return str1.toLowerCase() == str2.toLowerCase();
};


/**
 * Does simple python-style string substitution.
 * subs("foo%s hot%s", "bar", "dog") becomes "foobar hotdog".
 * @param {string} str The string containing the pattern.
 * @param {...*} var_args The items to substitute into the pattern.
 * @return {string} A copy of {@code str} in which each occurrence of
 *     {@code %s} has been replaced an argument from {@code var_args}.
 */
goog.string.subs = function (str, var_args) {
    var splitParts = str.split('%s');
    var returnString = '';

    var subsArguments = Array.prototype.slice.call(arguments, 1);
    while (subsArguments.length &&
        // Replace up to the last split part. We are inserting in the
        // positions between split parts.
        splitParts.length > 1) {
        returnString += splitParts.shift() + subsArguments.shift();
    }

    return returnString + splitParts.join('%s'); // Join unused '%s'
};


/**
 * Converts multiple whitespace chars (spaces, non-breaking-spaces, new lines
 * and tabs) to a single space, and strips leading and trailing whitespace.
 * @param {string} str Input string.
 * @return {string} A copy of {@code str} with collapsed whitespace.
 */
goog.string.collapseWhitespace = function (str) {
    // Since IE doesn't include non-breaking-space (0xa0) in their \s character
    // class (as required by section 7.2 of the ECMAScript spec), we explicitly
    // include it in the regexp to enforce consistent cross-browser behavior.
    return str.replace(/[\s\xa0]+/g, ' ').replace(/^\s+|\s+$/g, '');
};


/**
 * Checks if a string is empty or contains only whitespaces.
 * @param {string} str The string to check.
 * @return {boolean} True if {@code str} is empty or whitespace only.
 */
goog.string.isEmpty = function (str) {
    // testing length == 0 first is actually slower in all browsers (about the
    // same in Opera).
    // Since IE doesn't include non-breaking-space (0xa0) in their \s character
    // class (as required by section 7.2 of the ECMAScript spec), we explicitly
    // include it in the regexp to enforce consistent cross-browser behavior.
    return /^[\s\xa0]*$/.test(str);
};


/**
 * Checks if a string is null, undefined, empty or contains only whitespaces.
 * @param {*} str The string to check.
 * @return {boolean} True if{@code str} is null, undefined, empty, or
 *     whitespace only.
 */
goog.string.isEmptySafe = function (str) {
    return goog.string.isEmpty(goog.string.makeSafe(str));
};


/**
 * Checks if a string is all breaking whitespace.
 * @param {string} str The string to check.
 * @return {boolean} Whether the string is all breaking whitespace.
 */
goog.string.isBreakingWhitespace = function (str) {
    return !/[^\t\n\r ]/.test(str);
};


/**
 * Checks if a string contains all letters.
 * @param {string} str string to check.
 * @return {boolean} True if {@code str} consists entirely of letters.
 */
goog.string.isAlpha = function (str) {
    return !/[^a-zA-Z]/.test(str);
};


/**
 * Checks if a string contains only numbers.
 * @param {*} str string to check. If not a string, it will be
 *     casted to one.
 * @return {boolean} True if {@code str} is numeric.
 */
goog.string.isNumeric = function (str) {
    return !/[^0-9]/.test(str);
};


/**
 * Checks if a string contains only numbers or letters.
 * @param {string} str string to check.
 * @return {boolean} True if {@code str} is alphanumeric.
 */
goog.string.isAlphaNumeric = function (str) {
    return !/[^a-zA-Z0-9]/.test(str);
};


/**
 * Checks if a character is a space character.
 * @param {string} ch Character to check.
 * @return {boolean} True if {code ch} is a space.
 */
goog.string.isSpace = function (ch) {
    return ch == ' ';
};


/**
 * Checks if a character is a valid unicode character.
 * @param {string} ch Character to check.
 * @return {boolean} True if {code ch} is a valid unicode character.
 */
goog.string.isUnicodeChar = function (ch) {
    return ch.length == 1 && ch >= ' ' && ch <= '~' ||
        ch >= '\u0080' && ch <= '\uFFFD';
};


/**
 * Takes a string and replaces newlines with a space. Multiple lines are
 * replaced with a single space.
 * @param {string} str The string from which to strip newlines.
 * @return {string} A copy of {@code str} stripped of newlines.
 */
goog.string.stripNewlines = function (str) {
    return str.replace(/(\r\n|\r|\n)+/g, ' ');
};


/**
 * Replaces Windows and Mac new lines with unix style: \r or \r\n with \n.
 * @param {string} str The string to in which to canonicalize newlines.
 * @return {string} {@code str} A copy of {@code} with canonicalized newlines.
 */
goog.string.canonicalizeNewlines = function (str) {
    return str.replace(/(\r\n|\r|\n)/g, '\n');
};


/**
 * Normalizes whitespace in a string, replacing all whitespace chars with
 * a space.
 * @param {string} str The string in which to normalize whitespace.
 * @return {string} A copy of {@code str} with all whitespace normalized.
 */
goog.string.normalizeWhitespace = function (str) {
    return str.replace(/\xa0|\s/g, ' ');
};


/**
 * Normalizes spaces in a string, replacing all consecutive spaces and tabs
 * with a single space. Replaces non-breaking space with a space.
 * @param {string} str The string in which to normalize spaces.
 * @return {string} A copy of {@code str} with all consecutive spaces and tabs
 *    replaced with a single space.
 */
goog.string.normalizeSpaces = function (str) {
    return str.replace(/\xa0|[ \t]+/g, ' ');
};


/**
 * Removes the breaking spaces from the left and right of the string and
 * collapses the sequences of breaking spaces in the middle into single spaces.
 * The original and the result strings render the same way in HTML.
 * @param {string} str A string in which to collapse spaces.
 * @return {string} Copy of the string with normalized breaking spaces.
 */
goog.string.collapseBreakingSpaces = function (str) {
    return str.replace(/[\t\r\n ]+/g, ' ').replace(
        /^[\t\r\n ]+|[\t\r\n ]+$/g, '');
};


/**
 * Trims white spaces to the left and right of a string.
 * @param {string} str The string to trim.
 * @return {string} A trimmed copy of {@code str}.
 */
goog.string.trim = function (str) {
    // Since IE doesn't include non-breaking-space (0xa0) in their \s character
    // class (as required by section 7.2 of the ECMAScript spec), we explicitly
    // include it in the regexp to enforce consistent cross-browser behavior.
    return str.replace(/^[\s\xa0]+|[\s\xa0]+$/g, '');
};


/**
 * Trims whitespaces at the left end of a string.
 * @param {string} str The string to left trim.
 * @return {string} A trimmed copy of {@code str}.
 */
goog.string.trimLeft = function (str) {
    // Since IE doesn't include non-breaking-space (0xa0) in their \s character
    // class (as required by section 7.2 of the ECMAScript spec), we explicitly
    // include it in the regexp to enforce consistent cross-browser behavior.
    return str.replace(/^[\s\xa0]+/, '');
};


/**
 * Trims whitespaces at the right end of a string.
 * @param {string} str The string to right trim.
 * @return {string} A trimmed copy of {@code str}.
 */
goog.string.trimRight = function (str) {
    // Since IE doesn't include non-breaking-space (0xa0) in their \s character
    // class (as required by section 7.2 of the ECMAScript spec), we explicitly
    // include it in the regexp to enforce consistent cross-browser behavior.
    return str.replace(/[\s\xa0]+$/, '');
};


/**
 * A string comparator that ignores case.
 * -1 = str1 less than str2
 *  0 = str1 equals str2
 *  1 = str1 greater than str2
 *
 * @param {string} str1 The string to compare.
 * @param {string} str2 The string to compare {@code str1} to.
 * @return {number} The comparator result, as described above.
 */
goog.string.caseInsensitiveCompare = function (str1, str2) {
    var test1 = String(str1).toLowerCase();
    var test2 = String(str2).toLowerCase();

    if (test1 < test2) {
        return -1;
    } else if (test1 == test2) {
        return 0;
    } else {
        return 1;
    }
};


/**
 * Regular expression used for splitting a string into substrings of fractional
 * numbers, integers, and non-numeric characters.
 * @type {RegExp}
 * @private
 */
goog.string.numerateCompareRegExp_ = /(\.\d+)|(\d+)|(\D+)/g;


/**
 * String comparison function that handles numbers in a way humans might expect.
 * Using this function, the string "File 2.jpg" sorts before "File 10.jpg". The
 * comparison is mostly case-insensitive, though strings that are identical
 * except for case are sorted with the upper-case strings before lower-case.
 *
 * This comparison function is significantly slower (about 500x) than either
 * the default or the case-insensitive compare. It should not be used in
 * time-critical code, but should be fast enough to sort several hundred short
 * strings (like filenames) with a reasonable delay.
 *
 * @param {string} str1 The string to compare in a numerically sensitive way.
 * @param {string} str2 The string to compare {@code str1} to.
 * @return {number} less than 0 if str1 < str2, 0 if str1 == str2, greater than
 *     0 if str1 > str2.
 */
goog.string.numerateCompare = function (str1, str2) {
    if (str1 == str2) {
        return 0;
    }
    if (!str1) {
        return -1;
    }
    if (!str2) {
        return 1;
    }

    // Using match to split the entire string ahead of time turns out to be faster
    // for most inputs than using RegExp.exec or iterating over each character.
    var tokens1 = str1.toLowerCase().match(goog.string.numerateCompareRegExp_);
    var tokens2 = str2.toLowerCase().match(goog.string.numerateCompareRegExp_);

    var count = Math.min(tokens1.length, tokens2.length);

    for (var i = 0; i < count; i++) {
        var a = tokens1[i];
        var b = tokens2[i];

        // Compare pairs of tokens, returning if one token sorts before the other.
        if (a != b) {

            // Only if both tokens are integers is a special comparison required.
            // Decimal numbers are sorted as strings (e.g., '.09' < '.1').
            var num1 = parseInt(a, 10);
            if (!isNaN(num1)) {
                var num2 = parseInt(b, 10);
                if (!isNaN(num2) && num1 - num2) {
                    return num1 - num2;
                }
            }
            return a < b ? -1 : 1;
        }
    }

    // If one string is a substring of the other, the shorter string sorts first.
    if (tokens1.length != tokens2.length) {
        return tokens1.length - tokens2.length;
    }

    // The two strings must be equivalent except for case (perfect equality is
    // tested at the head of the function.) Revert to default ASCII-betical string
    // comparison to stablize the sort.
    return str1 < str2 ? -1 : 1;
};


/**
 * URL-encodes a string
 * @param {*} str The string to url-encode.
 * @return {string} An encoded copy of {@code str} that is safe for urls.
 *     Note that '#', ':', and other characters used to delimit portions
 *     of URLs *will* be encoded.
 */
goog.string.urlEncode = function (str) {
    return encodeURIComponent(String(str));
};


/**
 * URL-decodes the string. We need to specially handle '+'s because
 * the javascript library doesn't convert them to spaces.
 * @param {string} str The string to url decode.
 * @return {string} The decoded {@code str}.
 */
goog.string.urlDecode = function (str) {
    return decodeURIComponent(str.replace(/\+/g, ' '));
};


/**
 * Converts \n to <br>s or <br />s.
 * @param {string} str The string in which to convert newlines.
 * @param {boolean=} opt_xml Whether to use XML compatible tags.
 * @return {string} A copy of {@code str} with converted newlines.
 */
goog.string.newLineToBr = function (str, opt_xml) {
    return str.replace(/(\r\n|\r|\n)/g, opt_xml ? '<br />' : '<br>');
};


/**
 * Escape double quote '"' characters in addition to '&', '<', and '>' so that a
 * string can be included in an HTML tag attribute value within double quotes.
 *
 * It should be noted that > doesn't need to be escaped for the HTML or XML to
 * be valid, but it has been decided to escape it for consistency with other
 * implementations.
 *
 * NOTE(user):
 * HtmlEscape is often called during the generation of large blocks of HTML.
 * Using statics for the regular expressions and strings is an optimization
 * that can more than half the amount of time IE spends in this function for
 * large apps, since strings and regexes both contribute to GC allocations.
 *
 * Testing for the presence of a character before escaping increases the number
 * of function calls, but actually provides a speed increase for the average
 * case -- since the average case often doesn't require the escaping of all 4
 * characters and indexOf() is much cheaper than replace().
 * The worst case does suffer slightly from the additional calls, therefore the
 * opt_isLikelyToContainHtmlChars option has been included for situations
 * where all 4 HTML entities are very likely to be present and need escaping.
 *
 * Some benchmarks (times tended to fluctuate +-0.05ms):
 *                                     FireFox                     IE6
 * (no chars / average (mix of cases) / all 4 chars)
 * no checks                     0.13 / 0.22 / 0.22         0.23 / 0.53 / 0.80
 * indexOf                       0.08 / 0.17 / 0.26         0.22 / 0.54 / 0.84
 * indexOf + re test             0.07 / 0.17 / 0.28         0.19 / 0.50 / 0.85
 *
 * An additional advantage of checking if replace actually needs to be called
 * is a reduction in the number of object allocations, so as the size of the
 * application grows the difference between the various methods would increase.
 *
 * @param {string} str string to be escaped.
 * @param {boolean=} opt_isLikelyToContainHtmlChars Don't perform a check to see
 *     if the character needs replacing - use this option if you expect each of
 *     the characters to appear often. Leave false if you expect few html
 *     characters to occur in your strings, such as if you are escaping HTML.
 * @return {string} An escaped copy of {@code str}.
 */
goog.string.htmlEscape = function (str, opt_isLikelyToContainHtmlChars) {

    if (opt_isLikelyToContainHtmlChars) {
        return str.replace(goog.string.amperRe_, '&amp;')
            .replace(goog.string.ltRe_, '&lt;')
            .replace(goog.string.gtRe_, '&gt;')
            .replace(goog.string.quotRe_, '&quot;');

    } else {
        // quick test helps in the case when there are no chars to replace, in
        // worst case this makes barely a difference to the time taken
        if (!goog.string.allRe_.test(str)) return str;

        // str.indexOf is faster than regex.test in this case
        if (str.indexOf('&') != -1) {
            str = str.replace(goog.string.amperRe_, '&amp;');
        }
        if (str.indexOf('<') != -1) {
            str = str.replace(goog.string.ltRe_, '&lt;');
        }
        if (str.indexOf('>') != -1) {
            str = str.replace(goog.string.gtRe_, '&gt;');
        }
        if (str.indexOf('"') != -1) {
            str = str.replace(goog.string.quotRe_, '&quot;');
        }
        return str;
    }
};


/**
 * Regular expression that matches an ampersand, for use in escaping.
 * @type {RegExp}
 * @private
 */
goog.string.amperRe_ = /&/g;


/**
 * Regular expression that matches a less than sign, for use in escaping.
 * @type {RegExp}
 * @private
 */
goog.string.ltRe_ = /</g;


/**
 * Regular expression that matches a greater than sign, for use in escaping.
 * @type {RegExp}
 * @private
 */
goog.string.gtRe_ = />/g;


/**
 * Regular expression that matches a double quote, for use in escaping.
 * @type {RegExp}
 * @private
 */
goog.string.quotRe_ = /\"/g;


/**
 * Regular expression that matches any character that needs to be escaped.
 * @type {RegExp}
 * @private
 */
goog.string.allRe_ = /[&<>\"]/;


/**
 * Unescapes an HTML string.
 *
 * @param {string} str The string to unescape.
 * @return {string} An unescaped copy of {@code str}.
 */
goog.string.unescapeEntities = function (str) {
    if (goog.string.contains(str, '&')) {
        // We are careful not to use a DOM if we do not have one. We use the []
        // notation so that the JSCompiler will not complain about these objects and
        // fields in the case where we have no DOM.
        if ('document' in goog.global) {
            return goog.string.unescapeEntitiesUsingDom_(str);
        } else {
            // Fall back on pure XML entities
            return goog.string.unescapePureXmlEntities_(str);
        }
    }
    return str;
};


/**
 * Unescapes an HTML string using a DOM to resolve non-XML, non-numeric
 * entities. This function is XSS-safe and whitespace-preserving.
 * @private
 * @param {string} str The string to unescape.
 * @return {string} The unescaped {@code str} string.
 */
goog.string.unescapeEntitiesUsingDom_ = function (str) {
    var seen = {'&amp;': '&', '&lt;': '<', '&gt;': '>', '&quot;': '"'};
    var div = document.createElement('div');
    // Match as many valid entity characters as possible. If the actual entity
    // happens to be shorter, it will still work as innerHTML will return the
    // trailing characters unchanged. Since the entity characters do not include
    // open angle bracket, there is no chance of XSS from the innerHTML use.
    // Since no whitespace is passed to innerHTML, whitespace is preserved.
    return str.replace(goog.string.HTML_ENTITY_PATTERN_, function (s, entity) {
        // Check for cached entity.
        var value = seen[s];
        if (value) {
            return value;
        }
        // Check for numeric entity.
        if (entity.charAt(0) == '#') {
            // Prefix with 0 so that hex entities (e.g. &#x10) parse as hex numbers.
            var n = Number('0' + entity.substr(1));
            if (!isNaN(n)) {
                value = String.fromCharCode(n);
            }
        }
        // Fall back to innerHTML otherwise.
        if (!value) {
            // Append a non-entity character to avoid a bug in Webkit that parses
            // an invalid entity at the end of innerHTML text as the empty string.
            div.innerHTML = s + ' ';
            // Then remove the trailing character from the result.
            value = div.firstChild.nodeValue.slice(0, -1);
        }
        // Cache and return.
        return seen[s] = value;
    });
};


/**
 * Unescapes XML entities.
 * @private
 * @param {string} str The string to unescape.
 * @return {string} An unescaped copy of {@code str}.
 */
goog.string.unescapePureXmlEntities_ = function (str) {
    return str.replace(/&([^;]+);/g, function (s, entity) {
        switch (entity) {
            case 'amp':
                return '&';
            case 'lt':
                return '<';
            case 'gt':
                return '>';
            case 'quot':
                return '"';
            default:
                if (entity.charAt(0) == '#') {
                    // Prefix with 0 so that hex entities (e.g. &#x10) parse as hex.
                    var n = Number('0' + entity.substr(1));
                    if (!isNaN(n)) {
                        return String.fromCharCode(n);
                    }
                }
                // For invalid entities we just return the entity
                return s;
        }
    });
};


/**
 * Regular expression that matches an HTML entity.
 * See also HTML5: Tokenization / Tokenizing character references.
 * @private
 * @type {!RegExp}
 */
goog.string.HTML_ENTITY_PATTERN_ = /&([^;\s<&]+);?/g;


/**
 * Do escaping of whitespace to preserve spatial formatting. We use character
 * entity #160 to make it safer for xml.
 * @param {string} str The string in which to escape whitespace.
 * @param {boolean=} opt_xml Whether to use XML compatible tags.
 * @return {string} An escaped copy of {@code str}.
 */
goog.string.whitespaceEscape = function (str, opt_xml) {
    return goog.string.newLineToBr(str.replace(/  /g, ' &#160;'), opt_xml);
};


/**
 * Strip quote characters around a string.  The second argument is a string of
 * characters to treat as quotes.  This can be a single character or a string of
 * multiple character and in that case each of those are treated as possible
 * quote characters. For example:
 *
 * <pre>
 * goog.string.stripQuotes('"abc"', '"`') --> 'abc'
 * goog.string.stripQuotes('`abc`', '"`') --> 'abc'
 * </pre>
 *
 * @param {string} str The string to strip.
 * @param {string} quoteChars The quote characters to strip.
 * @return {string} A copy of {@code str} without the quotes.
 */
goog.string.stripQuotes = function (str, quoteChars) {
    var length = quoteChars.length;
    for (var i = 0; i < length; i++) {
        var quoteChar = length == 1 ? quoteChars : quoteChars.charAt(i);
        if (str.charAt(0) == quoteChar && str.charAt(str.length - 1) == quoteChar) {
            return str.substring(1, str.length - 1);
        }
    }
    return str;
};


/**
 * Truncates a string to a certain length and adds '...' if necessary.  The
 * length also accounts for the ellipsis, so a maximum length of 10 and a string
 * 'Hello World!' produces 'Hello W...'.
 * @param {string} str The string to truncate.
 * @param {number} chars Max number of characters.
 * @param {boolean=} opt_protectEscapedCharacters Whether to protect escaped
 *     characters from being cut off in the middle.
 * @return {string} The truncated {@code str} string.
 */
goog.string.truncate = function (str, chars, opt_protectEscapedCharacters) {
    if (opt_protectEscapedCharacters) {
        str = goog.string.unescapeEntities(str);
    }

    if (str.length > chars) {
        str = str.substring(0, chars - 3) + '...';
    }

    if (opt_protectEscapedCharacters) {
        str = goog.string.htmlEscape(str);
    }

    return str;
};


/**
 * Truncate a string in the middle, adding "..." if necessary,
 * and favoring the beginning of the string.
 * @param {string} str The string to truncate the middle of.
 * @param {number} chars Max number of characters.
 * @param {boolean=} opt_protectEscapedCharacters Whether to protect escaped
 *     characters from being cutoff in the middle.
 * @param {number=} opt_trailingChars Optional number of trailing characters to
 *     leave at the end of the string, instead of truncating as close to the
 *     middle as possible.
 * @return {string} A truncated copy of {@code str}.
 */
goog.string.truncateMiddle = function (str, chars, opt_protectEscapedCharacters, opt_trailingChars) {
    if (opt_protectEscapedCharacters) {
        str = goog.string.unescapeEntities(str);
    }

    if (opt_trailingChars && str.length > chars) {
        if (opt_trailingChars > chars) {
            opt_trailingChars = chars;
        }
        var endPoint = str.length - opt_trailingChars;
        var startPoint = chars - opt_trailingChars;
        str = str.substring(0, startPoint) + '...' + str.substring(endPoint);
    } else if (str.length > chars) {
        // Favor the beginning of the string:
        var half = Math.floor(chars / 2);
        var endPos = str.length - half;
        half += chars % 2;
        str = str.substring(0, half) + '...' + str.substring(endPos);
    }

    if (opt_protectEscapedCharacters) {
        str = goog.string.htmlEscape(str);
    }

    return str;
};


/**
 * Special chars that need to be escaped for goog.string.quote.
 * @private
 * @type {Object}
 */
goog.string.specialEscapeChars_ = {
    '\0': '\\0',
    '\b': '\\b',
    '\f': '\\f',
    '\n': '\\n',
    '\r': '\\r',
    '\t': '\\t',
    '\x0B': '\\x0B', // '\v' is not supported in JScript
    '"': '\\"',
    '\\': '\\\\'
};


/**
 * Character mappings used internally for goog.string.escapeChar.
 * @private
 * @type {Object}
 */
goog.string.jsEscapeCache_ = {
    '\'': '\\\''
};


/**
 * Encloses a string in double quotes and escapes characters so that the
 * string is a valid JS string.
 * @param {string} s The string to quote.
 * @return {string} A copy of {@code s} surrounded by double quotes.
 */
goog.string.quote = function (s) {
    s = String(s);
    if (s.quote) {
        return s.quote();
    } else {
        var sb = ['"'];
        for (var i = 0; i < s.length; i++) {
            var ch = s.charAt(i);
            var cc = ch.charCodeAt(0);
            sb[i + 1] = goog.string.specialEscapeChars_[ch] ||
                ((cc > 31 && cc < 127) ? ch : goog.string.escapeChar(ch));
        }
        sb.push('"');
        return sb.join('');
    }
};


/**
 * Takes a string and returns the escaped string for that character.
 * @param {string} str The string to escape.
 * @return {string} An escaped string representing {@code str}.
 */
goog.string.escapeString = function (str) {
    var sb = [];
    for (var i = 0; i < str.length; i++) {
        sb[i] = goog.string.escapeChar(str.charAt(i));
    }
    return sb.join('');
};


/**
 * Takes a character and returns the escaped string for that character. For
 * example escapeChar(String.fromCharCode(15)) -> "\\x0E".
 * @param {string} c The character to escape.
 * @return {string} An escaped string representing {@code c}.
 */
goog.string.escapeChar = function (c) {
    if (c in goog.string.jsEscapeCache_) {
        return goog.string.jsEscapeCache_[c];
    }

    if (c in goog.string.specialEscapeChars_) {
        return goog.string.jsEscapeCache_[c] = goog.string.specialEscapeChars_[c];
    }

    var rv = c;
    var cc = c.charCodeAt(0);
    if (cc > 31 && cc < 127) {
        rv = c;
    } else {
        // tab is 9 but handled above
        if (cc < 256) {
            rv = '\\x';
            if (cc < 16 || cc > 256) {
                rv += '0';
            }
        } else {
            rv = '\\u';
            if (cc < 4096) { // \u1000
                rv += '0';
            }
        }
        rv += cc.toString(16).toUpperCase();
    }

    return goog.string.jsEscapeCache_[c] = rv;
};


/**
 * Takes a string and creates a map (Object) in which the keys are the
 * characters in the string. The value for the key is set to true. You can
 * then use goog.object.map or goog.array.map to change the values.
 * @param {string} s The string to build the map from.
 * @return {Object} The map of characters used.
 */
// TODO(arv): It seems like we should have a generic goog.array.toMap. But do
//            we want a dependency on goog.array in goog.string?
goog.string.toMap = function (s) {
    var rv = {};
    for (var i = 0; i < s.length; i++) {
        rv[s.charAt(i)] = true;
    }
    return rv;
};


/**
 * Checks whether a string contains a given substring.
 * @param {string} s The string to test.
 * @param {string} ss The substring to test for.
 * @return {boolean} True if {@code s} contains {@code ss}.
 */
goog.string.contains = function (s, ss) {
    return s.indexOf(ss) != -1;
};


/**
 * Returns the non-overlapping occurrences of ss in s.
 * If either s or ss evalutes to false, then returns zero.
 * @param {string} s The string to look in.
 * @param {string} ss The string to look for.
 * @return {number} Number of occurrences of ss in s.
 */
goog.string.countOf = function (s, ss) {
    return s && ss ? s.split(ss).length - 1 : 0;
};


/**
 * Removes a substring of a specified length at a specific
 * index in a string.
 * @param {string} s The base string from which to remove.
 * @param {number} index The index at which to remove the substring.
 * @param {number} stringLength The length of the substring to remove.
 * @return {string} A copy of {@code s} with the substring removed or the full
 *     string if nothing is removed or the input is invalid.
 */
goog.string.removeAt = function (s, index, stringLength) {
    var resultStr = s;
    // If the index is greater or equal to 0 then remove substring
    if (index >= 0 && index < s.length && stringLength > 0) {
        resultStr = s.substr(0, index) +
            s.substr(index + stringLength, s.length - index - stringLength);
    }
    return resultStr;
};


/**
 *  Removes the first occurrence of a substring from a string.
 *  @param {string} s The base string from which to remove.
 *  @param {string} ss The string to remove.
 *  @return {string} A copy of {@code s} with {@code ss} removed or the full
 *      string if nothing is removed.
 */
goog.string.remove = function (s, ss) {
    var re = new RegExp(goog.string.regExpEscape(ss), '');
    return s.replace(re, '');
};


/**
 *  Removes all occurrences of a substring from a string.
 *  @param {string} s The base string from which to remove.
 *  @param {string} ss The string to remove.
 *  @return {string} A copy of {@code s} with {@code ss} removed or the full
 *      string if nothing is removed.
 */
goog.string.removeAll = function (s, ss) {
    var re = new RegExp(goog.string.regExpEscape(ss), 'g');
    return s.replace(re, '');
};


/**
 * Escapes characters in the string that are not safe to use in a RegExp.
 * @param {*} s The string to escape. If not a string, it will be casted
 *     to one.
 * @return {string} A RegExp safe, escaped copy of {@code s}.
 */
goog.string.regExpEscape = function (s) {
    return String(s).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').
        replace(/\x08/g, '\\x08');
};


/**
 * Repeats a string n times.
 * @param {string} string The string to repeat.
 * @param {number} length The number of times to repeat.
 * @return {string} A string containing {@code length} repetitions of
 *     {@code string}.
 */
goog.string.repeat = function (string, length) {
    return new Array(length + 1).join(string);
};


/**
 * Pads number to given length and optionally rounds it to a given precision.
 * For example:
 * <pre>padNumber(1.25, 2, 3) -> '01.250'
 * padNumber(1.25, 2) -> '01.25'
 * padNumber(1.25, 2, 1) -> '01.3'
 * padNumber(1.25, 0) -> '1.25'</pre>
 *
 * @param {number} num The number to pad.
 * @param {number} length The desired length.
 * @param {number=} opt_precision The desired precision.
 * @return {string} {@code num} as a string with the given options.
 */
goog.string.padNumber = function (num, length, opt_precision) {
    var s = goog.isDef(opt_precision) ? num.toFixed(opt_precision) : String(num);
    var index = s.indexOf('.');
    if (index == -1) {
        index = s.length;
    }
    return goog.string.repeat('0', Math.max(0, length - index)) + s;
};


/**
 * Returns a string representation of the given object, with
 * null and undefined being returned as the empty string.
 *
 * @param {*} obj The object to convert.
 * @return {string} A string representation of the {@code obj}.
 */
goog.string.makeSafe = function (obj) {
    return obj == null ? '' : String(obj);
};


/**
 * Concatenates string expressions. This is useful
 * since some browsers are very inefficient when it comes to using plus to
 * concat strings. Be careful when using null and undefined here since
 * these will not be included in the result. If you need to represent these
 * be sure to cast the argument to a String first.
 * For example:
 * <pre>buildString('a', 'b', 'c', 'd') -> 'abcd'
 * buildString(null, undefined) -> ''
 * </pre>
 * @param {...*} var_args A list of strings to concatenate. If not a string,
 *     it will be casted to one.
 * @return {string} The concatenation of {@code var_args}.
 */
goog.string.buildString = function (var_args) {
    return Array.prototype.join.call(arguments, '');
};


/**
 * Returns a string with at least 64-bits of randomness.
 *
 * Doesn't trust Javascript's random function entirely. Uses a combination of
 * random and current timestamp, and then encodes the string in base-36 to
 * make it shorter.
 *
 * @return {string} A random string, e.g. sn1s7vb4gcic.
 */
goog.string.getRandomString = function () {
    var x = 2147483648;
    return Math.floor(Math.random() * x).toString(36) +
        Math.abs(Math.floor(Math.random() * x) ^ goog.now()).toString(36);
};


/**
 * Compares two version numbers.
 *
 * @param {string|number} version1 Version of first item.
 * @param {string|number} version2 Version of second item.
 *
 * @return {number}  1 if {@code version1} is higher.
 *                   0 if arguments are equal.
 *                  -1 if {@code version2} is higher.
 */
goog.string.compareVersions = function (version1, version2) {
    var order = 0;
    // Trim leading and trailing whitespace and split the versions into
    // subversions.
    var v1Subs = goog.string.trim(String(version1)).split('.');
    var v2Subs = goog.string.trim(String(version2)).split('.');
    var subCount = Math.max(v1Subs.length, v2Subs.length);

    // Iterate over the subversions, as long as they appear to be equivalent.
    for (var subIdx = 0; order == 0 && subIdx < subCount; subIdx++) {
        var v1Sub = v1Subs[subIdx] || '';
        var v2Sub = v2Subs[subIdx] || '';

        // Split the subversions into pairs of numbers and qualifiers (like 'b').
        // Two different RegExp objects are needed because they are both using
        // the 'g' flag.
        var v1CompParser = new RegExp('(\\d*)(\\D*)', 'g');
        var v2CompParser = new RegExp('(\\d*)(\\D*)', 'g');
        do {
            var v1Comp = v1CompParser.exec(v1Sub) || ['', '', ''];
            var v2Comp = v2CompParser.exec(v2Sub) || ['', '', ''];
            // Break if there are no more matches.
            if (v1Comp[0].length == 0 && v2Comp[0].length == 0) {
                break;
            }

            // Parse the numeric part of the subversion. A missing number is
            // equivalent to 0.
            var v1CompNum = v1Comp[1].length == 0 ? 0 : parseInt(v1Comp[1], 10);
            var v2CompNum = v2Comp[1].length == 0 ? 0 : parseInt(v2Comp[1], 10);

            // Compare the subversion components. The number has the highest
            // precedence. Next, if the numbers are equal, a subversion without any
            // qualifier is always higher than a subversion with any qualifier. Next,
            // the qualifiers are compared as strings.
            order = goog.string.compareElements_(v1CompNum, v2CompNum) ||
                goog.string.compareElements_(v1Comp[2].length == 0,
                    v2Comp[2].length == 0) ||
                goog.string.compareElements_(v1Comp[2], v2Comp[2]);
            // Stop as soon as an inequality is discovered.
        } while (order == 0);
    }

    return order;
};


/**
 * Compares elements of a version number.
 *
 * @param {string|number|boolean} left An element from a version number.
 * @param {string|number|boolean} right An element from a version number.
 *
 * @return {number}  1 if {@code left} is higher.
 *                   0 if arguments are equal.
 *                  -1 if {@code right} is higher.
 * @private
 */
goog.string.compareElements_ = function (left, right) {
    if (left < right) {
        return -1;
    } else if (left > right) {
        return 1;
    }
    return 0;
};


/**
 * Maximum value of #goog.string.hashCode, exclusive. 2^32.
 * @type {number}
 * @private
 */
goog.string.HASHCODE_MAX_ = 0x100000000;


/**
 * String hash function similar to java.lang.String.hashCode().
 * The hash code for a string is computed as
 * s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
 * where s[i] is the ith character of the string and n is the length of
 * the string. We mod the result to make it between 0 (inclusive) and 2^32
 * (exclusive).
 * @param {string} str A string.
 * @return {number} Hash value for {@code str}, between 0 (inclusive) and 2^32
 *  (exclusive). The empty string returns 0.
 */
goog.string.hashCode = function (str) {
    var result = 0;
    for (var i = 0; i < str.length; ++i) {
        result = 31 * result + str.charCodeAt(i);
        // Normalize to 4 byte range, 0 ... 2^32.
        result %= goog.string.HASHCODE_MAX_;
    }
    return result;
};


/**
 * The most recent unique ID. |0 is equivalent to Math.floor in this case.
 * @type {number}
 * @private
 */
goog.string.uniqueStringCounter_ = Math.random() * 0x80000000 | 0;


/**
 * Generates and returns a string which is unique in the current document.
 * This is useful, for example, to create unique IDs for DOM elements.
 * @return {string} A unique id.
 */
goog.string.createUniqueString = function () {
    return 'goog_' + goog.string.uniqueStringCounter_++;
};


/**
 * Converts the supplied string to a number, which may be Ininity or NaN.
 * This function strips whitespace: (toNumber(' 123') === 123)
 * This function accepts scientific notation: (toNumber('1e1') === 10)
 *
 * This is better than Javascript's built-in conversions because, sadly:
 *     (Number(' ') === 0) and (parseFloat('123a') === 123)
 *
 * @param {string} str The string to convert.
 * @return {number} The number the supplied string represents, or NaN.
 */
goog.string.toNumber = function (str) {
    var num = Number(str);
    if (num == 0 && goog.string.isEmpty(str)) {
        return NaN;
    }
    return num;
};


/**
 * Returns whether the given string is lower camel case (e.g. "isFooBar").
 *
 * Note that this assumes the string is entirely letters.
 * @see http://en.wikipedia.org/wiki/CamelCase#Variations_and_synonyms
 *
 * @param {string} str String to test.
 * @return {boolean} Whether the string is lower camel case.
 */
goog.string.isLowerCamelCase = function (str) {
    return /^[a-z]+([A-Z][a-z]*)*$/.test(str);
};


/**
 * Returns whether the given string is upper camel case (e.g. "FooBarBaz").
 *
 * Note that this assumes the string is entirely letters.
 * @see http://en.wikipedia.org/wiki/CamelCase#Variations_and_synonyms
 *
 * @param {string} str String to test.
 * @return {boolean} Whether the string is upper camel case.
 */
goog.string.isUpperCamelCase = function (str) {
    return /^([A-Z][a-z]*)+$/.test(str);
};


/**
 * Converts a string from selector-case to camelCase (e.g. from
 * "multi-part-string" to "multiPartString"), useful for converting
 * CSS selectors and HTML dataset keys to their equivalent JS properties.
 * @param {string} str The string in selector-case form.
 * @return {string} The string in camelCase form.
 */
goog.string.toCamelCase = function (str) {
    return String(str).replace(/\-([a-z])/g, function (all, match) {
        return match.toUpperCase();
    });
};


/**
 * Converts a string from camelCase to selector-case (e.g. from
 * "multiPartString" to "multi-part-string"), useful for converting JS
 * style and dataset properties to equivalent CSS selectors and HTML keys.
 * @param {string} str The string in camelCase form.
 * @return {string} The string in selector-case form.
 */
goog.string.toSelectorCase = function (str) {
    return String(str).replace(/([A-Z])/g, '-$1').toLowerCase();
};


/**
 * Converts a string into TitleCase. First character of the string is always
 * capitalized in addition to the first letter of every subsequent word.
 * Words are delimited by one or more whitespaces by default. Custom delimiters
 * can optionally be specified to replace the default, which doesn't preserve
 * whitespace delimiters and instead must be explicitly included if needed.
 *
 * Default delimiter => " ":
 *    goog.string.toTitleCase('oneTwoThree')    => 'OneTwoThree'
 *    goog.string.toTitleCase('one two three')  => 'One Two Three'
 *    goog.string.toTitleCase('  one   two   ') => '  One   Two   '
 *    goog.string.toTitleCase('one_two_three')  => 'One_two_three'
 *    goog.string.toTitleCase('one-two-three')  => 'One-two-three'
 *
 * Custom delimiter => "_-.":
 *    goog.string.toTitleCase('oneTwoThree', '_-.')       => 'OneTwoThree'
 *    goog.string.toTitleCase('one two three', '_-.')     => 'One two three'
 *    goog.string.toTitleCase('  one   two   ', '_-.')    => '  one   two   '
 *    goog.string.toTitleCase('one_two_three', '_-.')     => 'One_Two_Three'
 *    goog.string.toTitleCase('one-two-three', '_-.')     => 'One-Two-Three'
 *    goog.string.toTitleCase('one...two...three', '_-.') => 'One...Two...Three'
 *    goog.string.toTitleCase('one. two. three', '_-.')   => 'One. two. three'
 *    goog.string.toTitleCase('one-two.three', '_-.')     => 'One-Two.Three'
 *
 * @param {string} str String value in camelCase form.
 * @param {string=} opt_delimiters Custom delimiter character set used to
 *      distinguish words in the string value. Each character represents a
 *      single delimiter. When provided, default whitespace delimiter is
 *      overridden and must be explicitly included if needed.
 * @return {string} String value in TitleCase form.
 */
goog.string.toTitleCase = function (str, opt_delimiters) {
    var delimiters = goog.isString(opt_delimiters) ?
        goog.string.regExpEscape(opt_delimiters) : '\\s';

    // For IE8, we need to prevent using an empty character set. Otherwise,
    // incorrect matching will occur.
    delimiters = delimiters ? '|[' + delimiters + ']+' : '';

    var regexp = new RegExp('(^' + delimiters + ')([a-z])', 'g');
    return str.replace(regexp, function (all, p1, p2) {
        return p1 + p2.toUpperCase();
    });
};


/**
 * Parse a string in decimal or hexidecimal ('0xFFFF') form.
 *
 * To parse a particular radix, please use parseInt(string, radix) directly. See
 * https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/parseInt
 *
 * This is a wrapper for the built-in parseInt function that will only parse
 * numbers as base 10 or base 16.  Some JS implementations assume strings
 * starting with "0" are intended to be octal. ES3 allowed but discouraged
 * this behavior. ES5 forbids it.  This function emulates the ES5 behavior.
 *
 * For more information, see Mozilla JS Reference: http://goo.gl/8RiFj
 *
 * @param {string|number|null|undefined} value The value to be parsed.
 * @return {number} The number, parsed. If the string failed to parse, this
 *     will be NaN.
 */
goog.string.parseInt = function (value) {
    // Force finite numbers to strings.
    if (isFinite(value)) {
        value = String(value);
    }

    if (goog.isString(value)) {
        // If the string starts with '0x' or '-0x', parse as hex.
        return /^\s*-?0x/i.test(value) ?
            parseInt(value, 16) : parseInt(value, 10);
    }

    return NaN;
};


/**
 * Splits a string on a separator a limited number of times.
 *
 * This implementation is more similar to Python or Java, where the limit
 * parameter specifies the maximum number of splits rather than truncating
 * the number of results.
 *
 * See http://docs.python.org/2/library/stdtypes.html#str.split
 * See JavaDoc: http://goo.gl/F2AsY
 * See Mozilla reference: http://goo.gl/dZdZs
 *
 * @param {string} str String to split.
 * @param {string} separator The separator.
 * @param {number} limit The limit to the number of splits. The resulting array
 *     will have a maximum length of limit+1.  Negative numbers are the same
 *     as zero.
 * @return {!Array.<string>} The string, split.
 */

goog.string.splitLimit = function (str, separator, limit) {
    var parts = str.split(separator);
    var returnVal = [];

    // Only continue doing this while we haven't hit the limit and we have
    // parts left.
    while (limit > 0 && parts.length) {
        returnVal.push(parts.shift());
        limit--;
    }

    // If there are remaining parts, append them to the end.
    if (parts.length) {
        returnVal.push(parts.join(separator));
    }

    return returnVal;
};


// Input 4
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Rendering engine detection.
 * @see <a href="http://www.useragentstring.com/">User agent strings</a>
 * For information on the browser brand (such as Safari versus Chrome), see
 * goog.userAgent.product.
 * @see ../demos/useragent.html
 */

goog.provide('goog.userAgent');

goog.require('goog.string');


/**
 * @define {boolean} Whether we know at compile-time that the browser is IE.
 */
goog.define('goog.userAgent.ASSUME_IE', false);


/**
 * @define {boolean} Whether we know at compile-time that the browser is GECKO.
 */
goog.define('goog.userAgent.ASSUME_GECKO', false);


/**
 * @define {boolean} Whether we know at compile-time that the browser is WEBKIT.
 */
goog.define('goog.userAgent.ASSUME_WEBKIT', false);


/**
 * @define {boolean} Whether we know at compile-time that the browser is a
 *     mobile device running WebKit e.g. iPhone or Android.
 */
goog.define('goog.userAgent.ASSUME_MOBILE_WEBKIT', false);


/**
 * @define {boolean} Whether we know at compile-time that the browser is OPERA.
 */
goog.define('goog.userAgent.ASSUME_OPERA', false);


/**
 * @define {boolean} Whether the
 *     {@code goog.userAgent.isVersionOrHigher}
 *     function will return true for any version.
 */
goog.define('goog.userAgent.ASSUME_ANY_VERSION', false);


/**
 * Whether we know the browser engine at compile-time.
 * @type {boolean}
 * @private
 */
goog.userAgent.BROWSER_KNOWN_ =
    goog.userAgent.ASSUME_IE ||
        goog.userAgent.ASSUME_GECKO ||
        goog.userAgent.ASSUME_MOBILE_WEBKIT ||
        goog.userAgent.ASSUME_WEBKIT ||
        goog.userAgent.ASSUME_OPERA;


/**
 * Returns the userAgent string for the current browser.
 * Some user agents (I'm thinking of you, Gears WorkerPool) do not expose a
 * navigator object off the global scope.  In that case we return null.
 *
 * @return {?string} The userAgent string or null if there is none.
 */
goog.userAgent.getUserAgentString = function () {
    return goog.global['navigator'] ? goog.global['navigator'].userAgent : null;
};


/**
 * @return {Object} The native navigator object.
 */
goog.userAgent.getNavigator = function () {
    // Need a local navigator reference instead of using the global one,
    // to avoid the rare case where they reference different objects.
    // (in a WorkerPool, for example).
    return goog.global['navigator'];
};


/**
 * Initializer for goog.userAgent.
 *
 * This is a named function so that it can be stripped via the jscompiler
 * option for stripping types.
 * @private
 */
goog.userAgent.init_ = function () {
    /**
     * Whether the user agent string denotes Opera.
     * @type {boolean}
     * @private
     */
    goog.userAgent.detectedOpera_ = false;

    /**
     * Whether the user agent string denotes Internet Explorer. This includes
     * other browsers using Trident as its rendering engine. For example AOL
     * and Netscape 8
     * @type {boolean}
     * @private
     */
    goog.userAgent.detectedIe_ = false;

    /**
     * Whether the user agent string denotes WebKit. WebKit is the rendering
     * engine that Safari, Android and others use.
     * @type {boolean}
     * @private
     */
    goog.userAgent.detectedWebkit_ = false;

    /**
     * Whether the user agent string denotes a mobile device.
     * @type {boolean}
     * @private
     */
    goog.userAgent.detectedMobile_ = false;

    /**
     * Whether the user agent string denotes Gecko. Gecko is the rendering
     * engine used by Mozilla, Mozilla Firefox, Camino and many more.
     * @type {boolean}
     * @private
     */
    goog.userAgent.detectedGecko_ = false;

    var ua;
    if (!goog.userAgent.BROWSER_KNOWN_ &&
        (ua = goog.userAgent.getUserAgentString())) {
        var navigator = goog.userAgent.getNavigator();
        goog.userAgent.detectedOpera_ = goog.string.startsWith(ua, 'Opera');
        goog.userAgent.detectedIe_ = !goog.userAgent.detectedOpera_ &&
            (goog.string.contains(ua, 'MSIE') ||
                goog.string.contains(ua, 'Trident'));
        goog.userAgent.detectedWebkit_ = !goog.userAgent.detectedOpera_ &&
            goog.string.contains(ua, 'WebKit');
        // WebKit also gives navigator.product string equal to 'Gecko'.
        goog.userAgent.detectedMobile_ = goog.userAgent.detectedWebkit_ &&
            goog.string.contains(ua, 'Mobile');
        goog.userAgent.detectedGecko_ = !goog.userAgent.detectedOpera_ && !goog.userAgent.detectedWebkit_ && !goog.userAgent.detectedIe_ &&
            navigator.product == 'Gecko';
    }
};


if (!goog.userAgent.BROWSER_KNOWN_) {
    goog.userAgent.init_();
}


/**
 * Whether the user agent is Opera.
 * @type {boolean}
 */
goog.userAgent.OPERA = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_OPERA : goog.userAgent.detectedOpera_;


/**
 * Whether the user agent is Internet Explorer. This includes other browsers
 * using Trident as its rendering engine. For example AOL and Netscape 8
 * @type {boolean}
 */
goog.userAgent.IE = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_IE : goog.userAgent.detectedIe_;


/**
 * Whether the user agent is Gecko. Gecko is the rendering engine used by
 * Mozilla, Mozilla Firefox, Camino and many more.
 * @type {boolean}
 */
goog.userAgent.GECKO = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_GECKO :
    goog.userAgent.detectedGecko_;


/**
 * Whether the user agent is WebKit. WebKit is the rendering engine that
 * Safari, Android and others use.
 * @type {boolean}
 */
goog.userAgent.WEBKIT = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_WEBKIT || goog.userAgent.ASSUME_MOBILE_WEBKIT :
    goog.userAgent.detectedWebkit_;


/**
 * Whether the user agent is running on a mobile device.
 * @type {boolean}
 */
goog.userAgent.MOBILE = goog.userAgent.ASSUME_MOBILE_WEBKIT ||
    goog.userAgent.detectedMobile_;


/**
 * Used while transitioning code to use WEBKIT instead.
 * @type {boolean}
 * @deprecated Use {@link goog.userAgent.product.SAFARI} instead.
 * TODO(nicksantos): Delete this from goog.userAgent.
 */
goog.userAgent.SAFARI = goog.userAgent.WEBKIT;


/**
 * @return {string} the platform (operating system) the user agent is running
 *     on. Default to empty string because navigator.platform may not be defined
 *     (on Rhino, for example).
 * @private
 */
goog.userAgent.determinePlatform_ = function () {
    var navigator = goog.userAgent.getNavigator();
    return navigator && navigator.platform || '';
};


/**
 * The platform (operating system) the user agent is running on. Default to
 * empty string because navigator.platform may not be defined (on Rhino, for
 * example).
 * @type {string}
 */
goog.userAgent.PLATFORM = goog.userAgent.determinePlatform_();


/**
 * @define {boolean} Whether the user agent is running on a Macintosh operating
 *     system.
 */
goog.define('goog.userAgent.ASSUME_MAC', false);


/**
 * @define {boolean} Whether the user agent is running on a Windows operating
 *     system.
 */
goog.define('goog.userAgent.ASSUME_WINDOWS', false);


/**
 * @define {boolean} Whether the user agent is running on a Linux operating
 *     system.
 */
goog.define('goog.userAgent.ASSUME_LINUX', false);


/**
 * @define {boolean} Whether the user agent is running on a X11 windowing
 *     system.
 */
goog.define('goog.userAgent.ASSUME_X11', false);


/**
 * @define {boolean} Whether the user agent is running on Android.
 */
goog.define('goog.userAgent.ASSUME_ANDROID', false);


/**
 * @define {boolean} Whether the user agent is running on an iPhone.
 */
goog.define('goog.userAgent.ASSUME_IPHONE', false);


/**
 * @define {boolean} Whether the user agent is running on an iPad.
 */
goog.define('goog.userAgent.ASSUME_IPAD', false);


/**
 * @type {boolean}
 * @private
 */
goog.userAgent.PLATFORM_KNOWN_ =
    goog.userAgent.ASSUME_MAC ||
        goog.userAgent.ASSUME_WINDOWS ||
        goog.userAgent.ASSUME_LINUX ||
        goog.userAgent.ASSUME_X11 ||
        goog.userAgent.ASSUME_ANDROID ||
        goog.userAgent.ASSUME_IPHONE ||
        goog.userAgent.ASSUME_IPAD;


/**
 * Initialize the goog.userAgent constants that define which platform the user
 * agent is running on.
 * @private
 */
goog.userAgent.initPlatform_ = function () {
    /**
     * Whether the user agent is running on a Macintosh operating system.
     * @type {boolean}
     * @private
     */
    goog.userAgent.detectedMac_ = goog.string.contains(goog.userAgent.PLATFORM,
        'Mac');

    /**
     * Whether the user agent is running on a Windows operating system.
     * @type {boolean}
     * @private
     */
    goog.userAgent.detectedWindows_ = goog.string.contains(
        goog.userAgent.PLATFORM, 'Win');

    /**
     * Whether the user agent is running on a Linux operating system.
     * @type {boolean}
     * @private
     */
    goog.userAgent.detectedLinux_ = goog.string.contains(goog.userAgent.PLATFORM,
        'Linux');

    /**
     * Whether the user agent is running on a X11 windowing system.
     * @type {boolean}
     * @private
     */
    goog.userAgent.detectedX11_ = !!goog.userAgent.getNavigator() &&
        goog.string.contains(goog.userAgent.getNavigator()['appVersion'] || '',
            'X11');

    // Need user agent string for Android/IOS detection
    var ua = goog.userAgent.getUserAgentString();

    /**
     * Whether the user agent is running on Android.
     * @type {boolean}
     * @private
     */
    goog.userAgent.detectedAndroid_ = !!ua &&
        goog.string.contains(ua, 'Android');

    /**
     * Whether the user agent is running on an iPhone.
     * @type {boolean}
     * @private
     */
    goog.userAgent.detectedIPhone_ = !!ua && goog.string.contains(ua, 'iPhone');

    /**
     * Whether the user agent is running on an iPad.
     * @type {boolean}
     * @private
     */
    goog.userAgent.detectedIPad_ = !!ua && goog.string.contains(ua, 'iPad');
};


if (!goog.userAgent.PLATFORM_KNOWN_) {
    goog.userAgent.initPlatform_();
}


/**
 * Whether the user agent is running on a Macintosh operating system.
 * @type {boolean}
 */
goog.userAgent.MAC = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_MAC : goog.userAgent.detectedMac_;


/**
 * Whether the user agent is running on a Windows operating system.
 * @type {boolean}
 */
goog.userAgent.WINDOWS = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_WINDOWS : goog.userAgent.detectedWindows_;


/**
 * Whether the user agent is running on a Linux operating system.
 * @type {boolean}
 */
goog.userAgent.LINUX = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_LINUX : goog.userAgent.detectedLinux_;


/**
 * Whether the user agent is running on a X11 windowing system.
 * @type {boolean}
 */
goog.userAgent.X11 = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_X11 : goog.userAgent.detectedX11_;


/**
 * Whether the user agent is running on Android.
 * @type {boolean}
 */
goog.userAgent.ANDROID = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_ANDROID : goog.userAgent.detectedAndroid_;


/**
 * Whether the user agent is running on an iPhone.
 * @type {boolean}
 */
goog.userAgent.IPHONE = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_IPHONE : goog.userAgent.detectedIPhone_;


/**
 * Whether the user agent is running on an iPad.
 * @type {boolean}
 */
goog.userAgent.IPAD = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_IPAD : goog.userAgent.detectedIPad_;


/**
 * @return {string} The string that describes the version number of the user
 *     agent.
 * @private
 */
goog.userAgent.determineVersion_ = function () {
    // All browsers have different ways to detect the version and they all have
    // different naming schemes.

    // version is a string rather than a number because it may contain 'b', 'a',
    // and so on.
    var version = '', re;

    if (goog.userAgent.OPERA && goog.global['opera']) {
        var operaVersion = goog.global['opera'].version;
        version = typeof operaVersion == 'function' ? operaVersion() : operaVersion;
    } else {
        if (goog.userAgent.GECKO) {
            re = /rv\:([^\);]+)(\)|;)/;
        } else if (goog.userAgent.IE) {
            re = /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/;
        } else if (goog.userAgent.WEBKIT) {
            // WebKit/125.4
            re = /WebKit\/(\S+)/;
        }
        if (re) {
            var arr = re.exec(goog.userAgent.getUserAgentString());
            version = arr ? arr[1] : '';
        }
    }
    if (goog.userAgent.IE) {
        // IE9 can be in document mode 9 but be reporting an inconsistent user agent
        // version.  If it is identifying as a version lower than 9 we take the
        // documentMode as the version instead.  IE8 has similar behavior.
        // It is recommended to set the X-UA-Compatible header to ensure that IE9
        // uses documentMode 9.
        var docMode = goog.userAgent.getDocumentMode_();
        if (docMode > parseFloat(version)) {
            return String(docMode);
        }
    }
    return version;
};


/**
 * @return {number|undefined} Returns the document mode (for testing).
 * @private
 */
goog.userAgent.getDocumentMode_ = function () {
    // NOTE(user): goog.userAgent may be used in context where there is no DOM.
    var doc = goog.global['document'];
    return doc ? doc['documentMode'] : undefined;
};


/**
 * The version of the user agent. This is a string because it might contain
 * 'b' (as in beta) as well as multiple dots.
 * @type {string}
 */
goog.userAgent.VERSION = goog.userAgent.determineVersion_();


/**
 * Compares two version numbers.
 *
 * @param {string} v1 Version of first item.
 * @param {string} v2 Version of second item.
 *
 * @return {number}  1 if first argument is higher
 *                   0 if arguments are equal
 *                  -1 if second argument is higher.
 * @deprecated Use goog.string.compareVersions.
 */
goog.userAgent.compare = function (v1, v2) {
    return goog.string.compareVersions(v1, v2);
};


/**
 * Cache for {@link goog.userAgent.isVersionOrHigher}.
 * Calls to compareVersions are surprisingly expensive and, as a browser's
 * version number is unlikely to change during a session, we cache the results.
 * @const
 * @private
 */
goog.userAgent.isVersionOrHigherCache_ = {};


/**
 * Whether the user agent version is higher or the same as the given version.
 * NOTE: When checking the version numbers for Firefox and Safari, be sure to
 * use the engine's version, not the browser's version number.  For example,
 * Firefox 3.0 corresponds to Gecko 1.9 and Safari 3.0 to Webkit 522.11.
 * Opera and Internet Explorer versions match the product release number.<br>
 * @see <a href="http://en.wikipedia.org/wiki/Safari_version_history">
 *     Webkit</a>
 * @see <a href="http://en.wikipedia.org/wiki/Gecko_engine">Gecko</a>
 *
 * @param {string|number} version The version to check.
 * @return {boolean} Whether the user agent version is higher or the same as
 *     the given version.
 */
goog.userAgent.isVersionOrHigher = function (version) {
    return goog.userAgent.ASSUME_ANY_VERSION ||
        goog.userAgent.isVersionOrHigherCache_[version] ||
        (goog.userAgent.isVersionOrHigherCache_[version] =
            goog.string.compareVersions(goog.userAgent.VERSION, version) >= 0);
};


/**
 * Deprecated alias to {@code goog.userAgent.isVersionOrHigher}.
 * @param {string|number} version The version to check.
 * @return {boolean} Whether the user agent version is higher or the same as
 *     the given version.
 * @deprecated Use goog.userAgent.isVersionOrHigher().
 */
goog.userAgent.isVersion = goog.userAgent.isVersionOrHigher;


/**
 * Whether the IE effective document mode is higher or the same as the given
 * document mode version.
 * NOTE: Only for IE, return false for another browser.
 *
 * @param {number} documentMode The document mode version to check.
 * @return {boolean} Whether the IE effective document mode is higher or the
 *     same as the given version.
 */
goog.userAgent.isDocumentModeOrHigher = function (documentMode) {
    return goog.userAgent.IE && goog.userAgent.DOCUMENT_MODE >= documentMode;
};


/**
 * Deprecated alias to {@code goog.userAgent.isDocumentModeOrHigher}.
 * @param {number} version The version to check.
 * @return {boolean} Whether the IE effective document mode is higher or the
 *      same as the given version.
 * @deprecated Use goog.userAgent.isDocumentModeOrHigher().
 */
goog.userAgent.isDocumentMode = goog.userAgent.isDocumentModeOrHigher;


/**
 * For IE version < 7, documentMode is undefined, so attempt to use the
 * CSS1Compat property to see if we are in standards mode. If we are in
 * standards mode, treat the browser version as the document mode. Otherwise,
 * IE is emulating version 5.
 * @type {number|undefined}
 * @const
 */
goog.userAgent.DOCUMENT_MODE = (function () {
    var doc = goog.global['document'];
    if (!doc || !goog.userAgent.IE) {
        return undefined;
    }
    var mode = goog.userAgent.getDocumentMode_();
    return mode || (doc['compatMode'] == 'CSS1Compat' ?
        parseInt(goog.userAgent.VERSION, 10) : 5);
})();

// Input 5
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview Constants for user agent detection.
 */

goog.provide('wgxpath.userAgent');

goog.require('goog.userAgent');


/**
 * @type {boolean}
 * @const
 */
wgxpath.userAgent.IE_DOC_PRE_9 = goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9);


/**
 * @type {boolean}
 * @const
 */
wgxpath.userAgent.IE_DOC_PRE_8 = goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(8);

// Input 6
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview Wrapper classes for attribute nodes in old IE browsers.
 */

goog.provide('wgxpath.IEAttrWrapper');

goog.require('goog.dom.NodeType');
goog.require('wgxpath.userAgent');


/**
 * A wrapper for an attribute node in old IE.
 *
 * <p> Note: Although sourceIndex is equal to node.sourceIndex, it is
 * denormalized into a separate parameter for performance, so that clients
 * constructing multiple IEAttrWrappers can pass in the same sourceIndex
 * rather than re-querying it each time.
 *
 * @constructor
 * @extends {Attr}
 * @param {!Node} node The attribute node.
 * @param {!Node} parent The parent of the attribute node.
 * @param {string} nodeName The name of the attribute node.
 * @param {(string|number|boolean)} nodeValue The value of the attribute node.
 * @param {number} sourceIndex The source index of the parent node.
 */
wgxpath.IEAttrWrapper = function (node, parent, nodeName, nodeValue, sourceIndex) {
    /**
     * @type {!Node}
     * @private
     */
    this.node_ = node;

    /**
     * @type {string}
     */
    this.nodeName = nodeName;

    /**
     * @type {(string|number|boolean)}
     */
    this.nodeValue = nodeValue;

    /**
     * @type {goog.dom.NodeType}
     */
    this.nodeType = goog.dom.NodeType.ATTRIBUTE;

    /**
     * @type {!Node}
     */
    this.ownerElement = parent;

    /**
     * @type {number}
     * @private
     */
    this.parentSourceIndex_ = sourceIndex;

    /**
     * @type {!Node}
     */
    this.parentNode = parent;
};


/**
 * Creates a wrapper for an attribute node in old IE.
 *
 * @param {!Node} parent The parent of the attribute node.
 * @param {!Node} attr The attribute node.
 * @param {number} sourceIndex The source index of the parent node.
 * @return {!wgxpath.IEAttrWrapper} The constcuted wrapper.
 */
wgxpath.IEAttrWrapper.forAttrOf = function (parent, attr, sourceIndex) {
    var nodeValue = (wgxpath.userAgent.IE_DOC_PRE_8 && attr.nodeName == 'href') ?
        parent.getAttribute(attr.nodeName, 2) : attr.nodeValue;
    return new wgxpath.IEAttrWrapper(attr, parent, attr.nodeName, nodeValue,
        sourceIndex);
};


/**
 * Creates a wrapper for a style attribute node in old IE.
 *
 * @param {!Node} parent The parent of the attribute node.
 * @param {number} sourceIndex The source index of the parent node.
 * @return {!wgxpath.IEAttrWrapper} The constcuted wrapper.
 */
wgxpath.IEAttrWrapper.forStyleOf = function (parent, sourceIndex) {
    return new wgxpath.IEAttrWrapper(parent.style, parent, 'style',
        parent.style.cssText, sourceIndex);
};


/**
 * Returns the source index of the parent of the attribute node.
 *
 * @return {number} The source index of the parent.
 */
wgxpath.IEAttrWrapper.prototype.getParentSourceIndex = function () {
    return this.parentSourceIndex_;
};


/**
 * Returns the attribute node contained in the wrapper.
 *
 * @return {!Node} The original attribute node.
 */
wgxpath.IEAttrWrapper.prototype.getNode = function () {
    return this.node_;
};

// Input 7
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview The lexer class for tokenizing xpath expressions.
 */

goog.provide('wgxpath.Lexer');


/**
 * Constructs a lexer.
 *
 * @param {!Array.<string>} tokens Tokens to iterate over.
 * @constructor
 */
wgxpath.Lexer = function (tokens) {
    /**
     * @type {!Array.<string>}
     * @private
     */
    this.tokens_ = tokens;

    /**
     * @type {number}
     * @private
     */
    this.index_ = 0;
};


/**
 * Tokenizes a source string into an array of tokens.
 *
 * @param {string} source Source string to tokenize.
 * @return {!wgxpath.Lexer} Essentially an iterator over the tokens.
 */
wgxpath.Lexer.tokenize = function (source) {
    var tokens = source.match(wgxpath.Lexer.TOKEN_);

    // Removes tokens starting with whitespace from the array.
    for (var i = 0; i < tokens.length; i++) {
        if (wgxpath.Lexer.LEADING_WHITESPACE_.test(tokens[i])) {
            tokens.splice(i, 1);
        }
    }
    return new wgxpath.Lexer(tokens);
};


/**
 * Regular expressions to match XPath productions.
 *
 * @const
 * @type {!RegExp}
 * @private
 */
wgxpath.Lexer.TOKEN_ = new RegExp(
    '\\$?(?:(?![0-9-])[\\w-]+:)?(?![0-9-])[\\w-]+' +
        // Nodename (possibly with namespace) or variable.
        '|\\/\\/' + // Double slash.
        '|\\.\\.' + // Double dot.
        '|::' + // Double colon.
        '|\\d+(?:\\.\\d*)?' + // Number starting with digit.
        '|\\.\\d+' + // Number starting with decimal point.
        '|"[^"]*"' + // Double quoted string.
        '|\'[^\']*\'' + // Single quoted string.
        '|[!<>]=' + // Operators
        '|\\s+' + // Whitespaces.
        '|.', // Any single character.
    'g');


/**
 * Regex to check if a string starts with a whitespace character.
 *
 * @const
 * @type {!RegExp}
 * @private
 */
wgxpath.Lexer.LEADING_WHITESPACE_ = /^\s/;


/**
 * Peeks at the lexer. An optional index can be
 * used to specify the token peek at.
 *
 * @param {number=} opt_i Index to peek at. Defaults to zero.
 * @return {string} Token peeked.
 */
wgxpath.Lexer.prototype.peek = function (opt_i) {
    return this.tokens_[this.index_ + (opt_i || 0)];
};


/**
 * Returns the next token from the lexer and increments the index.
 *
 * @return {string} The next token.
 */
wgxpath.Lexer.prototype.next = function () {
    return this.tokens_[this.index_++];
};


/**
 * Decrements the index by one.
 */
wgxpath.Lexer.prototype.back = function () {
    this.index_--;
};


/**
 * Checks whether the lexer is empty.
 *
 * @return {boolean} Whether the lexer is empty.
 */
wgxpath.Lexer.prototype.empty = function () {
    return this.tokens_.length <= this.index_;
};

// Input 8
// Copyright 2009 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Provides a base class for custom Error objects such that the
 * stack is correctly maintained.
 *
 * You should never need to throw goog.debug.Error(msg) directly, Error(msg) is
 * sufficient.
 *
 */

goog.provide('goog.debug.Error');


/**
 * Base class for custom error objects.
 * @param {*=} opt_msg The message associated with the error.
 * @constructor
 * @extends {Error}
 */
goog.debug.Error = function (opt_msg) {

    // Ensure there is a stack trace.
    if (Error.captureStackTrace) {
        Error.captureStackTrace(this, goog.debug.Error);
    } else {
        this.stack = new Error().stack || '';
    }

    if (opt_msg) {
        this.message = String(opt_msg);
    }
};
goog.inherits(goog.debug.Error, Error);


/** @override */
goog.debug.Error.prototype.name = 'CustomError';

// Input 9
// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities to check the preconditions, postconditions and
 * invariants runtime.
 *
 * Methods in this package should be given special treatment by the compiler
 * for type-inference. For example, <code>goog.asserts.assert(foo)</code>
 * will restrict <code>foo</code> to a truthy value.
 *
 * The compiler has an option to disable asserts. So code like:
 * <code>
 * var x = goog.asserts.assert(foo()); goog.asserts.assert(bar());
 * </code>
 * will be transformed into:
 * <code>
 * var x = foo();
 * </code>
 * The compiler will leave in foo() (because its return value is used),
 * but it will remove bar() because it assumes it does not have side-effects.
 *
 */

goog.provide('goog.asserts');
goog.provide('goog.asserts.AssertionError');

goog.require('goog.debug.Error');
goog.require('goog.string');


/**
 * @define {boolean} Whether to strip out asserts or to leave them in.
 */
goog.define('goog.asserts.ENABLE_ASSERTS', goog.DEBUG);


/**
 * Error object for failed assertions.
 * @param {string} messagePattern The pattern that was used to form message.
 * @param {!Array.<*>} messageArgs The items to substitute into the pattern.
 * @constructor
 * @extends {goog.debug.Error}
 */
goog.asserts.AssertionError = function (messagePattern, messageArgs) {
    messageArgs.unshift(messagePattern);
    goog.debug.Error.call(this, goog.string.subs.apply(null, messageArgs));
    // Remove the messagePattern afterwards to avoid permenantly modifying the
    // passed in array.
    messageArgs.shift();

    /**
     * The message pattern used to format the error message. Error handlers can
     * use this to uniquely identify the assertion.
     * @type {string}
     */
    this.messagePattern = messagePattern;
};
goog.inherits(goog.asserts.AssertionError, goog.debug.Error);


/** @override */
goog.asserts.AssertionError.prototype.name = 'AssertionError';


/**
 * Throws an exception with the given message and "Assertion failed" prefixed
 * onto it.
 * @param {string} defaultMessage The message to use if givenMessage is empty.
 * @param {Array.<*>} defaultArgs The substitution arguments for defaultMessage.
 * @param {string|undefined} givenMessage Message supplied by the caller.
 * @param {Array.<*>} givenArgs The substitution arguments for givenMessage.
 * @throws {goog.asserts.AssertionError} When the value is not a number.
 * @private
 */
goog.asserts.doAssertFailure_ =
    function (defaultMessage, defaultArgs, givenMessage, givenArgs) {
        var message = 'Assertion failed';
        if (givenMessage) {
            message += ': ' + givenMessage;
            var args = givenArgs;
        } else if (defaultMessage) {
            message += ': ' + defaultMessage;
            args = defaultArgs;
        }
        // The '' + works around an Opera 10 bug in the unit tests. Without it,
        // a stack trace is added to var message above. With this, a stack trace is
        // not added until this line (it causes the extra garbage to be added after
        // the assertion message instead of in the middle of it).
        throw new goog.asserts.AssertionError('' + message, args || []);
    };


/**
 * Checks if the condition evaluates to true if goog.asserts.ENABLE_ASSERTS is
 * true.
 * @param {*} condition The condition to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {*} The value of the condition.
 * @throws {goog.asserts.AssertionError} When the condition evaluates to false.
 */
goog.asserts.assert = function (condition, opt_message, var_args) {
    if (goog.asserts.ENABLE_ASSERTS && !condition) {
        goog.asserts.doAssertFailure_('', null, opt_message,
            Array.prototype.slice.call(arguments, 2));
    }
    return condition;
};


/**
 * Fails if goog.asserts.ENABLE_ASSERTS is true. This function is useful in case
 * when we want to add a check in the unreachable area like switch-case
 * statement:
 *
 * <pre>
 *  switch(type) {
 *    case FOO: doSomething(); break;
 *    case BAR: doSomethingElse(); break;
 *    default: goog.assert.fail('Unrecognized type: ' + type);
 *      // We have only 2 types - "default:" section is unreachable code.
 *  }
 * </pre>
 *
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @throws {goog.asserts.AssertionError} Failure.
 */
goog.asserts.fail = function (opt_message, var_args) {
    if (goog.asserts.ENABLE_ASSERTS) {
        throw new goog.asserts.AssertionError(
            'Failure' + (opt_message ? ': ' + opt_message : ''),
            Array.prototype.slice.call(arguments, 1));
    }
};


/**
 * Checks if the value is a number if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {number} The value, guaranteed to be a number when asserts enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a number.
 */
goog.asserts.assertNumber = function (value, opt_message, var_args) {
    if (goog.asserts.ENABLE_ASSERTS && !goog.isNumber(value)) {
        goog.asserts.doAssertFailure_('Expected number but got %s: %s.',
            [goog.typeOf(value), value], opt_message,
            Array.prototype.slice.call(arguments, 2));
    }
    return /** @type {number} */ (value);
};


/**
 * Checks if the value is a string if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {string} The value, guaranteed to be a string when asserts enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a string.
 */
goog.asserts.assertString = function (value, opt_message, var_args) {
    if (goog.asserts.ENABLE_ASSERTS && !goog.isString(value)) {
        goog.asserts.doAssertFailure_('Expected string but got %s: %s.',
            [goog.typeOf(value), value], opt_message,
            Array.prototype.slice.call(arguments, 2));
    }
    return /** @type {string} */ (value);
};


/**
 * Checks if the value is a function if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Function} The value, guaranteed to be a function when asserts
 *     enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a function.
 */
goog.asserts.assertFunction = function (value, opt_message, var_args) {
    if (goog.asserts.ENABLE_ASSERTS && !goog.isFunction(value)) {
        goog.asserts.doAssertFailure_('Expected function but got %s: %s.',
            [goog.typeOf(value), value], opt_message,
            Array.prototype.slice.call(arguments, 2));
    }
    return /** @type {!Function} */ (value);
};


/**
 * Checks if the value is an Object if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Object} The value, guaranteed to be a non-null object.
 * @throws {goog.asserts.AssertionError} When the value is not an object.
 */
goog.asserts.assertObject = function (value, opt_message, var_args) {
    if (goog.asserts.ENABLE_ASSERTS && !goog.isObject(value)) {
        goog.asserts.doAssertFailure_('Expected object but got %s: %s.',
            [goog.typeOf(value), value],
            opt_message, Array.prototype.slice.call(arguments, 2));
    }
    return /** @type {!Object} */ (value);
};


/**
 * Checks if the value is an Array if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Array} The value, guaranteed to be a non-null array.
 * @throws {goog.asserts.AssertionError} When the value is not an array.
 */
goog.asserts.assertArray = function (value, opt_message, var_args) {
    if (goog.asserts.ENABLE_ASSERTS && !goog.isArray(value)) {
        goog.asserts.doAssertFailure_('Expected array but got %s: %s.',
            [goog.typeOf(value), value], opt_message,
            Array.prototype.slice.call(arguments, 2));
    }
    return /** @type {!Array} */ (value);
};


/**
 * Checks if the value is a boolean if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {boolean} The value, guaranteed to be a boolean when asserts are
 *     enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a boolean.
 */
goog.asserts.assertBoolean = function (value, opt_message, var_args) {
    if (goog.asserts.ENABLE_ASSERTS && !goog.isBoolean(value)) {
        goog.asserts.doAssertFailure_('Expected boolean but got %s: %s.',
            [goog.typeOf(value), value], opt_message,
            Array.prototype.slice.call(arguments, 2));
    }
    return /** @type {boolean} */ (value);
};


/**
 * Checks if the value is an instance of the user-defined type if
 * goog.asserts.ENABLE_ASSERTS is true.
 *
 * The compiler may tighten the type returned by this function.
 *
 * @param {*} value The value to check.
 * @param {function(new: T, ...)} type A user-defined constructor.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @throws {goog.asserts.AssertionError} When the value is not an instance of
 *     type.
 * @return {!T}
 * @template T
 */
goog.asserts.assertInstanceof = function (value, type, opt_message, var_args) {
    if (goog.asserts.ENABLE_ASSERTS && !(value instanceof type)) {
        goog.asserts.doAssertFailure_('instanceof check failed.', null,
            opt_message, Array.prototype.slice.call(arguments, 3));
    }
    return value;
};


/**
 * Checks that no enumerable keys are present in Object.prototype. Such keys
 * would break most code that use {@code for (var ... in ...)} loops.
 */
goog.asserts.assertObjectPrototypeIsIntact = function () {
    for (var key in Object.prototype) {
        goog.asserts.fail(key + ' should not be enumerable in Object.prototype.');
    }
};

// Input 10
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for manipulating arrays.
 *
 */


goog.provide('goog.array');
goog.provide('goog.array.ArrayLike');

goog.require('goog.asserts');


/**
 * @define {boolean} NATIVE_ARRAY_PROTOTYPES indicates whether the code should
 * rely on Array.prototype functions, if available.
 *
 * The Array.prototype functions can be defined by external libraries like
 * Prototype and setting this flag to false forces closure to use its own
 * goog.array implementation.
 *
 * If your javascript can be loaded by a third party site and you are wary about
 * relying on the prototype functions, specify
 * "--define goog.NATIVE_ARRAY_PROTOTYPES=false" to the JSCompiler.
 *
 * Setting goog.TRUSTED_SITE to false will automatically set
 * NATIVE_ARRAY_PROTOTYPES to false.
 */
goog.define('goog.NATIVE_ARRAY_PROTOTYPES', goog.TRUSTED_SITE);


/**
 * @typedef {Array|NodeList|Arguments|{length: number}}
 */
goog.array.ArrayLike;


/**
 * Returns the last element in an array without removing it.
 * @param {goog.array.ArrayLike} array The array.
 * @return {*} Last item in array.
 */
goog.array.peek = function (array) {
    return array[array.length - 1];
};


/**
 * Reference to the original {@code Array.prototype}.
 * @private
 */
goog.array.ARRAY_PROTOTYPE_ = Array.prototype;


// NOTE(arv): Since most of the array functions are generic it allows you to
// pass an array-like object. Strings have a length and are considered array-
// like. However, the 'in' operator does not work on strings so we cannot just
// use the array path even if the browser supports indexing into strings. We
// therefore end up splitting the string.


/**
 * Returns the index of the first element of an array with a specified
 * value, or -1 if the element is not present in the array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-indexof}
 *
 * @param {goog.array.ArrayLike} arr The array to be searched.
 * @param {*} obj The object for which we are searching.
 * @param {number=} opt_fromIndex The index at which to start the search. If
 *     omitted the search starts at index 0.
 * @return {number} The index of the first matching array element.
 */
goog.array.indexOf = goog.NATIVE_ARRAY_PROTOTYPES &&
    goog.array.ARRAY_PROTOTYPE_.indexOf ?
    function (arr, obj, opt_fromIndex) {
        goog.asserts.assert(arr.length != null);

        return goog.array.ARRAY_PROTOTYPE_.indexOf.call(arr, obj, opt_fromIndex);
    } :
    function (arr, obj, opt_fromIndex) {
        var fromIndex = opt_fromIndex == null ?
            0 : (opt_fromIndex < 0 ?
            Math.max(0, arr.length + opt_fromIndex) : opt_fromIndex);

        if (goog.isString(arr)) {
            // Array.prototype.indexOf uses === so only strings should be found.
            if (!goog.isString(obj) || obj.length != 1) {
                return -1;
            }
            return arr.indexOf(obj, fromIndex);
        }

        for (var i = fromIndex; i < arr.length; i++) {
            if (i in arr && arr[i] === obj)
                return i;
        }
        return -1;
    };


/**
 * Returns the index of the last element of an array with a specified value, or
 * -1 if the element is not present in the array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-lastindexof}
 *
 * @param {goog.array.ArrayLike} arr The array to be searched.
 * @param {*} obj The object for which we are searching.
 * @param {?number=} opt_fromIndex The index at which to start the search. If
 *     omitted the search starts at the end of the array.
 * @return {number} The index of the last matching array element.
 */
goog.array.lastIndexOf = goog.NATIVE_ARRAY_PROTOTYPES &&
    goog.array.ARRAY_PROTOTYPE_.lastIndexOf ?
    function (arr, obj, opt_fromIndex) {
        goog.asserts.assert(arr.length != null);

        // Firefox treats undefined and null as 0 in the fromIndex argument which
        // leads it to always return -1
        var fromIndex = opt_fromIndex == null ? arr.length - 1 : opt_fromIndex;
        return goog.array.ARRAY_PROTOTYPE_.lastIndexOf.call(arr, obj, fromIndex);
    } :
    function (arr, obj, opt_fromIndex) {
        var fromIndex = opt_fromIndex == null ? arr.length - 1 : opt_fromIndex;

        if (fromIndex < 0) {
            fromIndex = Math.max(0, arr.length + fromIndex);
        }

        if (goog.isString(arr)) {
            // Array.prototype.lastIndexOf uses === so only strings should be found.
            if (!goog.isString(obj) || obj.length != 1) {
                return -1;
            }
            return arr.lastIndexOf(obj, fromIndex);
        }

        for (var i = fromIndex; i >= 0; i--) {
            if (i in arr && arr[i] === obj)
                return i;
        }
        return -1;
    };


/**
 * Calls a function for each element in an array. Skips holes in the array.
 * See {@link http://tinyurl.com/developer-mozilla-org-array-foreach}
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array like object over
 *     which to iterate.
 * @param {?function(this: S, T, number, ?): ?} f The function to call for every
 *     element. This function takes 3 arguments (the element, the index and the
 *     array). The return value is ignored.
 * @param {S=} opt_obj The object to be used as the value of 'this' within f.
 * @template T,S
 */
goog.array.forEach = goog.NATIVE_ARRAY_PROTOTYPES &&
    goog.array.ARRAY_PROTOTYPE_.forEach ?
    function (arr, f, opt_obj) {
        goog.asserts.assert(arr.length != null);

        goog.array.ARRAY_PROTOTYPE_.forEach.call(arr, f, opt_obj);
    } :
    function (arr, f, opt_obj) {
        var l = arr.length;  // must be fixed during loop... see docs
        var arr2 = goog.isString(arr) ? arr.split('') : arr;
        for (var i = 0; i < l; i++) {
            if (i in arr2) {
                f.call(opt_obj, arr2[i], i, arr);
            }
        }
    };


/**
 * Calls a function for each element in an array, starting from the last
 * element rather than the first.
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this: S, T, number, ?): ?} f The function to call for every
 *     element. This function
 *     takes 3 arguments (the element, the index and the array). The return
 *     value is ignored.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @template T,S
 */
goog.array.forEachRight = function (arr, f, opt_obj) {
    var l = arr.length;  // must be fixed during loop... see docs
    var arr2 = goog.isString(arr) ? arr.split('') : arr;
    for (var i = l - 1; i >= 0; --i) {
        if (i in arr2) {
            f.call(opt_obj, arr2[i], i, arr);
        }
    }
};


/**
 * Calls a function for each element in an array, and if the function returns
 * true adds the element to a new array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-filter}
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?):boolean} f The function to call for
 *     every element. This function
 *     takes 3 arguments (the element, the index and the array) and must
 *     return a Boolean. If the return value is true the element is added to the
 *     result array. If it is false the element is not included.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @return {!Array} a new array in which only elements that passed the test are
 *     present.
 * @template T,S
 */
goog.array.filter = goog.NATIVE_ARRAY_PROTOTYPES &&
    goog.array.ARRAY_PROTOTYPE_.filter ?
    function (arr, f, opt_obj) {
        goog.asserts.assert(arr.length != null);

        return goog.array.ARRAY_PROTOTYPE_.filter.call(arr, f, opt_obj);
    } :
    function (arr, f, opt_obj) {
        var l = arr.length;  // must be fixed during loop... see docs
        var res = [];
        var resLength = 0;
        var arr2 = goog.isString(arr) ? arr.split('') : arr;
        for (var i = 0; i < l; i++) {
            if (i in arr2) {
                var val = arr2[i];  // in case f mutates arr2
                if (f.call(opt_obj, val, i, arr)) {
                    res[resLength++] = val;
                }
            }
        }
        return res;
    };


/**
 * Calls a function for each element in an array and inserts the result into a
 * new array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-map}
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?):?} f The function to call for every
 *     element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return something. The result will be inserted into a new array.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @return {!Array} a new array with the results from f.
 * @template T,S
 */
goog.array.map = goog.NATIVE_ARRAY_PROTOTYPES &&
    goog.array.ARRAY_PROTOTYPE_.map ?
    function (arr, f, opt_obj) {
        goog.asserts.assert(arr.length != null);

        return goog.array.ARRAY_PROTOTYPE_.map.call(arr, f, opt_obj);
    } :
    function (arr, f, opt_obj) {
        var l = arr.length;  // must be fixed during loop... see docs
        var res = new Array(l);
        var arr2 = goog.isString(arr) ? arr.split('') : arr;
        for (var i = 0; i < l; i++) {
            if (i in arr2) {
                res[i] = f.call(opt_obj, arr2[i], i, arr);
            }
        }
        return res;
    };


/**
 * Passes every element of an array into a function and accumulates the result.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-reduce}
 *
 * For example:
 * var a = [1, 2, 3, 4];
 * goog.array.reduce(a, function(r, v, i, arr) {return r + v;}, 0);
 * returns 10
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, R, T, number, ?) : R} f The function to call for
 *     every element. This function
 *     takes 4 arguments (the function's previous result or the initial value,
 *     the value of the current array element, the current array index, and the
 *     array itself)
 *     function(previousValue, currentValue, index, array).
 * @param {?} val The initial value to pass into the function on the first call.
 * @param {S=} opt_obj  The object to be used as the value of 'this'
 *     within f.
 * @return {R} Result of evaluating f repeatedly across the values of the array.
 * @template T,S,R
 */
goog.array.reduce = goog.NATIVE_ARRAY_PROTOTYPES &&
    goog.array.ARRAY_PROTOTYPE_.reduce ?
    function (arr, f, val, opt_obj) {
        goog.asserts.assert(arr.length != null);
        if (opt_obj) {
            f = goog.bind(f, opt_obj);
        }
        return goog.array.ARRAY_PROTOTYPE_.reduce.call(arr, f, val);
    } :
    function (arr, f, val, opt_obj) {
        var rval = val;
        goog.array.forEach(arr, function (val, index) {
            rval = f.call(opt_obj, rval, val, index, arr);
        });
        return rval;
    };


/**
 * Passes every element of an array into a function and accumulates the result,
 * starting from the last element and working towards the first.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-reduceright}
 *
 * For example:
 * var a = ['a', 'b', 'c'];
 * goog.array.reduceRight(a, function(r, v, i, arr) {return r + v;}, '');
 * returns 'cba'
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, R, T, number, ?) : R} f The function to call for
 *     every element. This function
 *     takes 4 arguments (the function's previous result or the initial value,
 *     the value of the current array element, the current array index, and the
 *     array itself)
 *     function(previousValue, currentValue, index, array).
 * @param {?} val The initial value to pass into the function on the first call.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @return {R} Object returned as a result of evaluating f repeatedly across the
 *     values of the array.
 * @template T,S,R
 */
goog.array.reduceRight = goog.NATIVE_ARRAY_PROTOTYPES &&
    goog.array.ARRAY_PROTOTYPE_.reduceRight ?
    function (arr, f, val, opt_obj) {
        goog.asserts.assert(arr.length != null);
        if (opt_obj) {
            f = goog.bind(f, opt_obj);
        }
        return goog.array.ARRAY_PROTOTYPE_.reduceRight.call(arr, f, val);
    } :
    function (arr, f, val, opt_obj) {
        var rval = val;
        goog.array.forEachRight(arr, function (val, index) {
            rval = f.call(opt_obj, rval, val, index, arr);
        });
        return rval;
    };


/**
 * Calls f for each element of an array. If any call returns true, some()
 * returns true (without checking the remaining elements). If all calls
 * return false, some() returns false.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-some}
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call for
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the array) and should return a boolean.
 * @param {S=} opt_obj  The object to be used as the value of 'this'
 *     within f.
 * @return {boolean} true if any element passes the test.
 * @template T,S
 */
goog.array.some = goog.NATIVE_ARRAY_PROTOTYPES &&
    goog.array.ARRAY_PROTOTYPE_.some ?
    function (arr, f, opt_obj) {
        goog.asserts.assert(arr.length != null);

        return goog.array.ARRAY_PROTOTYPE_.some.call(arr, f, opt_obj);
    } :
    function (arr, f, opt_obj) {
        var l = arr.length;  // must be fixed during loop... see docs
        var arr2 = goog.isString(arr) ? arr.split('') : arr;
        for (var i = 0; i < l; i++) {
            if (i in arr2 && f.call(opt_obj, arr2[i], i, arr)) {
                return true;
            }
        }
        return false;
    };


/**
 * Call f for each element of an array. If all calls return true, every()
 * returns true. If any call returns false, every() returns false and
 * does not continue to check the remaining elements.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-every}
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call for
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the array) and should return a boolean.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @return {boolean} false if any element fails the test.
 * @template T,S
 */
goog.array.every = goog.NATIVE_ARRAY_PROTOTYPES &&
    goog.array.ARRAY_PROTOTYPE_.every ?
    function (arr, f, opt_obj) {
        goog.asserts.assert(arr.length != null);

        return goog.array.ARRAY_PROTOTYPE_.every.call(arr, f, opt_obj);
    } :
    function (arr, f, opt_obj) {
        var l = arr.length;  // must be fixed during loop... see docs
        var arr2 = goog.isString(arr) ? arr.split('') : arr;
        for (var i = 0; i < l; i++) {
            if (i in arr2 && !f.call(opt_obj, arr2[i], i, arr)) {
                return false;
            }
        }
        return true;
    };


/**
 * Counts the array elements that fulfill the predicate, i.e. for which the
 * callback function returns true. Skips holes in the array.
 *
 * @param {!(Array.<T>|goog.array.ArrayLike)} arr Array or array like object
 *     over which to iterate.
 * @param {function(this: S, T, number, ?): boolean} f The function to call for
 *     every element. Takes 3 arguments (the element, the index and the array).
 * @param {S=} opt_obj The object to be used as the value of 'this' within f.
 * @return {number} The number of the matching elements.
 * @template T,S
 */
goog.array.count = function (arr, f, opt_obj) {
    var count = 0;
    goog.array.forEach(arr, function (element, index, arr) {
        if (f.call(opt_obj, element, index, arr)) {
            ++count;
        }
    }, opt_obj);
    return count;
};


/**
 * Search an array for the first element that satisfies a given condition and
 * return that element.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the array) and should return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {T} The first array element that passes the test, or null if no
 *     element is found.
 * @template T,S
 */
goog.array.find = function (arr, f, opt_obj) {
    var i = goog.array.findIndex(arr, f, opt_obj);
    return i < 0 ? null : goog.isString(arr) ? arr.charAt(i) : arr[i];
};


/**
 * Search an array for the first element that satisfies a given condition and
 * return its index.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call for
 *     every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {number} The index of the first array element that passes the test,
 *     or -1 if no element is found.
 * @template T,S
 */
goog.array.findIndex = function (arr, f, opt_obj) {
    var l = arr.length;  // must be fixed during loop... see docs
    var arr2 = goog.isString(arr) ? arr.split('') : arr;
    for (var i = 0; i < l; i++) {
        if (i in arr2 && f.call(opt_obj, arr2[i], i, arr)) {
            return i;
        }
    }
    return -1;
};


/**
 * Search an array (in reverse order) for the last element that satisfies a
 * given condition and return that element.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {T} The last array element that passes the test, or null if no
 *     element is found.
 * @template T,S
 */
goog.array.findRight = function (arr, f, opt_obj) {
    var i = goog.array.findIndexRight(arr, f, opt_obj);
    return i < 0 ? null : goog.isString(arr) ? arr.charAt(i) : arr[i];
};


/**
 * Search an array (in reverse order) for the last element that satisfies a
 * given condition and return its index.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {Object=} opt_obj An optional "this" context for the function.
 * @return {number} The index of the last array element that passes the test,
 *     or -1 if no element is found.
 * @template T,S
 */
goog.array.findIndexRight = function (arr, f, opt_obj) {
    var l = arr.length;  // must be fixed during loop... see docs
    var arr2 = goog.isString(arr) ? arr.split('') : arr;
    for (var i = l - 1; i >= 0; i--) {
        if (i in arr2 && f.call(opt_obj, arr2[i], i, arr)) {
            return i;
        }
    }
    return -1;
};


/**
 * Whether the array contains the given object.
 * @param {goog.array.ArrayLike} arr The array to test for the presence of the
 *     element.
 * @param {*} obj The object for which to test.
 * @return {boolean} true if obj is present.
 */
goog.array.contains = function (arr, obj) {
    return goog.array.indexOf(arr, obj) >= 0;
};


/**
 * Whether the array is empty.
 * @param {goog.array.ArrayLike} arr The array to test.
 * @return {boolean} true if empty.
 */
goog.array.isEmpty = function (arr) {
    return arr.length == 0;
};


/**
 * Clears the array.
 * @param {goog.array.ArrayLike} arr Array or array like object to clear.
 */
goog.array.clear = function (arr) {
    // For non real arrays we don't have the magic length so we delete the
    // indices.
    if (!goog.isArray(arr)) {
        for (var i = arr.length - 1; i >= 0; i--) {
            delete arr[i];
        }
    }
    arr.length = 0;
};


/**
 * Pushes an item into an array, if it's not already in the array.
 * @param {Array.<T>} arr Array into which to insert the item.
 * @param {T} obj Value to add.
 * @template T
 */
goog.array.insert = function (arr, obj) {
    if (!goog.array.contains(arr, obj)) {
        arr.push(obj);
    }
};


/**
 * Inserts an object at the given index of the array.
 * @param {goog.array.ArrayLike} arr The array to modify.
 * @param {*} obj The object to insert.
 * @param {number=} opt_i The index at which to insert the object. If omitted,
 *      treated as 0. A negative index is counted from the end of the array.
 */
goog.array.insertAt = function (arr, obj, opt_i) {
    goog.array.splice(arr, opt_i, 0, obj);
};


/**
 * Inserts at the given index of the array, all elements of another array.
 * @param {goog.array.ArrayLike} arr The array to modify.
 * @param {goog.array.ArrayLike} elementsToAdd The array of elements to add.
 * @param {number=} opt_i The index at which to insert the object. If omitted,
 *      treated as 0. A negative index is counted from the end of the array.
 */
goog.array.insertArrayAt = function (arr, elementsToAdd, opt_i) {
    goog.partial(goog.array.splice, arr, opt_i, 0).apply(null, elementsToAdd);
};


/**
 * Inserts an object into an array before a specified object.
 * @param {Array.<T>} arr The array to modify.
 * @param {T} obj The object to insert.
 * @param {T=} opt_obj2 The object before which obj should be inserted. If obj2
 *     is omitted or not found, obj is inserted at the end of the array.
 * @template T
 */
goog.array.insertBefore = function (arr, obj, opt_obj2) {
    var i;
    if (arguments.length == 2 || (i = goog.array.indexOf(arr, opt_obj2)) < 0) {
        arr.push(obj);
    } else {
        goog.array.insertAt(arr, obj, i);
    }
};


/**
 * Removes the first occurrence of a particular value from an array.
 * @param {goog.array.ArrayLike} arr Array from which to remove value.
 * @param {*} obj Object to remove.
 * @return {boolean} True if an element was removed.
 */
goog.array.remove = function (arr, obj) {
    var i = goog.array.indexOf(arr, obj);
    var rv;
    if ((rv = i >= 0)) {
        goog.array.removeAt(arr, i);
    }
    return rv;
};


/**
 * Removes from an array the element at index i
 * @param {goog.array.ArrayLike} arr Array or array like object from which to
 *     remove value.
 * @param {number} i The index to remove.
 * @return {boolean} True if an element was removed.
 */
goog.array.removeAt = function (arr, i) {
    goog.asserts.assert(arr.length != null);

    // use generic form of splice
    // splice returns the removed items and if successful the length of that
    // will be 1
    return goog.array.ARRAY_PROTOTYPE_.splice.call(arr, i, 1).length == 1;
};


/**
 * Removes the first value that satisfies the given condition.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {boolean} True if an element was removed.
 * @template T,S
 */
goog.array.removeIf = function (arr, f, opt_obj) {
    var i = goog.array.findIndex(arr, f, opt_obj);
    if (i >= 0) {
        goog.array.removeAt(arr, i);
        return true;
    }
    return false;
};


/**
 * Returns a new array that is the result of joining the arguments.  If arrays
 * are passed then their items are added, however, if non-arrays are passed they
 * will be added to the return array as is.
 *
 * Note that ArrayLike objects will be added as is, rather than having their
 * items added.
 *
 * goog.array.concat([1, 2], [3, 4]) -> [1, 2, 3, 4]
 * goog.array.concat(0, [1, 2]) -> [0, 1, 2]
 * goog.array.concat([1, 2], null) -> [1, 2, null]
 *
 * There is bug in all current versions of IE (6, 7 and 8) where arrays created
 * in an iframe become corrupted soon (not immediately) after the iframe is
 * destroyed. This is common if loading data via goog.net.IframeIo, for example.
 * This corruption only affects the concat method which will start throwing
 * Catastrophic Errors (#-2147418113).
 *
 * See http://endoflow.com/scratch/corrupted-arrays.html for a test case.
 *
 * Internally goog.array should use this, so that all methods will continue to
 * work on these broken array objects.
 *
 * @param {...*} var_args Items to concatenate.  Arrays will have each item
 *     added, while primitives and objects will be added as is.
 * @return {!Array} The new resultant array.
 */
goog.array.concat = function (var_args) {
    return goog.array.ARRAY_PROTOTYPE_.concat.apply(
        goog.array.ARRAY_PROTOTYPE_, arguments);
};


/**
 * Converts an object to an array.
 * @param {goog.array.ArrayLike} object  The object to convert to an array.
 * @return {!Array} The object converted into an array. If object has a
 *     length property, every property indexed with a non-negative number
 *     less than length will be included in the result. If object does not
 *     have a length property, an empty array will be returned.
 */
goog.array.toArray = function (object) {
    var length = object.length;

    // If length is not a number the following it false. This case is kept for
    // backwards compatibility since there are callers that pass objects that are
    // not array like.
    if (length > 0) {
        var rv = new Array(length);
        for (var i = 0; i < length; i++) {
            rv[i] = object[i];
        }
        return rv;
    }
    return [];
};


/**
 * Does a shallow copy of an array.
 * @param {goog.array.ArrayLike} arr  Array or array-like object to clone.
 * @return {!Array} Clone of the input array.
 */
goog.array.clone = goog.array.toArray;


/**
 * Extends an array with another array, element, or "array like" object.
 * This function operates 'in-place', it does not create a new Array.
 *
 * Example:
 * var a = [];
 * goog.array.extend(a, [0, 1]);
 * a; // [0, 1]
 * goog.array.extend(a, 2);
 * a; // [0, 1, 2]
 *
 * @param {Array} arr1  The array to modify.
 * @param {...*} var_args The elements or arrays of elements to add to arr1.
 */
goog.array.extend = function (arr1, var_args) {
    for (var i = 1; i < arguments.length; i++) {
        var arr2 = arguments[i];
        // If we have an Array or an Arguments object we can just call push
        // directly.
        var isArrayLike;
        if (goog.isArray(arr2) ||
            // Detect Arguments. ES5 says that the [[Class]] of an Arguments object
            // is "Arguments" but only V8 and JSC/Safari gets this right. We instead
            // detect Arguments by checking for array like and presence of "callee".
            (isArrayLike = goog.isArrayLike(arr2)) &&
                // The getter for callee throws an exception in strict mode
                // according to section 10.6 in ES5 so check for presence instead.
                Object.prototype.hasOwnProperty.call(arr2, 'callee')) {
            arr1.push.apply(arr1, arr2);
        } else if (isArrayLike) {
            // Otherwise loop over arr2 to prevent copying the object.
            var len1 = arr1.length;
            var len2 = arr2.length;
            for (var j = 0; j < len2; j++) {
                arr1[len1 + j] = arr2[j];
            }
        } else {
            arr1.push(arr2);
        }
    }
};


/**
 * Adds or removes elements from an array. This is a generic version of Array
 * splice. This means that it might work on other objects similar to arrays,
 * such as the arguments object.
 *
 * @param {goog.array.ArrayLike} arr The array to modify.
 * @param {number|undefined} index The index at which to start changing the
 *     array. If not defined, treated as 0.
 * @param {number} howMany How many elements to remove (0 means no removal. A
 *     value below 0 is treated as zero and so is any other non number. Numbers
 *     are floored).
 * @param {...*} var_args Optional, additional elements to insert into the
 *     array.
 * @return {!Array} the removed elements.
 */
goog.array.splice = function (arr, index, howMany, var_args) {
    goog.asserts.assert(arr.length != null);

    return goog.array.ARRAY_PROTOTYPE_.splice.apply(
        arr, goog.array.slice(arguments, 1));
};


/**
 * Returns a new array from a segment of an array. This is a generic version of
 * Array slice. This means that it might work on other objects similar to
 * arrays, such as the arguments object.
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr The array from
 * which to copy a segment.
 * @param {number} start The index of the first element to copy.
 * @param {number=} opt_end The index after the last element to copy.
 * @return {!Array.<T>} A new array containing the specified segment of the
 *     original array.
 * @template T
 */
goog.array.slice = function (arr, start, opt_end) {
    goog.asserts.assert(arr.length != null);

    // passing 1 arg to slice is not the same as passing 2 where the second is
    // null or undefined (in that case the second argument is treated as 0).
    // we could use slice on the arguments object and then use apply instead of
    // testing the length
    if (arguments.length <= 2) {
        return goog.array.ARRAY_PROTOTYPE_.slice.call(arr, start);
    } else {
        return goog.array.ARRAY_PROTOTYPE_.slice.call(arr, start, opt_end);
    }
};


/**
 * Removes all duplicates from an array (retaining only the first
 * occurrence of each array element).  This function modifies the
 * array in place and doesn't change the order of the non-duplicate items.
 *
 * For objects, duplicates are identified as having the same unique ID as
 * defined by {@link goog.getUid}.
 *
 * Runtime: N,
 * Worstcase space: 2N (no dupes)
 *
 * @param {goog.array.ArrayLike} arr The array from which to remove duplicates.
 * @param {Array=} opt_rv An optional array in which to return the results,
 *     instead of performing the removal inplace.  If specified, the original
 *     array will remain unchanged.
 */
goog.array.removeDuplicates = function (arr, opt_rv) {
    var returnArray = opt_rv || arr;

    var seen = {}, cursorInsert = 0, cursorRead = 0;
    while (cursorRead < arr.length) {
        var current = arr[cursorRead++];

        // Prefix each type with a single character representing the type to
        // prevent conflicting keys (e.g. true and 'true').
        var key = goog.isObject(current) ?
            'o' + goog.getUid(current) :
            (typeof current).charAt(0) + current;

        if (!Object.prototype.hasOwnProperty.call(seen, key)) {
            seen[key] = true;
            returnArray[cursorInsert++] = current;
        }
    }
    returnArray.length = cursorInsert;
};


/**
 * Searches the specified array for the specified target using the binary
 * search algorithm.  If no opt_compareFn is specified, elements are compared
 * using <code>goog.array.defaultCompare</code>, which compares the elements
 * using the built in < and > operators.  This will produce the expected
 * behavior for homogeneous arrays of String(s) and Number(s). The array
 * specified <b>must</b> be sorted in ascending order (as defined by the
 * comparison function).  If the array is not sorted, results are undefined.
 * If the array contains multiple instances of the specified target value, any
 * of these instances may be found.
 *
 * Runtime: O(log n)
 *
 * @param {goog.array.ArrayLike} arr The array to be searched.
 * @param {*} target The sought value.
 * @param {Function=} opt_compareFn Optional comparison function by which the
 *     array is ordered. Should take 2 arguments to compare, and return a
 *     negative number, zero, or a positive number depending on whether the
 *     first argument is less than, equal to, or greater than the second.
 * @return {number} Lowest index of the target value if found, otherwise
 *     (-(insertion point) - 1). The insertion point is where the value should
 *     be inserted into arr to preserve the sorted property.  Return value >= 0
 *     iff target is found.
 */
goog.array.binarySearch = function (arr, target, opt_compareFn) {
    return goog.array.binarySearch_(arr,
        opt_compareFn || goog.array.defaultCompare, false /* isEvaluator */,
        target);
};


/**
 * Selects an index in the specified array using the binary search algorithm.
 * The evaluator receives an element and determines whether the desired index
 * is before, at, or after it.  The evaluator must be consistent (formally,
 * goog.array.map(goog.array.map(arr, evaluator, opt_obj), goog.math.sign)
 * must be monotonically non-increasing).
 *
 * Runtime: O(log n)
 *
 * @param {goog.array.ArrayLike} arr The array to be searched.
 * @param {Function} evaluator Evaluator function that receives 3 arguments
 *     (the element, the index and the array). Should return a negative number,
 *     zero, or a positive number depending on whether the desired index is
 *     before, at, or after the element passed to it.
 * @param {Object=} opt_obj The object to be used as the value of 'this'
 *     within evaluator.
 * @return {number} Index of the leftmost element matched by the evaluator, if
 *     such exists; otherwise (-(insertion point) - 1). The insertion point is
 *     the index of the first element for which the evaluator returns negative,
 *     or arr.length if no such element exists. The return value is non-negative
 *     iff a match is found.
 */
goog.array.binarySelect = function (arr, evaluator, opt_obj) {
    return goog.array.binarySearch_(arr, evaluator, true /* isEvaluator */,
        undefined /* opt_target */, opt_obj);
};


/**
 * Implementation of a binary search algorithm which knows how to use both
 * comparison functions and evaluators. If an evaluator is provided, will call
 * the evaluator with the given optional data object, conforming to the
 * interface defined in binarySelect. Otherwise, if a comparison function is
 * provided, will call the comparison function against the given data object.
 *
 * This implementation purposefully does not use goog.bind or goog.partial for
 * performance reasons.
 *
 * Runtime: O(log n)
 *
 * @param {goog.array.ArrayLike} arr The array to be searched.
 * @param {Function} compareFn Either an evaluator or a comparison function,
 *     as defined by binarySearch and binarySelect above.
 * @param {boolean} isEvaluator Whether the function is an evaluator or a
 *     comparison function.
 * @param {*=} opt_target If the function is a comparison function, then this is
 *     the target to binary search for.
 * @param {Object=} opt_selfObj If the function is an evaluator, this is an
 *    optional this object for the evaluator.
 * @return {number} Lowest index of the target value if found, otherwise
 *     (-(insertion point) - 1). The insertion point is where the value should
 *     be inserted into arr to preserve the sorted property.  Return value >= 0
 *     iff target is found.
 * @private
 */
goog.array.binarySearch_ = function (arr, compareFn, isEvaluator, opt_target, opt_selfObj) {
    var left = 0;  // inclusive
    var right = arr.length;  // exclusive
    var found;
    while (left < right) {
        var middle = (left + right) >> 1;
        var compareResult;
        if (isEvaluator) {
            compareResult = compareFn.call(opt_selfObj, arr[middle], middle, arr);
        } else {
            compareResult = compareFn(opt_target, arr[middle]);
        }
        if (compareResult > 0) {
            left = middle + 1;
        } else {
            right = middle;
            // We are looking for the lowest index so we can't return immediately.
            found = !compareResult;
        }
    }
    // left is the index if found, or the insertion point otherwise.
    // ~left is a shorthand for -left - 1.
    return found ? left : ~left;
};


/**
 * Sorts the specified array into ascending order.  If no opt_compareFn is
 * specified, elements are compared using
 * <code>goog.array.defaultCompare</code>, which compares the elements using
 * the built in < and > operators.  This will produce the expected behavior
 * for homogeneous arrays of String(s) and Number(s), unlike the native sort,
 * but will give unpredictable results for heterogenous lists of strings and
 * numbers with different numbers of digits.
 *
 * This sort is not guaranteed to be stable.
 *
 * Runtime: Same as <code>Array.prototype.sort</code>
 *
 * @param {Array.<T>} arr The array to be sorted.
 * @param {?function(T,T):number=} opt_compareFn Optional comparison
 *     function by which the
 *     array is to be ordered. Should take 2 arguments to compare, and return a
 *     negative number, zero, or a positive number depending on whether the
 *     first argument is less than, equal to, or greater than the second.
 * @template T
 */
goog.array.sort = function (arr, opt_compareFn) {
    // TODO(arv): Update type annotation since null is not accepted.
    goog.asserts.assert(arr.length != null);

    goog.array.ARRAY_PROTOTYPE_.sort.call(
        arr, opt_compareFn || goog.array.defaultCompare);
};


/**
 * Sorts the specified array into ascending order in a stable way.  If no
 * opt_compareFn is specified, elements are compared using
 * <code>goog.array.defaultCompare</code>, which compares the elements using
 * the built in < and > operators.  This will produce the expected behavior
 * for homogeneous arrays of String(s) and Number(s).
 *
 * Runtime: Same as <code>Array.prototype.sort</code>, plus an additional
 * O(n) overhead of copying the array twice.
 *
 * @param {Array.<T>} arr The array to be sorted.
 * @param {?function(T, T): number=} opt_compareFn Optional comparison function
 *     by which the array is to be ordered. Should take 2 arguments to compare,
 *     and return a negative number, zero, or a positive number depending on
 *     whether the first argument is less than, equal to, or greater than the
 *     second.
 * @template T
 */
goog.array.stableSort = function (arr, opt_compareFn) {
    for (var i = 0; i < arr.length; i++) {
        arr[i] = {index: i, value: arr[i]};
    }
    var valueCompareFn = opt_compareFn || goog.array.defaultCompare;

    function stableCompareFn(obj1, obj2) {
        return valueCompareFn(obj1.value, obj2.value) || obj1.index - obj2.index;
    };
    goog.array.sort(arr, stableCompareFn);
    for (var i = 0; i < arr.length; i++) {
        arr[i] = arr[i].value;
    }
};


/**
 * Sorts an array of objects by the specified object key and compare
 * function. If no compare function is provided, the key values are
 * compared in ascending order using <code>goog.array.defaultCompare</code>.
 * This won't work for keys that get renamed by the compiler. So use
 * {'foo': 1, 'bar': 2} rather than {foo: 1, bar: 2}.
 * @param {Array.<Object>} arr An array of objects to sort.
 * @param {string} key The object key to sort by.
 * @param {Function=} opt_compareFn The function to use to compare key
 *     values.
 */
goog.array.sortObjectsByKey = function (arr, key, opt_compareFn) {
    var compare = opt_compareFn || goog.array.defaultCompare;
    goog.array.sort(arr, function (a, b) {
        return compare(a[key], b[key]);
    });
};


/**
 * Tells if the array is sorted.
 * @param {!Array.<T>} arr The array.
 * @param {?function(T,T):number=} opt_compareFn Function to compare the
 *     array elements.
 *     Should take 2 arguments to compare, and return a negative number, zero,
 *     or a positive number depending on whether the first argument is less
 *     than, equal to, or greater than the second.
 * @param {boolean=} opt_strict If true no equal elements are allowed.
 * @return {boolean} Whether the array is sorted.
 * @template T
 */
goog.array.isSorted = function (arr, opt_compareFn, opt_strict) {
    var compare = opt_compareFn || goog.array.defaultCompare;
    for (var i = 1; i < arr.length; i++) {
        var compareResult = compare(arr[i - 1], arr[i]);
        if (compareResult > 0 || compareResult == 0 && opt_strict) {
            return false;
        }
    }
    return true;
};


/**
 * Compares two arrays for equality. Two arrays are considered equal if they
 * have the same length and their corresponding elements are equal according to
 * the comparison function.
 *
 * @param {goog.array.ArrayLike} arr1 The first array to compare.
 * @param {goog.array.ArrayLike} arr2 The second array to compare.
 * @param {Function=} opt_equalsFn Optional comparison function.
 *     Should take 2 arguments to compare, and return true if the arguments
 *     are equal. Defaults to {@link goog.array.defaultCompareEquality} which
 *     compares the elements using the built-in '===' operator.
 * @return {boolean} Whether the two arrays are equal.
 */
goog.array.equals = function (arr1, arr2, opt_equalsFn) {
    if (!goog.isArrayLike(arr1) || !goog.isArrayLike(arr2) ||
        arr1.length != arr2.length) {
        return false;
    }
    var l = arr1.length;
    var equalsFn = opt_equalsFn || goog.array.defaultCompareEquality;
    for (var i = 0; i < l; i++) {
        if (!equalsFn(arr1[i], arr2[i])) {
            return false;
        }
    }
    return true;
};


/**
 * @deprecated Use {@link goog.array.equals}.
 * @param {goog.array.ArrayLike} arr1 See {@link goog.array.equals}.
 * @param {goog.array.ArrayLike} arr2 See {@link goog.array.equals}.
 * @param {Function=} opt_equalsFn See {@link goog.array.equals}.
 * @return {boolean} See {@link goog.array.equals}.
 */
goog.array.compare = function (arr1, arr2, opt_equalsFn) {
    return goog.array.equals(arr1, arr2, opt_equalsFn);
};


/**
 * 3-way array compare function.
 * @param {!goog.array.ArrayLike} arr1 The first array to compare.
 * @param {!goog.array.ArrayLike} arr2 The second array to compare.
 * @param {?function(?, ?): number=} opt_compareFn Optional comparison function
 *     by which the array is to be ordered. Should take 2 arguments to compare,
 *     and return a negative number, zero, or a positive number depending on
 *     whether the first argument is less than, equal to, or greater than the
 *     second.
 * @return {number} Negative number, zero, or a positive number depending on
 *     whether the first argument is less than, equal to, or greater than the
 *     second.
 */
goog.array.compare3 = function (arr1, arr2, opt_compareFn) {
    var compare = opt_compareFn || goog.array.defaultCompare;
    var l = Math.min(arr1.length, arr2.length);
    for (var i = 0; i < l; i++) {
        var result = compare(arr1[i], arr2[i]);
        if (result != 0) {
            return result;
        }
    }
    return goog.array.defaultCompare(arr1.length, arr2.length);
};


/**
 * Compares its two arguments for order, using the built in < and >
 * operators.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 */
goog.array.defaultCompare = function (a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
};


/**
 * Compares its two arguments for equality, using the built in === operator.
 * @param {*} a The first object to compare.
 * @param {*} b The second object to compare.
 * @return {boolean} True if the two arguments are equal, false otherwise.
 */
goog.array.defaultCompareEquality = function (a, b) {
    return a === b;
};


/**
 * Inserts a value into a sorted array. The array is not modified if the
 * value is already present.
 * @param {Array.<T>} array The array to modify.
 * @param {T} value The object to insert.
 * @param {?function(T,T):number=} opt_compareFn Optional comparison function by
 *     which the
 *     array is ordered. Should take 2 arguments to compare, and return a
 *     negative number, zero, or a positive number depending on whether the
 *     first argument is less than, equal to, or greater than the second.
 * @return {boolean} True if an element was inserted.
 * @template T
 */
goog.array.binaryInsert = function (array, value, opt_compareFn) {
    var index = goog.array.binarySearch(array, value, opt_compareFn);
    if (index < 0) {
        goog.array.insertAt(array, value, -(index + 1));
        return true;
    }
    return false;
};


/**
 * Removes a value from a sorted array.
 * @param {Array} array The array to modify.
 * @param {*} value The object to remove.
 * @param {Function=} opt_compareFn Optional comparison function by which the
 *     array is ordered. Should take 2 arguments to compare, and return a
 *     negative number, zero, or a positive number depending on whether the
 *     first argument is less than, equal to, or greater than the second.
 * @return {boolean} True if an element was removed.
 */
goog.array.binaryRemove = function (array, value, opt_compareFn) {
    var index = goog.array.binarySearch(array, value, opt_compareFn);
    return (index >= 0) ? goog.array.removeAt(array, index) : false;
};


/**
 * Splits an array into disjoint buckets according to a splitting function.
 * @param {Array.<T>} array The array.
 * @param {function(this:S, T,number,Array.<T>):?} sorter Function to call for
 *     every element.  This takes 3 arguments (the element, the index and the
 *     array) and must return a valid object key (a string, number, etc), or
 *     undefined, if that object should not be placed in a bucket.
 * @param {S=} opt_obj The object to be used as the value of 'this' within
 *     sorter.
 * @return {!Object} An object, with keys being all of the unique return values
 *     of sorter, and values being arrays containing the items for
 *     which the splitter returned that key.
 * @template T,S
 */
goog.array.bucket = function (array, sorter, opt_obj) {
    var buckets = {};

    for (var i = 0; i < array.length; i++) {
        var value = array[i];
        var key = sorter.call(opt_obj, value, i, array);
        if (goog.isDef(key)) {
            // Push the value to the right bucket, creating it if necessary.
            var bucket = buckets[key] || (buckets[key] = []);
            bucket.push(value);
        }
    }

    return buckets;
};


/**
 * Creates a new object built from the provided array and the key-generation
 * function.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array like object over
 *     which to iterate whose elements will be the values in the new object.
 * @param {?function(this:S, T, number, ?) : string} keyFunc The function to
 *     call for every element. This function takes 3 arguments (the element, the
 *     index and the array) and should return a string that will be used as the
 *     key for the element in the new object. If the function returns the same
 *     key for more than one element, the value for that key is
 *     implementation-defined.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within keyFunc.
 * @return {!Object.<T>} The new object.
 * @template T,S
 */
goog.array.toObject = function (arr, keyFunc, opt_obj) {
    var ret = {};
    goog.array.forEach(arr, function (element, index) {
        ret[keyFunc.call(opt_obj, element, index, arr)] = element;
    });
    return ret;
};


/**
 * Creates a range of numbers in an arithmetic progression.
 *
 * Range takes 1, 2, or 3 arguments:
 * <pre>
 * range(5) is the same as range(0, 5, 1) and produces [0, 1, 2, 3, 4]
 * range(2, 5) is the same as range(2, 5, 1) and produces [2, 3, 4]
 * range(-2, -5, -1) produces [-2, -3, -4]
 * range(-2, -5, 1) produces [], since stepping by 1 wouldn't ever reach -5.
 * </pre>
 *
 * @param {number} startOrEnd The starting value of the range if an end argument
 *     is provided. Otherwise, the start value is 0, and this is the end value.
 * @param {number=} opt_end The optional end value of the range.
 * @param {number=} opt_step The step size between range values. Defaults to 1
 *     if opt_step is undefined or 0.
 * @return {!Array.<number>} An array of numbers for the requested range. May be
 *     an empty array if adding the step would not converge toward the end
 *     value.
 */
goog.array.range = function (startOrEnd, opt_end, opt_step) {
    var array = [];
    var start = 0;
    var end = startOrEnd;
    var step = opt_step || 1;
    if (opt_end !== undefined) {
        start = startOrEnd;
        end = opt_end;
    }

    if (step * (end - start) < 0) {
        // Sign mismatch: start + step will never reach the end value.
        return [];
    }

    if (step > 0) {
        for (var i = start; i < end; i += step) {
            array.push(i);
        }
    } else {
        for (var i = start; i > end; i += step) {
            array.push(i);
        }
    }
    return array;
};


/**
 * Returns an array consisting of the given value repeated N times.
 *
 * @param {*} value The value to repeat.
 * @param {number} n The repeat count.
 * @return {!Array} An array with the repeated value.
 */
goog.array.repeat = function (value, n) {
    var array = [];
    for (var i = 0; i < n; i++) {
        array[i] = value;
    }
    return array;
};


/**
 * Returns an array consisting of every argument with all arrays
 * expanded in-place recursively.
 *
 * @param {...*} var_args The values to flatten.
 * @return {!Array} An array containing the flattened values.
 */
goog.array.flatten = function (var_args) {
    var result = [];
    for (var i = 0; i < arguments.length; i++) {
        var element = arguments[i];
        if (goog.isArray(element)) {
            result.push.apply(result, goog.array.flatten.apply(null, element));
        } else {
            result.push(element);
        }
    }
    return result;
};


/**
 * Rotates an array in-place. After calling this method, the element at
 * index i will be the element previously at index (i - n) %
 * array.length, for all values of i between 0 and array.length - 1,
 * inclusive.
 *
 * For example, suppose list comprises [t, a, n, k, s]. After invoking
 * rotate(array, 1) (or rotate(array, -4)), array will comprise [s, t, a, n, k].
 *
 * @param {!Array.<T>} array The array to rotate.
 * @param {number} n The amount to rotate.
 * @return {!Array.<T>} The array.
 * @template T
 */
goog.array.rotate = function (array, n) {
    goog.asserts.assert(array.length != null);

    if (array.length) {
        n %= array.length;
        if (n > 0) {
            goog.array.ARRAY_PROTOTYPE_.unshift.apply(array, array.splice(-n, n));
        } else if (n < 0) {
            goog.array.ARRAY_PROTOTYPE_.push.apply(array, array.splice(0, -n));
        }
    }
    return array;
};


/**
 * Moves one item of an array to a new position keeping the order of the rest
 * of the items. Example use case: keeping a list of JavaScript objects
 * synchronized with the corresponding list of DOM elements after one of the
 * elements has been dragged to a new position.
 * @param {!(Array|Arguments|{length:number})} arr The array to modify.
 * @param {number} fromIndex Index of the item to move between 0 and
 *     {@code arr.length - 1}.
 * @param {number} toIndex Target index between 0 and {@code arr.length - 1}.
 */
goog.array.moveItem = function (arr, fromIndex, toIndex) {
    goog.asserts.assert(fromIndex >= 0 && fromIndex < arr.length);
    goog.asserts.assert(toIndex >= 0 && toIndex < arr.length);
    // Remove 1 item at fromIndex.
    var removedItems = goog.array.ARRAY_PROTOTYPE_.splice.call(arr, fromIndex, 1);
    // Insert the removed item at toIndex.
    goog.array.ARRAY_PROTOTYPE_.splice.call(arr, toIndex, 0, removedItems[0]);
    // We don't use goog.array.insertAt and goog.array.removeAt, because they're
    // significantly slower than splice.
};


/**
 * Creates a new array for which the element at position i is an array of the
 * ith element of the provided arrays.  The returned array will only be as long
 * as the shortest array provided; additional values are ignored.  For example,
 * the result of zipping [1, 2] and [3, 4, 5] is [[1,3], [2, 4]].
 *
 * This is similar to the zip() function in Python.  See {@link
 * http://docs.python.org/library/functions.html#zip}
 *
 * @param {...!goog.array.ArrayLike} var_args Arrays to be combined.
 * @return {!Array.<!Array>} A new array of arrays created from provided arrays.
 */
goog.array.zip = function (var_args) {
    if (!arguments.length) {
        return [];
    }
    var result = [];
    for (var i = 0; true; i++) {
        var value = [];
        for (var j = 0; j < arguments.length; j++) {
            var arr = arguments[j];
            // If i is larger than the array length, this is the shortest array.
            if (i >= arr.length) {
                return result;
            }
            value.push(arr[i]);
        }
        result.push(value);
    }
};


/**
 * Shuffles the values in the specified array using the Fisher-Yates in-place
 * shuffle (also known as the Knuth Shuffle). By default, calls Math.random()
 * and so resets the state of that random number generator. Similarly, may reset
 * the state of the any other specified random number generator.
 *
 * Runtime: O(n)
 *
 * @param {!Array} arr The array to be shuffled.
 * @param {function():number=} opt_randFn Optional random function to use for
 *     shuffling.
 *     Takes no arguments, and returns a random number on the interval [0, 1).
 *     Defaults to Math.random() using JavaScript's built-in Math library.
 */
goog.array.shuffle = function (arr, opt_randFn) {
    var randFn = opt_randFn || Math.random;

    for (var i = arr.length - 1; i > 0; i--) {
        // Choose a random array index in [0, i] (inclusive with i).
        var j = Math.floor(randFn() * (i + 1));

        var tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
};

// Input 11
// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Browser capability checks for the dom package.
 *
 */


goog.provide('goog.dom.BrowserFeature');

goog.require('goog.userAgent');


/**
 * Enum of browser capabilities.
 * @enum {boolean}
 */
goog.dom.BrowserFeature = {
    /**
     * Whether attributes 'name' and 'type' can be added to an element after it's
     * created. False in Internet Explorer prior to version 9.
     */
    CAN_ADD_NAME_OR_TYPE_ATTRIBUTES: !goog.userAgent.IE ||
        goog.userAgent.isDocumentModeOrHigher(9),

    /**
     * Whether we can use element.children to access an element's Element
     * children. Available since Gecko 1.9.1, IE 9. (IE<9 also includes comment
     * nodes in the collection.)
     */
    CAN_USE_CHILDREN_ATTRIBUTE: !goog.userAgent.GECKO && !goog.userAgent.IE ||
        goog.userAgent.IE && goog.userAgent.isDocumentModeOrHigher(9) ||
        goog.userAgent.GECKO && goog.userAgent.isVersionOrHigher('1.9.1'),

    /**
     * Opera, Safari 3, and Internet Explorer 9 all support innerText but they
     * include text nodes in script and style tags. Not document-mode-dependent.
     */
    CAN_USE_INNER_TEXT: (
        goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('9')),

    /**
     * MSIE, Opera, and Safari>=4 support element.parentElement to access an
     * element's parent if it is an Element.
     */
    CAN_USE_PARENT_ELEMENT_PROPERTY: goog.userAgent.IE || goog.userAgent.OPERA ||
        goog.userAgent.WEBKIT,

    /**
     * Whether NoScope elements need a scoped element written before them in
     * innerHTML.
     * MSDN: http://msdn.microsoft.com/en-us/library/ms533897(VS.85).aspx#1
     */
    INNER_HTML_NEEDS_SCOPED_ELEMENT: goog.userAgent.IE
};

// Input 12
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Defines the goog.dom.TagName enum.  This enumerates
 * all HTML tag names specified in either the the W3C HTML 4.01 index of
 * elements or the HTML5 draft specification.
 *
 * References:
 * http://www.w3.org/TR/html401/index/elements.html
 * http://dev.w3.org/html5/spec/section-index.html
 *
 */
goog.provide('goog.dom.TagName');


/**
 * Enum of all html tag names specified by the W3C HTML4.01 and HTML5
 * specifications.
 * @enum {string}
 */
goog.dom.TagName = {
    A: 'A',
    ABBR: 'ABBR',
    ACRONYM: 'ACRONYM',
    ADDRESS: 'ADDRESS',
    APPLET: 'APPLET',
    AREA: 'AREA',
    ARTICLE: 'ARTICLE',
    ASIDE: 'ASIDE',
    AUDIO: 'AUDIO',
    B: 'B',
    BASE: 'BASE',
    BASEFONT: 'BASEFONT',
    BDI: 'BDI',
    BDO: 'BDO',
    BIG: 'BIG',
    BLOCKQUOTE: 'BLOCKQUOTE',
    BODY: 'BODY',
    BR: 'BR',
    BUTTON: 'BUTTON',
    CANVAS: 'CANVAS',
    CAPTION: 'CAPTION',
    CENTER: 'CENTER',
    CITE: 'CITE',
    CODE: 'CODE',
    COL: 'COL',
    COLGROUP: 'COLGROUP',
    COMMAND: 'COMMAND',
    DATA: 'DATA',
    DATALIST: 'DATALIST',
    DD: 'DD',
    DEL: 'DEL',
    DETAILS: 'DETAILS',
    DFN: 'DFN',
    DIALOG: 'DIALOG',
    DIR: 'DIR',
    DIV: 'DIV',
    DL: 'DL',
    DT: 'DT',
    EM: 'EM',
    EMBED: 'EMBED',
    FIELDSET: 'FIELDSET',
    FIGCAPTION: 'FIGCAPTION',
    FIGURE: 'FIGURE',
    FONT: 'FONT',
    FOOTER: 'FOOTER',
    FORM: 'FORM',
    FRAME: 'FRAME',
    FRAMESET: 'FRAMESET',
    H1: 'H1',
    H2: 'H2',
    H3: 'H3',
    H4: 'H4',
    H5: 'H5',
    H6: 'H6',
    HEAD: 'HEAD',
    HEADER: 'HEADER',
    HGROUP: 'HGROUP',
    HR: 'HR',
    HTML: 'HTML',
    I: 'I',
    IFRAME: 'IFRAME',
    IMG: 'IMG',
    INPUT: 'INPUT',
    INS: 'INS',
    ISINDEX: 'ISINDEX',
    KBD: 'KBD',
    KEYGEN: 'KEYGEN',
    LABEL: 'LABEL',
    LEGEND: 'LEGEND',
    LI: 'LI',
    LINK: 'LINK',
    MAP: 'MAP',
    MARK: 'MARK',
    MATH: 'MATH',
    MENU: 'MENU',
    META: 'META',
    METER: 'METER',
    NAV: 'NAV',
    NOFRAMES: 'NOFRAMES',
    NOSCRIPT: 'NOSCRIPT',
    OBJECT: 'OBJECT',
    OL: 'OL',
    OPTGROUP: 'OPTGROUP',
    OPTION: 'OPTION',
    OUTPUT: 'OUTPUT',
    P: 'P',
    PARAM: 'PARAM',
    PRE: 'PRE',
    PROGRESS: 'PROGRESS',
    Q: 'Q',
    RP: 'RP',
    RT: 'RT',
    RUBY: 'RUBY',
    S: 'S',
    SAMP: 'SAMP',
    SCRIPT: 'SCRIPT',
    SECTION: 'SECTION',
    SELECT: 'SELECT',
    SMALL: 'SMALL',
    SOURCE: 'SOURCE',
    SPAN: 'SPAN',
    STRIKE: 'STRIKE',
    STRONG: 'STRONG',
    STYLE: 'STYLE',
    SUB: 'SUB',
    SUMMARY: 'SUMMARY',
    SUP: 'SUP',
    SVG: 'SVG',
    TABLE: 'TABLE',
    TBODY: 'TBODY',
    TD: 'TD',
    TEXTAREA: 'TEXTAREA',
    TFOOT: 'TFOOT',
    TH: 'TH',
    THEAD: 'THEAD',
    TIME: 'TIME',
    TITLE: 'TITLE',
    TR: 'TR',
    TRACK: 'TRACK',
    TT: 'TT',
    U: 'U',
    UL: 'UL',
    VAR: 'VAR',
    VIDEO: 'VIDEO',
    WBR: 'WBR'
};

// Input 13
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for adding, removing and setting classes.  Prefer
 * {@link goog.dom.classlist} over these utilities since goog.dom.classlist
 * conforms closer to the semantics of Element.classList, is faster (uses
 * native methods rather than parsing strings on every call) and compiles
 * to smaller code as a result.
 *
 * Note: these utilities are meant to operate on HTMLElements and
 * will not work on elements with differing interfaces (such as SVGElements).
 *
 */


goog.provide('goog.dom.classes');

goog.require('goog.array');


/**
 * Sets the entire class name of an element.
 * @param {Node} element DOM node to set class of.
 * @param {string} className Class name(s) to apply to element.
 */
goog.dom.classes.set = function (element, className) {
    element.className = className;
};


/**
 * Gets an array of class names on an element
 * @param {Node} element DOM node to get class of.
 * @return {!Array} Class names on {@code element}. Some browsers add extra
 *     properties to the array. Do not depend on any of these!
 */
goog.dom.classes.get = function (element) {
    var className = element.className;
    // Some types of elements don't have a className in IE (e.g. iframes).
    // Furthermore, in Firefox, className is not a string when the element is
    // an SVG element.
    return goog.isString(className) && className.match(/\S+/g) || [];
};


/**
 * Adds a class or classes to an element. Does not add multiples of class names.
 * @param {Node} element DOM node to add class to.
 * @param {...string} var_args Class names to add.
 * @return {boolean} Whether class was added (or all classes were added).
 */
goog.dom.classes.add = function (element, var_args) {
    var classes = goog.dom.classes.get(element);
    var args = goog.array.slice(arguments, 1);
    var expectedCount = classes.length + args.length;
    goog.dom.classes.add_(classes, args);
    goog.dom.classes.set(element, classes.join(' '));
    return classes.length == expectedCount;
};


/**
 * Removes a class or classes from an element.
 * @param {Node} element DOM node to remove class from.
 * @param {...string} var_args Class name(s) to remove.
 * @return {boolean} Whether all classes in {@code var_args} were found and
 *     removed.
 */
goog.dom.classes.remove = function (element, var_args) {
    var classes = goog.dom.classes.get(element);
    var args = goog.array.slice(arguments, 1);
    var newClasses = goog.dom.classes.getDifference_(classes, args);
    goog.dom.classes.set(element, newClasses.join(' '));
    return newClasses.length == classes.length - args.length;
};


/**
 * Helper method for {@link goog.dom.classes.add} and
 * {@link goog.dom.classes.addRemove}. Adds one or more classes to the supplied
 * classes array.
 * @param {Array.<string>} classes All class names for the element, will be
 *     updated to have the classes supplied in {@code args} added.
 * @param {Array.<string>} args Class names to add.
 * @private
 */
goog.dom.classes.add_ = function (classes, args) {
    for (var i = 0; i < args.length; i++) {
        if (!goog.array.contains(classes, args[i])) {
            classes.push(args[i]);
        }
    }
};


/**
 * Helper method for {@link goog.dom.classes.remove} and
 * {@link goog.dom.classes.addRemove}. Calculates the difference of two arrays.
 * @param {!Array.<string>} arr1 First array.
 * @param {!Array.<string>} arr2 Second array.
 * @return {!Array.<string>} The first array without the elements of the second
 *     array.
 * @private
 */
goog.dom.classes.getDifference_ = function (arr1, arr2) {
    return goog.array.filter(arr1, function (item) {
        return !goog.array.contains(arr2, item);
    });
};


/**
 * Switches a class on an element from one to another without disturbing other
 * classes. If the fromClass isn't removed, the toClass won't be added.
 * @param {Node} element DOM node to swap classes on.
 * @param {string} fromClass Class to remove.
 * @param {string} toClass Class to add.
 * @return {boolean} Whether classes were switched.
 */
goog.dom.classes.swap = function (element, fromClass, toClass) {
    var classes = goog.dom.classes.get(element);

    var removed = false;
    for (var i = 0; i < classes.length; i++) {
        if (classes[i] == fromClass) {
            goog.array.splice(classes, i--, 1);
            removed = true;
        }
    }

    if (removed) {
        classes.push(toClass);
        goog.dom.classes.set(element, classes.join(' '));
    }

    return removed;
};


/**
 * Adds zero or more classes to an element and removes zero or more as a single
 * operation. Unlike calling {@link goog.dom.classes.add} and
 * {@link goog.dom.classes.remove} separately, this is more efficient as it only
 * parses the class property once.
 *
 * If a class is in both the remove and add lists, it will be added. Thus,
 * you can use this instead of {@link goog.dom.classes.swap} when you have
 * more than two class names that you want to swap.
 *
 * @param {Node} element DOM node to swap classes on.
 * @param {?(string|Array.<string>)} classesToRemove Class or classes to
 *     remove, if null no classes are removed.
 * @param {?(string|Array.<string>)} classesToAdd Class or classes to add, if
 *     null no classes are added.
 */
goog.dom.classes.addRemove = function (element, classesToRemove, classesToAdd) {
    var classes = goog.dom.classes.get(element);
    if (goog.isString(classesToRemove)) {
        goog.array.remove(classes, classesToRemove);
    } else if (goog.isArray(classesToRemove)) {
        classes = goog.dom.classes.getDifference_(classes, classesToRemove);
    }

    if (goog.isString(classesToAdd) && !goog.array.contains(classes, classesToAdd)) {
        classes.push(classesToAdd);
    } else if (goog.isArray(classesToAdd)) {
        goog.dom.classes.add_(classes, classesToAdd);
    }

    goog.dom.classes.set(element, classes.join(' '));
};


/**
 * Returns true if an element has a class.
 * @param {Node} element DOM node to test.
 * @param {string} className Class name to test for.
 * @return {boolean} Whether element has the class.
 */
goog.dom.classes.has = function (element, className) {
    return goog.array.contains(goog.dom.classes.get(element), className);
};


/**
 * Adds or removes a class depending on the enabled argument.
 * @param {Node} element DOM node to add or remove the class on.
 * @param {string} className Class name to add or remove.
 * @param {boolean} enabled Whether to add or remove the class (true adds,
 *     false removes).
 */
goog.dom.classes.enable = function (element, className, enabled) {
    if (enabled) {
        goog.dom.classes.add(element, className);
    } else {
        goog.dom.classes.remove(element, className);
    }
};


/**
 * Removes a class if an element has it, and adds it the element doesn't have
 * it.  Won't affect other classes on the node.
 * @param {Node} element DOM node to toggle class on.
 * @param {string} className Class to toggle.
 * @return {boolean} True if class was added, false if it was removed
 *     (in other words, whether element has the class after this function has
 *     been called).
 */
goog.dom.classes.toggle = function (element, className) {
    var add = !goog.dom.classes.has(element, className);
    goog.dom.classes.enable(element, className, add);
    return add;
};

// Input 14
// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for creating functions. Loosely inspired by the
 * java classes: http://go/functions.java and http://go/predicate.java.
 *
 * @author nicksantos@google.com (Nick Santos)
 */


goog.provide('goog.functions');


/**
 * Creates a function that always returns the same value.
 * @param {T} retValue The value to return.
 * @return {function():T} The new function.
 * @template T
 */
goog.functions.constant = function (retValue) {
    return function () {
        return retValue;
    };
};


/**
 * Always returns false.
 * @type {function(...): boolean}
 */
goog.functions.FALSE = goog.functions.constant(false);


/**
 * Always returns true.
 * @type {function(...): boolean}
 */
goog.functions.TRUE = goog.functions.constant(true);


/**
 * Always returns NULL.
 * @type {function(...): null}
 */
goog.functions.NULL = goog.functions.constant(null);


/**
 * A simple function that returns the first argument of whatever is passed
 * into it.
 * @param {T=} opt_returnValue The single value that will be returned.
 * @param {...*} var_args Optional trailing arguments. These are ignored.
 * @return {T} The first argument passed in, or undefined if nothing was passed.
 * @template T
 */
goog.functions.identity = function (opt_returnValue, var_args) {
    return opt_returnValue;
};


/**
 * Creates a function that always throws an error with the given message.
 * @param {string} message The error message.
 * @return {!Function} The error-throwing function.
 */
goog.functions.error = function (message) {
    return function () {
        throw Error(message);
    };
};


/**
 * Creates a function that throws the given object.
 * @param {*} err An object to be thrown.
 * @return {!Function} The error-throwing function.
 */
goog.functions.fail = function (err) {
    return function () {
        throw err;
    }
};


/**
 * Given a function, create a function that keeps opt_numArgs arguments and
 * silently discards all additional arguments.
 * @param {Function} f The original function.
 * @param {number=} opt_numArgs The number of arguments to keep. Defaults to 0.
 * @return {!Function} A version of f that only keeps the first opt_numArgs
 *     arguments.
 */
goog.functions.lock = function (f, opt_numArgs) {
    opt_numArgs = opt_numArgs || 0;
    return function () {
        return f.apply(this, Array.prototype.slice.call(arguments, 0, opt_numArgs));
    };
};


/**
 * Creates a function that returns its nth argument.
 * @param {number} n The position of the return argument.
 * @return {!Function} A new function.
 */
goog.functions.nth = function (n) {
    return function () {
        return arguments[n];
    };
};


/**
 * Given a function, create a new function that swallows its return value
 * and replaces it with a new one.
 * @param {Function} f A function.
 * @param {T} retValue A new return value.
 * @return {function(...[?]):T} A new function.
 * @template T
 */
goog.functions.withReturnValue = function (f, retValue) {
    return goog.functions.sequence(f, goog.functions.constant(retValue));
};


/**
 * Creates the composition of the functions passed in.
 * For example, (goog.functions.compose(f, g))(a) is equivalent to f(g(a)).
 * @param {function(...[?]):T} fn The final function.
 * @param {...Function} var_args A list of functions.
 * @return {function(...[?]):T} The composition of all inputs.
 * @template T
 */
goog.functions.compose = function (fn, var_args) {
    var functions = arguments;
    var length = functions.length;
    return function () {
        var result;
        if (length) {
            result = functions[length - 1].apply(this, arguments);
        }

        for (var i = length - 2; i >= 0; i--) {
            result = functions[i].call(this, result);
        }
        return result;
    };
};


/**
 * Creates a function that calls the functions passed in in sequence, and
 * returns the value of the last function. For example,
 * (goog.functions.sequence(f, g))(x) is equivalent to f(x),g(x).
 * @param {...Function} var_args A list of functions.
 * @return {!Function} A function that calls all inputs in sequence.
 */
goog.functions.sequence = function (var_args) {
    var functions = arguments;
    var length = functions.length;
    return function () {
        var result;
        for (var i = 0; i < length; i++) {
            result = functions[i].apply(this, arguments);
        }
        return result;
    };
};


/**
 * Creates a function that returns true if each of its components evaluates
 * to true. The components are evaluated in order, and the evaluation will be
 * short-circuited as soon as a function returns false.
 * For example, (goog.functions.and(f, g))(x) is equivalent to f(x) && g(x).
 * @param {...Function} var_args A list of functions.
 * @return {function(...[?]):boolean} A function that ANDs its component
 *      functions.
 */
goog.functions.and = function (var_args) {
    var functions = arguments;
    var length = functions.length;
    return function () {
        for (var i = 0; i < length; i++) {
            if (!functions[i].apply(this, arguments)) {
                return false;
            }
        }
        return true;
    };
};


/**
 * Creates a function that returns true if any of its components evaluates
 * to true. The components are evaluated in order, and the evaluation will be
 * short-circuited as soon as a function returns true.
 * For example, (goog.functions.or(f, g))(x) is equivalent to f(x) || g(x).
 * @param {...Function} var_args A list of functions.
 * @return {function(...[?]):boolean} A function that ORs its component
 *    functions.
 */
goog.functions.or = function (var_args) {
    var functions = arguments;
    var length = functions.length;
    return function () {
        for (var i = 0; i < length; i++) {
            if (functions[i].apply(this, arguments)) {
                return true;
            }
        }
        return false;
    };
};


/**
 * Creates a function that returns the Boolean opposite of a provided function.
 * For example, (goog.functions.not(f))(x) is equivalent to !f(x).
 * @param {!Function} f The original function.
 * @return {function(...[?]):boolean} A function that delegates to f and returns
 * opposite.
 */
goog.functions.not = function (f) {
    return function () {
        return !f.apply(this, arguments);
    };
};


/**
 * Generic factory function to construct an object given the constructor
 * and the arguments. Intended to be bound to create object factories.
 *
 * Callers should cast the result to the appropriate type for proper type
 * checking by the compiler.
 * @param {!Function} constructor The constructor for the Object.
 * @param {...*} var_args The arguments to be passed to the constructor.
 * @return {!Object} A new instance of the class given in {@code constructor}.
 */
goog.functions.create = function (constructor, var_args) {
    /** @constructor */
    var temp = function () {
    };
    temp.prototype = constructor.prototype;

    // obj will have constructor's prototype in its chain and
    // 'obj instanceof constructor' will be true.
    var obj = new temp();

    // obj is initialized by constructor.
    // arguments is only array-like so lacks shift(), but can be used with
    // the Array prototype function.
    constructor.apply(obj, Array.prototype.slice.call(arguments, 1));
    return obj;
};


/**
 * @define {boolean} Whether the return value cache should be used.
 *    This should only be used to disable caches when testing.
 */
goog.define('goog.functions.CACHE_RETURN_VALUE', true);


/**
 * Gives a wrapper function that caches the return value of a parameterless
 * function when first called.
 *
 * When called for the first time, the given function is called and its
 * return value is cached (thus this is only appropriate for idempotent
 * functions).  Subsequent calls will return the cached return value. This
 * allows the evaluation of expensive functions to be delayed until first used.
 *
 * To cache the return values of functions with parameters, see goog.memoize.
 *
 * @param {!function():T} fn A function to lazily evaluate.
 * @return {!function():T} A wrapped version the function.
 * @template T
 */
goog.functions.cacheReturnValue = function (fn) {
    var called = false;
    var value;

    return function () {
        if (!goog.functions.CACHE_RETURN_VALUE) {
            return fn();
        }

        if (!called) {
            value = fn();
            called = true;
        }

        return value;
    }
};

// Input 15
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Additional mathematical functions.
 */

goog.provide('goog.math');

goog.require('goog.array');
goog.require('goog.asserts');


/**
 * Returns a random integer greater than or equal to 0 and less than {@code a}.
 * @param {number} a  The upper bound for the random integer (exclusive).
 * @return {number} A random integer N such that 0 <= N < a.
 */
goog.math.randomInt = function (a) {
    return Math.floor(Math.random() * a);
};


/**
 * Returns a random number greater than or equal to {@code a} and less than
 * {@code b}.
 * @param {number} a  The lower bound for the random number (inclusive).
 * @param {number} b  The upper bound for the random number (exclusive).
 * @return {number} A random number N such that a <= N < b.
 */
goog.math.uniformRandom = function (a, b) {
    return a + Math.random() * (b - a);
};


/**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */
goog.math.clamp = function (value, min, max) {
    return Math.min(Math.max(value, min), max);
};


/**
 * The % operator in JavaScript returns the remainder of a / b, but differs from
 * some other languages in that the result will have the same sign as the
 * dividend. For example, -1 % 8 == -1, whereas in some other languages
 * (such as Python) the result would be 7. This function emulates the more
 * correct modulo behavior, which is useful for certain applications such as
 * calculating an offset index in a circular list.
 *
 * @param {number} a The dividend.
 * @param {number} b The divisor.
 * @return {number} a % b where the result is between 0 and b (either 0 <= x < b
 *     or b < x <= 0, depending on the sign of b).
 */
goog.math.modulo = function (a, b) {
    var r = a % b;
    // If r and b differ in sign, add b to wrap the result to the correct sign.
    return (r * b < 0) ? r + b : r;
};


/**
 * Performs linear interpolation between values a and b. Returns the value
 * between a and b proportional to x (when x is between 0 and 1. When x is
 * outside this range, the return value is a linear extrapolation).
 * @param {number} a A number.
 * @param {number} b A number.
 * @param {number} x The proportion between a and b.
 * @return {number} The interpolated value between a and b.
 */
goog.math.lerp = function (a, b, x) {
    return a + x * (b - a);
};


/**
 * Tests whether the two values are equal to each other, within a certain
 * tolerance to adjust for floating point errors.
 * @param {number} a A number.
 * @param {number} b A number.
 * @param {number=} opt_tolerance Optional tolerance range. Defaults
 *     to 0.000001. If specified, should be greater than 0.
 * @return {boolean} Whether {@code a} and {@code b} are nearly equal.
 */
goog.math.nearlyEquals = function (a, b, opt_tolerance) {
    return Math.abs(a - b) <= (opt_tolerance || 0.000001);
};


/**
 * Standardizes an angle to be in range [0-360). Negative angles become
 * positive, and values greater than 360 are returned modulo 360.
 * @param {number} angle Angle in degrees.
 * @return {number} Standardized angle.
 */
goog.math.standardAngle = function (angle) {
    return goog.math.modulo(angle, 360);
};


/**
 * Converts degrees to radians.
 * @param {number} angleDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */
goog.math.toRadians = function (angleDegrees) {
    return angleDegrees * Math.PI / 180;
};


/**
 * Converts radians to degrees.
 * @param {number} angleRadians Angle in radians.
 * @return {number} Angle in degrees.
 */
goog.math.toDegrees = function (angleRadians) {
    return angleRadians * 180 / Math.PI;
};


/**
 * For a given angle and radius, finds the X portion of the offset.
 * @param {number} degrees Angle in degrees (zero points in +X direction).
 * @param {number} radius Radius.
 * @return {number} The x-distance for the angle and radius.
 */
goog.math.angleDx = function (degrees, radius) {
    return radius * Math.cos(goog.math.toRadians(degrees));
};


/**
 * For a given angle and radius, finds the Y portion of the offset.
 * @param {number} degrees Angle in degrees (zero points in +X direction).
 * @param {number} radius Radius.
 * @return {number} The y-distance for the angle and radius.
 */
goog.math.angleDy = function (degrees, radius) {
    return radius * Math.sin(goog.math.toRadians(degrees));
};


/**
 * Computes the angle between two points (x1,y1) and (x2,y2).
 * Angle zero points in the +X direction, 90 degrees points in the +Y
 * direction (down) and from there we grow clockwise towards 360 degrees.
 * @param {number} x1 x of first point.
 * @param {number} y1 y of first point.
 * @param {number} x2 x of second point.
 * @param {number} y2 y of second point.
 * @return {number} Standardized angle in degrees of the vector from
 *     x1,y1 to x2,y2.
 */
goog.math.angle = function (x1, y1, x2, y2) {
    return goog.math.standardAngle(goog.math.toDegrees(Math.atan2(y2 - y1,
        x2 - x1)));
};


/**
 * Computes the difference between startAngle and endAngle (angles in degrees).
 * @param {number} startAngle  Start angle in degrees.
 * @param {number} endAngle  End angle in degrees.
 * @return {number} The number of degrees that when added to
 *     startAngle will result in endAngle. Positive numbers mean that the
 *     direction is clockwise. Negative numbers indicate a counter-clockwise
 *     direction.
 *     The shortest route (clockwise vs counter-clockwise) between the angles
 *     is used.
 *     When the difference is 180 degrees, the function returns 180 (not -180)
 *     angleDifference(30, 40) is 10, and angleDifference(40, 30) is -10.
 *     angleDifference(350, 10) is 20, and angleDifference(10, 350) is -20.
 */
goog.math.angleDifference = function (startAngle, endAngle) {
    var d = goog.math.standardAngle(endAngle) -
        goog.math.standardAngle(startAngle);
    if (d > 180) {
        d = d - 360;
    } else if (d <= -180) {
        d = 360 + d;
    }
    return d;
};


/**
 * Returns the sign of a number as per the "sign" or "signum" function.
 * @param {number} x The number to take the sign of.
 * @return {number} -1 when negative, 1 when positive, 0 when 0.
 */
goog.math.sign = function (x) {
    return x == 0 ? 0 : (x < 0 ? -1 : 1);
};


/**
 * JavaScript implementation of Longest Common Subsequence problem.
 * http://en.wikipedia.org/wiki/Longest_common_subsequence
 *
 * Returns the longest possible array that is subarray of both of given arrays.
 *
 * @param {Array.<Object>} array1 First array of objects.
 * @param {Array.<Object>} array2 Second array of objects.
 * @param {Function=} opt_compareFn Function that acts as a custom comparator
 *     for the array ojects. Function should return true if objects are equal,
 *     otherwise false.
 * @param {Function=} opt_collectorFn Function used to decide what to return
 *     as a result subsequence. It accepts 2 arguments: index of common element
 *     in the first array and index in the second. The default function returns
 *     element from the first array.
 * @return {Array.<Object>} A list of objects that are common to both arrays
 *     such that there is no common subsequence with size greater than the
 *     length of the list.
 */
goog.math.longestCommonSubsequence = function (array1, array2, opt_compareFn, opt_collectorFn) {

    var compare = opt_compareFn || function (a, b) {
        return a == b;
    };

    var collect = opt_collectorFn || function (i1, i2) {
        return array1[i1];
    };

    var length1 = array1.length;
    var length2 = array2.length;

    var arr = [];
    for (var i = 0; i < length1 + 1; i++) {
        arr[i] = [];
        arr[i][0] = 0;
    }

    for (var j = 0; j < length2 + 1; j++) {
        arr[0][j] = 0;
    }

    for (i = 1; i <= length1; i++) {
        for (j = 1; j <= length2; j++) {
            if (compare(array1[i - 1], array2[j - 1])) {
                arr[i][j] = arr[i - 1][j - 1] + 1;
            } else {
                arr[i][j] = Math.max(arr[i - 1][j], arr[i][j - 1]);
            }
        }
    }

    // Backtracking
    var result = [];
    var i = length1, j = length2;
    while (i > 0 && j > 0) {
        if (compare(array1[i - 1], array2[j - 1])) {
            result.unshift(collect(i - 1, j - 1));
            i--;
            j--;
        } else {
            if (arr[i - 1][j] > arr[i][j - 1]) {
                i--;
            } else {
                j--;
            }
        }
    }

    return result;
};


/**
 * Returns the sum of the arguments.
 * @param {...number} var_args Numbers to add.
 * @return {number} The sum of the arguments (0 if no arguments were provided,
 *     {@code NaN} if any of the arguments is not a valid number).
 */
goog.math.sum = function (var_args) {
    return /** @type {number} */ (goog.array.reduce(arguments,
        function (sum, value) {
            return sum + value;
        }, 0));
};


/**
 * Returns the arithmetic mean of the arguments.
 * @param {...number} var_args Numbers to average.
 * @return {number} The average of the arguments ({@code NaN} if no arguments
 *     were provided or any of the arguments is not a valid number).
 */
goog.math.average = function (var_args) {
    return goog.math.sum.apply(null, arguments) / arguments.length;
};


/**
 * Returns the sample standard deviation of the arguments.  For a definition of
 * sample standard deviation, see e.g.
 * http://en.wikipedia.org/wiki/Standard_deviation
 * @param {...number} var_args Number samples to analyze.
 * @return {number} The sample standard deviation of the arguments (0 if fewer
 *     than two samples were provided, or {@code NaN} if any of the samples is
 *     not a valid number).
 */
goog.math.standardDeviation = function (var_args) {
    var sampleSize = arguments.length;
    if (sampleSize < 2) {
        return 0;
    }

    var mean = goog.math.average.apply(null, arguments);
    var variance = goog.math.sum.apply(null, goog.array.map(arguments,
        function (val) {
            return Math.pow(val - mean, 2);
        })) / (sampleSize - 1);

    return Math.sqrt(variance);
};


/**
 * Returns whether the supplied number represents an integer, i.e. that is has
 * no fractional component.  No range-checking is performed on the number.
 * @param {number} num The number to test.
 * @return {boolean} Whether {@code num} is an integer.
 */
goog.math.isInt = function (num) {
    return isFinite(num) && num % 1 == 0;
};


/**
 * Returns whether the supplied number is finite and not NaN.
 * @param {number} num The number to test.
 * @return {boolean} Whether {@code num} is a finite number.
 */
goog.math.isFiniteNumber = function (num) {
    return isFinite(num) && !isNaN(num);
};


/**
 * A tweaked variant of {@code Math.floor} which tolerates if the passed number
 * is infinitesimally smaller than the closest integer. It often happens with
 * the results of floating point calculations because of the finite precision
 * of the intermediate results. For example {@code Math.floor(Math.log(1000) /
 * Math.LN10) == 2}, not 3 as one would expect.
 * @param {number} num A number.
 * @param {number=} opt_epsilon An infinitesimally small positive number, the
 *     rounding error to tolerate.
 * @return {number} The largest integer less than or equal to {@code num}.
 */
goog.math.safeFloor = function (num, opt_epsilon) {
    goog.asserts.assert(!goog.isDef(opt_epsilon) || opt_epsilon > 0);
    return Math.floor(num + (opt_epsilon || 2e-15));
};


/**
 * A tweaked variant of {@code Math.ceil}. See {@code goog.math.safeFloor} for
 * details.
 * @param {number} num A number.
 * @param {number=} opt_epsilon An infinitesimally small positive number, the
 *     rounding error to tolerate.
 * @return {number} The smallest integer greater than or equal to {@code num}.
 */
goog.math.safeCeil = function (num, opt_epsilon) {
    goog.asserts.assert(!goog.isDef(opt_epsilon) || opt_epsilon > 0);
    return Math.ceil(num - (opt_epsilon || 2e-15));
};

// Input 16
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A utility class for representing two-dimensional positions.
 */


goog.provide('goog.math.Coordinate');

goog.require('goog.math');


/**
 * Class for representing coordinates and positions.
 * @param {number=} opt_x Left, defaults to 0.
 * @param {number=} opt_y Top, defaults to 0.
 * @constructor
 */
goog.math.Coordinate = function (opt_x, opt_y) {
    /**
     * X-value
     * @type {number}
     */
    this.x = goog.isDef(opt_x) ? opt_x : 0;

    /**
     * Y-value
     * @type {number}
     */
    this.y = goog.isDef(opt_y) ? opt_y : 0;
};


/**
 * Returns a new copy of the coordinate.
 * @return {!goog.math.Coordinate} A clone of this coordinate.
 */
goog.math.Coordinate.prototype.clone = function () {
    return new goog.math.Coordinate(this.x, this.y);
};


if (goog.DEBUG) {
    /**
     * Returns a nice string representing the coordinate.
     * @return {string} In the form (50, 73).
     * @override
     */
    goog.math.Coordinate.prototype.toString = function () {
        return '(' + this.x + ', ' + this.y + ')';
    };
}


/**
 * Compares coordinates for equality.
 * @param {goog.math.Coordinate} a A Coordinate.
 * @param {goog.math.Coordinate} b A Coordinate.
 * @return {boolean} True iff the coordinates are equal, or if both are null.
 */
goog.math.Coordinate.equals = function (a, b) {
    if (a == b) {
        return true;
    }
    if (!a || !b) {
        return false;
    }
    return a.x == b.x && a.y == b.y;
};


/**
 * Returns the distance between two coordinates.
 * @param {!goog.math.Coordinate} a A Coordinate.
 * @param {!goog.math.Coordinate} b A Coordinate.
 * @return {number} The distance between {@code a} and {@code b}.
 */
goog.math.Coordinate.distance = function (a, b) {
    var dx = a.x - b.x;
    var dy = a.y - b.y;
    return Math.sqrt(dx * dx + dy * dy);
};


/**
 * Returns the magnitude of a coordinate.
 * @param {!goog.math.Coordinate} a A Coordinate.
 * @return {number} The distance between the origin and {@code a}.
 */
goog.math.Coordinate.magnitude = function (a) {
    return Math.sqrt(a.x * a.x + a.y * a.y);
};


/**
 * Returns the angle from the origin to a coordinate.
 * @param {!goog.math.Coordinate} a A Coordinate.
 * @return {number} The angle, in degrees, clockwise from the positive X
 *     axis to {@code a}.
 */
goog.math.Coordinate.azimuth = function (a) {
    return goog.math.angle(0, 0, a.x, a.y);
};


/**
 * Returns the squared distance between two coordinates. Squared distances can
 * be used for comparisons when the actual value is not required.
 *
 * Performance note: eliminating the square root is an optimization often used
 * in lower-level languages, but the speed difference is not nearly as
 * pronounced in JavaScript (only a few percent.)
 *
 * @param {!goog.math.Coordinate} a A Coordinate.
 * @param {!goog.math.Coordinate} b A Coordinate.
 * @return {number} The squared distance between {@code a} and {@code b}.
 */
goog.math.Coordinate.squaredDistance = function (a, b) {
    var dx = a.x - b.x;
    var dy = a.y - b.y;
    return dx * dx + dy * dy;
};


/**
 * Returns the difference between two coordinates as a new
 * goog.math.Coordinate.
 * @param {!goog.math.Coordinate} a A Coordinate.
 * @param {!goog.math.Coordinate} b A Coordinate.
 * @return {!goog.math.Coordinate} A Coordinate representing the difference
 *     between {@code a} and {@code b}.
 */
goog.math.Coordinate.difference = function (a, b) {
    return new goog.math.Coordinate(a.x - b.x, a.y - b.y);
};


/**
 * Returns the sum of two coordinates as a new goog.math.Coordinate.
 * @param {!goog.math.Coordinate} a A Coordinate.
 * @param {!goog.math.Coordinate} b A Coordinate.
 * @return {!goog.math.Coordinate} A Coordinate representing the sum of the two
 *     coordinates.
 */
goog.math.Coordinate.sum = function (a, b) {
    return new goog.math.Coordinate(a.x + b.x, a.y + b.y);
};


/**
 * Rounds the x and y fields to the next larger integer values.
 * @return {!goog.math.Coordinate} This coordinate with ceil'd fields.
 */
goog.math.Coordinate.prototype.ceil = function () {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
};


/**
 * Rounds the x and y fields to the next smaller integer values.
 * @return {!goog.math.Coordinate} This coordinate with floored fields.
 */
goog.math.Coordinate.prototype.floor = function () {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
};


/**
 * Rounds the x and y fields to the nearest integer values.
 * @return {!goog.math.Coordinate} This coordinate with rounded fields.
 */
goog.math.Coordinate.prototype.round = function () {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
};


/**
 * Translates this box by the given offsets. If a {@code goog.math.Coordinate}
 * is given, then the x and y values are translated by the coordinate's x and y.
 * Otherwise, x and y are translated by {@code tx} and {@code opt_ty}
 * respectively.
 * @param {number|goog.math.Coordinate} tx The value to translate x by or the
 *     the coordinate to translate this coordinate by.
 * @param {number=} opt_ty The value to translate y by.
 * @return {!goog.math.Coordinate} This coordinate after translating.
 */
goog.math.Coordinate.prototype.translate = function (tx, opt_ty) {
    if (tx instanceof goog.math.Coordinate) {
        this.x += tx.x;
        this.y += tx.y;
    } else {
        this.x += tx;
        if (goog.isNumber(opt_ty)) {
            this.y += opt_ty;
        }
    }
    return this;
};


/**
 * Scales this coordinate by the given scale factors. The x and y values are
 * scaled by {@code sx} and {@code opt_sy} respectively.  If {@code opt_sy}
 * is not given, then {@code sx} is used for both x and y.
 * @param {number} sx The scale factor to use for the x dimension.
 * @param {number=} opt_sy The scale factor to use for the y dimension.
 * @return {!goog.math.Coordinate} This coordinate after scaling.
 */
goog.math.Coordinate.prototype.scale = function (sx, opt_sy) {
    var sy = goog.isNumber(opt_sy) ? opt_sy : sx;
    this.x *= sx;
    this.y *= sy;
    return this;
};

// Input 17
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A utility class for representing two-dimensional sizes.
 */


goog.provide('goog.math.Size');


/**
 * Class for representing sizes consisting of a width and height. Undefined
 * width and height support is deprecated and results in compiler warning.
 * @param {number} width Width.
 * @param {number} height Height.
 * @constructor
 */
goog.math.Size = function (width, height) {
    /**
     * Width
     * @type {number}
     */
    this.width = width;

    /**
     * Height
     * @type {number}
     */
    this.height = height;
};


/**
 * Compares sizes for equality.
 * @param {goog.math.Size} a A Size.
 * @param {goog.math.Size} b A Size.
 * @return {boolean} True iff the sizes have equal widths and equal
 *     heights, or if both are null.
 */
goog.math.Size.equals = function (a, b) {
    if (a == b) {
        return true;
    }
    if (!a || !b) {
        return false;
    }
    return a.width == b.width && a.height == b.height;
};


/**
 * @return {!goog.math.Size} A new copy of the Size.
 */
goog.math.Size.prototype.clone = function () {
    return new goog.math.Size(this.width, this.height);
};


if (goog.DEBUG) {
    /**
     * Returns a nice string representing size.
     * @return {string} In the form (50 x 73).
     * @override
     */
    goog.math.Size.prototype.toString = function () {
        return '(' + this.width + ' x ' + this.height + ')';
    };
}


/**
 * @return {number} The longer of the two dimensions in the size.
 */
goog.math.Size.prototype.getLongest = function () {
    return Math.max(this.width, this.height);
};


/**
 * @return {number} The shorter of the two dimensions in the size.
 */
goog.math.Size.prototype.getShortest = function () {
    return Math.min(this.width, this.height);
};


/**
 * @return {number} The area of the size (width * height).
 */
goog.math.Size.prototype.area = function () {
    return this.width * this.height;
};


/**
 * @return {number} The perimeter of the size (width + height) * 2.
 */
goog.math.Size.prototype.perimeter = function () {
    return (this.width + this.height) * 2;
};


/**
 * @return {number} The ratio of the size's width to its height.
 */
goog.math.Size.prototype.aspectRatio = function () {
    return this.width / this.height;
};


/**
 * @return {boolean} True if the size has zero area, false if both dimensions
 *     are non-zero numbers.
 */
goog.math.Size.prototype.isEmpty = function () {
    return !this.area();
};


/**
 * Clamps the width and height parameters upward to integer values.
 * @return {!goog.math.Size} This size with ceil'd components.
 */
goog.math.Size.prototype.ceil = function () {
    this.width = Math.ceil(this.width);
    this.height = Math.ceil(this.height);
    return this;
};


/**
 * @param {!goog.math.Size} target The target size.
 * @return {boolean} True if this Size is the same size or smaller than the
 *     target size in both dimensions.
 */
goog.math.Size.prototype.fitsInside = function (target) {
    return this.width <= target.width && this.height <= target.height;
};


/**
 * Clamps the width and height parameters downward to integer values.
 * @return {!goog.math.Size} This size with floored components.
 */
goog.math.Size.prototype.floor = function () {
    this.width = Math.floor(this.width);
    this.height = Math.floor(this.height);
    return this;
};


/**
 * Rounds the width and height parameters to integer values.
 * @return {!goog.math.Size} This size with rounded components.
 */
goog.math.Size.prototype.round = function () {
    this.width = Math.round(this.width);
    this.height = Math.round(this.height);
    return this;
};


/**
 * Scales this size by the given scale factors. The width and height are scaled
 * by {@code sx} and {@code opt_sy} respectively.  If {@code opt_sy} is not
 * given, then {@code sx} is used for both the width and height.
 * @param {number} sx The scale factor to use for the width.
 * @param {number=} opt_sy The scale factor to use for the height.
 * @return {!goog.math.Size} This Size object after scaling.
 */
goog.math.Size.prototype.scale = function (sx, opt_sy) {
    var sy = goog.isNumber(opt_sy) ? opt_sy : sx;
    this.width *= sx;
    this.height *= sy;
    return this;
};


/**
 * Uniformly scales the size to fit inside the dimensions of a given size. The
 * original aspect ratio will be preserved.
 *
 * This function assumes that both Sizes contain strictly positive dimensions.
 * @param {!goog.math.Size} target The target size.
 * @return {!goog.math.Size} This Size object, after optional scaling.
 */
goog.math.Size.prototype.scaleToFit = function (target) {
    var s = this.aspectRatio() > target.aspectRatio() ?
        target.width / this.width :
        target.height / this.height;

    return this.scale(s);
};

// Input 18
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for manipulating objects/maps/hashes.
 */

goog.provide('goog.object');


/**
 * Calls a function for each element in an object/map/hash.
 *
 * @param {Object.<K,V>} obj The object over which to iterate.
 * @param {function(this:T,V,?,Object.<K,V>):?} f The function to call
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the object) and the return value is ignored.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @template T,K,V
 */
goog.object.forEach = function (obj, f, opt_obj) {
    for (var key in obj) {
        f.call(opt_obj, obj[key], key, obj);
    }
};


/**
 * Calls a function for each element in an object/map/hash. If that call returns
 * true, adds the element to a new object.
 *
 * @param {Object.<K,V>} obj The object over which to iterate.
 * @param {function(this:T,V,?,Object.<K,V>):boolean} f The function to call
 *     for every element. This
 *     function takes 3 arguments (the element, the index and the object)
 *     and should return a boolean. If the return value is true the
 *     element is added to the result object. If it is false the
 *     element is not included.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @return {!Object.<K,V>} a new object in which only elements that passed the
 *     test are present.
 * @template T,K,V
 */
goog.object.filter = function (obj, f, opt_obj) {
    var res = {};
    for (var key in obj) {
        if (f.call(opt_obj, obj[key], key, obj)) {
            res[key] = obj[key];
        }
    }
    return res;
};


/**
 * For every element in an object/map/hash calls a function and inserts the
 * result into a new object.
 *
 * @param {Object.<K,V>} obj The object over which to iterate.
 * @param {function(this:T,V,?,Object.<K,V>):R} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the element, the index and the object)
 *     and should return something. The result will be inserted
 *     into a new object.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @return {!Object.<K,R>} a new object with the results from f.
 * @template T,K,V,R
 */
goog.object.map = function (obj, f, opt_obj) {
    var res = {};
    for (var key in obj) {
        res[key] = f.call(opt_obj, obj[key], key, obj);
    }
    return res;
};


/**
 * Calls a function for each element in an object/map/hash. If any
 * call returns true, returns true (without checking the rest). If
 * all calls return false, returns false.
 *
 * @param {Object.<K,V>} obj The object to check.
 * @param {function(this:T,V,?,Object.<K,V>):boolean} f The function to
 *     call for every element. This function
 *     takes 3 arguments (the element, the index and the object) and should
 *     return a boolean.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @return {boolean} true if any element passes the test.
 * @template T,K,V
 */
goog.object.some = function (obj, f, opt_obj) {
    for (var key in obj) {
        if (f.call(opt_obj, obj[key], key, obj)) {
            return true;
        }
    }
    return false;
};


/**
 * Calls a function for each element in an object/map/hash. If
 * all calls return true, returns true. If any call returns false, returns
 * false at this point and does not continue to check the remaining elements.
 *
 * @param {Object.<K,V>} obj The object to check.
 * @param {?function(this:T,V,?,Object.<K,V>):boolean} f The function to
 *     call for every element. This function
 *     takes 3 arguments (the element, the index and the object) and should
 *     return a boolean.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @return {boolean} false if any element fails the test.
 * @template T,K,V
 */
goog.object.every = function (obj, f, opt_obj) {
    for (var key in obj) {
        if (!f.call(opt_obj, obj[key], key, obj)) {
            return false;
        }
    }
    return true;
};


/**
 * Returns the number of key-value pairs in the object map.
 *
 * @param {Object} obj The object for which to get the number of key-value
 *     pairs.
 * @return {number} The number of key-value pairs in the object map.
 */
goog.object.getCount = function (obj) {
    // JS1.5 has __count__ but it has been deprecated so it raises a warning...
    // in other words do not use. Also __count__ only includes the fields on the
    // actual object and not in the prototype chain.
    var rv = 0;
    for (var key in obj) {
        rv++;
    }
    return rv;
};


/**
 * Returns one key from the object map, if any exists.
 * For map literals the returned key will be the first one in most of the
 * browsers (a know exception is Konqueror).
 *
 * @param {Object} obj The object to pick a key from.
 * @return {string|undefined} The key or undefined if the object is empty.
 */
goog.object.getAnyKey = function (obj) {
    for (var key in obj) {
        return key;
    }
};


/**
 * Returns one value from the object map, if any exists.
 * For map literals the returned value will be the first one in most of the
 * browsers (a know exception is Konqueror).
 *
 * @param {Object.<K,V>} obj The object to pick a value from.
 * @return {V|undefined} The value or undefined if the object is empty.
 * @template K,V
 */
goog.object.getAnyValue = function (obj) {
    for (var key in obj) {
        return obj[key];
    }
};


/**
 * Whether the object/hash/map contains the given object as a value.
 * An alias for goog.object.containsValue(obj, val).
 *
 * @param {Object.<K,V>} obj The object in which to look for val.
 * @param {V} val The object for which to check.
 * @return {boolean} true if val is present.
 * @template K,V
 */
goog.object.contains = function (obj, val) {
    return goog.object.containsValue(obj, val);
};


/**
 * Returns the values of the object/map/hash.
 *
 * @param {Object.<K,V>} obj The object from which to get the values.
 * @return {!Array.<V>} The values in the object/map/hash.
 * @template K,V
 */
goog.object.getValues = function (obj) {
    var res = [];
    var i = 0;
    for (var key in obj) {
        res[i++] = obj[key];
    }
    return res;
};


/**
 * Returns the keys of the object/map/hash.
 *
 * @param {Object} obj The object from which to get the keys.
 * @return {!Array.<string>} Array of property keys.
 */
goog.object.getKeys = function (obj) {
    var res = [];
    var i = 0;
    for (var key in obj) {
        res[i++] = key;
    }
    return res;
};


/**
 * Get a value from an object multiple levels deep.  This is useful for
 * pulling values from deeply nested objects, such as JSON responses.
 * Example usage: getValueByKeys(jsonObj, 'foo', 'entries', 3)
 *
 * @param {!Object} obj An object to get the value from.  Can be array-like.
 * @param {...(string|number|!Array.<number|string>)} var_args A number of keys
 *     (as strings, or numbers, for array-like objects).  Can also be
 *     specified as a single array of keys.
 * @return {*} The resulting value.  If, at any point, the value for a key
 *     is undefined, returns undefined.
 */
goog.object.getValueByKeys = function (obj, var_args) {
    var isArrayLike = goog.isArrayLike(var_args);
    var keys = isArrayLike ? var_args : arguments;

    // Start with the 2nd parameter for the variable parameters syntax.
    for (var i = isArrayLike ? 0 : 1; i < keys.length; i++) {
        obj = obj[keys[i]];
        if (!goog.isDef(obj)) {
            break;
        }
    }

    return obj;
};


/**
 * Whether the object/map/hash contains the given key.
 *
 * @param {Object} obj The object in which to look for key.
 * @param {*} key The key for which to check.
 * @return {boolean} true If the map contains the key.
 */
goog.object.containsKey = function (obj, key) {
    return key in obj;
};


/**
 * Whether the object/map/hash contains the given value. This is O(n).
 *
 * @param {Object.<K,V>} obj The object in which to look for val.
 * @param {V} val The value for which to check.
 * @return {boolean} true If the map contains the value.
 * @template K,V
 */
goog.object.containsValue = function (obj, val) {
    for (var key in obj) {
        if (obj[key] == val) {
            return true;
        }
    }
    return false;
};


/**
 * Searches an object for an element that satisfies the given condition and
 * returns its key.
 * @param {Object.<K,V>} obj The object to search in.
 * @param {function(this:T,V,string,Object.<K,V>):boolean} f The
 *      function to call for every element. Takes 3 arguments (the value,
 *     the key and the object) and should return a boolean.
 * @param {T=} opt_this An optional "this" context for the function.
 * @return {string|undefined} The key of an element for which the function
 *     returns true or undefined if no such element is found.
 * @template T,K,V
 */
goog.object.findKey = function (obj, f, opt_this) {
    for (var key in obj) {
        if (f.call(opt_this, obj[key], key, obj)) {
            return key;
        }
    }
    return undefined;
};


/**
 * Searches an object for an element that satisfies the given condition and
 * returns its value.
 * @param {Object.<K,V>} obj The object to search in.
 * @param {function(this:T,V,string,Object.<K,V>):boolean} f The function
 *     to call for every element. Takes 3 arguments (the value, the key
 *     and the object) and should return a boolean.
 * @param {T=} opt_this An optional "this" context for the function.
 * @return {V} The value of an element for which the function returns true or
 *     undefined if no such element is found.
 * @template T,K,V
 */
goog.object.findValue = function (obj, f, opt_this) {
    var key = goog.object.findKey(obj, f, opt_this);
    return key && obj[key];
};


/**
 * Whether the object/map/hash is empty.
 *
 * @param {Object} obj The object to test.
 * @return {boolean} true if obj is empty.
 */
goog.object.isEmpty = function (obj) {
    for (var key in obj) {
        return false;
    }
    return true;
};


/**
 * Removes all key value pairs from the object/map/hash.
 *
 * @param {Object} obj The object to clear.
 */
goog.object.clear = function (obj) {
    for (var i in obj) {
        delete obj[i];
    }
};


/**
 * Removes a key-value pair based on the key.
 *
 * @param {Object} obj The object from which to remove the key.
 * @param {*} key The key to remove.
 * @return {boolean} Whether an element was removed.
 */
goog.object.remove = function (obj, key) {
    var rv;
    if ((rv = key in obj)) {
        delete obj[key];
    }
    return rv;
};


/**
 * Adds a key-value pair to the object. Throws an exception if the key is
 * already in use. Use set if you want to change an existing pair.
 *
 * @param {Object.<K,V>} obj The object to which to add the key-value pair.
 * @param {string} key The key to add.
 * @param {V} val The value to add.
 * @template K,V
 */
goog.object.add = function (obj, key, val) {
    if (key in obj) {
        throw Error('The object already contains the key "' + key + '"');
    }
    goog.object.set(obj, key, val);
};


/**
 * Returns the value for the given key.
 *
 * @param {Object.<K,V>} obj The object from which to get the value.
 * @param {string} key The key for which to get the value.
 * @param {R=} opt_val The value to return if no item is found for the given
 *     key (default is undefined).
 * @return {V|R|undefined} The value for the given key.
 * @template K,V,R
 */
goog.object.get = function (obj, key, opt_val) {
    if (key in obj) {
        return obj[key];
    }
    return opt_val;
};


/**
 * Adds a key-value pair to the object/map/hash.
 *
 * @param {Object.<K,V>} obj The object to which to add the key-value pair.
 * @param {string} key The key to add.
 * @param {V} value The value to add.
 * @template K,V
 */
goog.object.set = function (obj, key, value) {
    obj[key] = value;
};


/**
 * Adds a key-value pair to the object/map/hash if it doesn't exist yet.
 *
 * @param {Object.<K,V>} obj The object to which to add the key-value pair.
 * @param {string} key The key to add.
 * @param {V} value The value to add if the key wasn't present.
 * @return {V} The value of the entry at the end of the function.
 * @template K,V
 */
goog.object.setIfUndefined = function (obj, key, value) {
    return key in obj ? obj[key] : (obj[key] = value);
};


/**
 * Does a flat clone of the object.
 *
 * @param {Object.<K,V>} obj Object to clone.
 * @return {!Object.<K,V>} Clone of the input object.
 * @template K,V
 */
goog.object.clone = function (obj) {
    // We cannot use the prototype trick because a lot of methods depend on where
    // the actual key is set.

    var res = {};
    for (var key in obj) {
        res[key] = obj[key];
    }
    return res;
    // We could also use goog.mixin but I wanted this to be independent from that.
};


/**
 * Clones a value. The input may be an Object, Array, or basic type. Objects and
 * arrays will be cloned recursively.
 *
 * WARNINGS:
 * <code>goog.object.unsafeClone</code> does not detect reference loops. Objects
 * that refer to themselves will cause infinite recursion.
 *
 * <code>goog.object.unsafeClone</code> is unaware of unique identifiers, and
 * copies UIDs created by <code>getUid</code> into cloned results.
 *
 * @param {*} obj The value to clone.
 * @return {*} A clone of the input value.
 */
goog.object.unsafeClone = function (obj) {
    var type = goog.typeOf(obj);
    if (type == 'object' || type == 'array') {
        if (obj.clone) {
            return obj.clone();
        }
        var clone = type == 'array' ? [] : {};
        for (var key in obj) {
            clone[key] = goog.object.unsafeClone(obj[key]);
        }
        return clone;
    }

    return obj;
};


/**
 * Returns a new object in which all the keys and values are interchanged
 * (keys become values and values become keys). If multiple keys map to the
 * same value, the chosen transposed value is implementation-dependent.
 *
 * @param {Object} obj The object to transpose.
 * @return {!Object} The transposed object.
 */
goog.object.transpose = function (obj) {
    var transposed = {};
    for (var key in obj) {
        transposed[obj[key]] = key;
    }
    return transposed;
};


/**
 * The names of the fields that are defined on Object.prototype.
 * @type {Array.<string>}
 * @private
 */
goog.object.PROTOTYPE_FIELDS_ = [
    'constructor',
    'hasOwnProperty',
    'isPrototypeOf',
    'propertyIsEnumerable',
    'toLocaleString',
    'toString',
    'valueOf'
];


/**
 * Extends an object with another object.
 * This operates 'in-place'; it does not create a new Object.
 *
 * Example:
 * var o = {};
 * goog.object.extend(o, {a: 0, b: 1});
 * o; // {a: 0, b: 1}
 * goog.object.extend(o, {c: 2});
 * o; // {a: 0, b: 1, c: 2}
 *
 * @param {Object} target  The object to modify.
 * @param {...Object} var_args The objects from which values will be copied.
 */
goog.object.extend = function (target, var_args) {
    var key, source;
    for (var i = 1; i < arguments.length; i++) {
        source = arguments[i];
        for (key in source) {
            target[key] = source[key];
        }

        // For IE the for-in-loop does not contain any properties that are not
        // enumerable on the prototype object (for example isPrototypeOf from
        // Object.prototype) and it will also not include 'replace' on objects that
        // extend String and change 'replace' (not that it is common for anyone to
        // extend anything except Object).

        for (var j = 0; j < goog.object.PROTOTYPE_FIELDS_.length; j++) {
            key = goog.object.PROTOTYPE_FIELDS_[j];
            if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
            }
        }
    }
};


/**
 * Creates a new object built from the key-value pairs provided as arguments.
 * @param {...*} var_args If only one argument is provided and it is an array
 *     then this is used as the arguments,  otherwise even arguments are used as
 *     the property names and odd arguments are used as the property values.
 * @return {!Object} The new object.
 * @throws {Error} If there are uneven number of arguments or there is only one
 *     non array argument.
 */
goog.object.create = function (var_args) {
    var argLength = arguments.length;
    if (argLength == 1 && goog.isArray(arguments[0])) {
        return goog.object.create.apply(null, arguments[0]);
    }

    if (argLength % 2) {
        throw Error('Uneven number of arguments');
    }

    var rv = {};
    for (var i = 0; i < argLength; i += 2) {
        rv[arguments[i]] = arguments[i + 1];
    }
    return rv;
};


/**
 * Creates a new object where the property names come from the arguments but
 * the value is always set to true
 * @param {...*} var_args If only one argument is provided and it is an array
 *     then this is used as the arguments,  otherwise the arguments are used
 *     as the property names.
 * @return {!Object} The new object.
 */
goog.object.createSet = function (var_args) {
    var argLength = arguments.length;
    if (argLength == 1 && goog.isArray(arguments[0])) {
        return goog.object.createSet.apply(null, arguments[0]);
    }

    var rv = {};
    for (var i = 0; i < argLength; i++) {
        rv[arguments[i]] = true;
    }
    return rv;
};


/**
 * Creates an immutable view of the underlying object, if the browser
 * supports immutable objects.
 *
 * In default mode, writes to this view will fail silently. In strict mode,
 * they will throw an error.
 *
 * @param {!Object.<K,V>} obj An object.
 * @return {!Object.<K,V>} An immutable view of that object, or the
 *     original object if this browser does not support immutables.
 * @template K,V
 */
goog.object.createImmutableView = function (obj) {
    var result = obj;
    if (Object.isFrozen && !Object.isFrozen(obj)) {
        result = Object.create(obj);
        Object.freeze(result);
    }
    return result;
};


/**
 * @param {!Object} obj An object.
 * @return {boolean} Whether this is an immutable view of the object.
 */
goog.object.isImmutableView = function (obj) {
    return !!Object.isFrozen && Object.isFrozen(obj);
};

// Input 19
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for manipulating the browser's Document Object Model
 * Inspiration taken *heavily* from mochikit (http://mochikit.com/).
 *
 * You can use {@link goog.dom.DomHelper} to create new dom helpers that refer
 * to a different document object.  This is useful if you are working with
 * frames or multiple windows.
 *
 */


// TODO(arv): Rename/refactor getTextContent and getRawTextContent. The problem
// is that getTextContent should mimic the DOM3 textContent. We should add a
// getInnerText (or getText) which tries to return the visible text, innerText.


goog.provide('goog.dom');
goog.provide('goog.dom.Appendable');
goog.provide('goog.dom.DomHelper');

goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.dom.BrowserFeature');
goog.require('goog.dom.NodeType');
goog.require('goog.dom.TagName');
goog.require('goog.dom.classes');
goog.require('goog.functions');
goog.require('goog.math.Coordinate');
goog.require('goog.math.Size');
goog.require('goog.object');
goog.require('goog.string');
goog.require('goog.userAgent');


/**
 * @define {boolean} Whether we know at compile time that the browser is in
 * quirks mode.
 */
goog.define('goog.dom.ASSUME_QUIRKS_MODE', false);


/**
 * @define {boolean} Whether we know at compile time that the browser is in
 * standards compliance mode.
 */
goog.define('goog.dom.ASSUME_STANDARDS_MODE', false);


/**
 * Whether we know the compatibility mode at compile time.
 * @type {boolean}
 * @private
 */
goog.dom.COMPAT_MODE_KNOWN_ =
    goog.dom.ASSUME_QUIRKS_MODE || goog.dom.ASSUME_STANDARDS_MODE;


/**
 * Gets the DomHelper object for the document where the element resides.
 * @param {(Node|Window)=} opt_element If present, gets the DomHelper for this
 *     element.
 * @return {!goog.dom.DomHelper} The DomHelper.
 */
goog.dom.getDomHelper = function (opt_element) {
    return opt_element ?
        new goog.dom.DomHelper(goog.dom.getOwnerDocument(opt_element)) :
        (goog.dom.defaultDomHelper_ ||
            (goog.dom.defaultDomHelper_ = new goog.dom.DomHelper()));
};


/**
 * Cached default DOM helper.
 * @type {goog.dom.DomHelper}
 * @private
 */
goog.dom.defaultDomHelper_;


/**
 * Gets the document object being used by the dom library.
 * @return {!Document} Document object.
 */
goog.dom.getDocument = function () {
    return document;
};


/**
 * Gets an element from the current document by element id.
 *
 * If an Element is passed in, it is returned.
 *
 * @param {string|Element} element Element ID or a DOM node.
 * @return {Element} The element with the given ID, or the node passed in.
 */
goog.dom.getElement = function (element) {
    return goog.dom.getElementHelper_(document, element);
};


/**
 * Gets an element by id from the given document (if present).
 * If an element is given, it is returned.
 * @param {!Document} doc
 * @param {string|Element} element Element ID or a DOM node.
 * @return {Element} The resulting element.
 * @private
 */
goog.dom.getElementHelper_ = function (doc, element) {
    return goog.isString(element) ?
        doc.getElementById(element) :
        element;
};


/**
 * Gets an element by id, asserting that the element is found.
 *
 * This is used when an element is expected to exist, and should fail with
 * an assertion error if it does not (if assertions are enabled).
 *
 * @param {string} id Element ID.
 * @return {!Element} The element with the given ID, if it exists.
 */
goog.dom.getRequiredElement = function (id) {
    return goog.dom.getRequiredElementHelper_(document, id);
};


/**
 * Helper function for getRequiredElementHelper functions, both static and
 * on DomHelper.  Asserts the element with the given id exists.
 * @param {!Document} doc
 * @param {string} id
 * @return {!Element} The element with the given ID, if it exists.
 * @private
 */
goog.dom.getRequiredElementHelper_ = function (doc, id) {
    // To prevent users passing in Elements as is permitted in getElement().
    goog.asserts.assertString(id);
    var element = goog.dom.getElement(id);
    goog.asserts.assert(element, 'No element found with id: ' + id);
    return element;
};


/**
 * Alias for getElement.
 * @param {string|Element} element Element ID or a DOM node.
 * @return {Element} The element with the given ID, or the node passed in.
 * @deprecated Use {@link goog.dom.getElement} instead.
 */
goog.dom.$ = goog.dom.getElement;


/**
 * Looks up elements by both tag and class name, using browser native functions
 * ({@code querySelectorAll}, {@code getElementsByTagName} or
 * {@code getElementsByClassName}) where possible. This function
 * is a useful, if limited, way of collecting a list of DOM elements
 * with certain characteristics.  {@code goog.dom.query} offers a
 * more powerful and general solution which allows matching on CSS3
 * selector expressions, but at increased cost in code size. If all you
 * need is particular tags belonging to a single class, this function
 * is fast and sleek.
 *
 * @see {goog.dom.query}
 *
 * @param {?string=} opt_tag Element tag name.
 * @param {?string=} opt_class Optional class name.
 * @param {(Document|Element)=} opt_el Optional element to look in.
 * @return { {length: number} } Array-like list of elements (only a length
 *     property and numerical indices are guaranteed to exist).
 */
goog.dom.getElementsByTagNameAndClass = function (opt_tag, opt_class, opt_el) {
    return goog.dom.getElementsByTagNameAndClass_(document, opt_tag, opt_class,
        opt_el);
};


/**
 * Returns an array of all the elements with the provided className.
 * @see {goog.dom.query}
 * @param {string} className the name of the class to look for.
 * @param {(Document|Element)=} opt_el Optional element to look in.
 * @return { {length: number} } The items found with the class name provided.
 */
goog.dom.getElementsByClass = function (className, opt_el) {
    var parent = opt_el || document;
    if (goog.dom.canUseQuerySelector_(parent)) {
        return parent.querySelectorAll('.' + className);
    } else if (parent.getElementsByClassName) {
        return parent.getElementsByClassName(className);
    }
    return goog.dom.getElementsByTagNameAndClass_(
        document, '*', className, opt_el);
};


/**
 * Returns the first element with the provided className.
 * @see {goog.dom.query}
 * @param {string} className the name of the class to look for.
 * @param {Element|Document=} opt_el Optional element to look in.
 * @return {Element} The first item with the class name provided.
 */
goog.dom.getElementByClass = function (className, opt_el) {
    var parent = opt_el || document;
    var retVal = null;
    if (goog.dom.canUseQuerySelector_(parent)) {
        retVal = parent.querySelector('.' + className);
    } else {
        retVal = goog.dom.getElementsByClass(className, opt_el)[0];
    }
    return retVal || null;
};


/**
 * Prefer the standardized (http://www.w3.org/TR/selectors-api/), native and
 * fast W3C Selectors API.
 * @param {!(Element|Document)} parent The parent document object.
 * @return {boolean} whether or not we can use parent.querySelector* APIs.
 * @private
 */
goog.dom.canUseQuerySelector_ = function (parent) {
    return !!(parent.querySelectorAll && parent.querySelector);
};


/**
 * Helper for {@code getElementsByTagNameAndClass}.
 * @param {!Document} doc The document to get the elements in.
 * @param {?string=} opt_tag Element tag name.
 * @param {?string=} opt_class Optional class name.
 * @param {(Document|Element)=} opt_el Optional element to look in.
 * @return { {length: number} } Array-like list of elements (only a length
 *     property and numerical indices are guaranteed to exist).
 * @private
 */
goog.dom.getElementsByTagNameAndClass_ = function (doc, opt_tag, opt_class, opt_el) {
    var parent = opt_el || doc;
    var tagName = (opt_tag && opt_tag != '*') ? opt_tag.toUpperCase() : '';

    if (goog.dom.canUseQuerySelector_(parent) &&
        (tagName || opt_class)) {
        var query = tagName + (opt_class ? '.' + opt_class : '');
        return parent.querySelectorAll(query);
    }

    // Use the native getElementsByClassName if available, under the assumption
    // that even when the tag name is specified, there will be fewer elements to
    // filter through when going by class than by tag name
    if (opt_class && parent.getElementsByClassName) {
        var els = parent.getElementsByClassName(opt_class);

        if (tagName) {
            var arrayLike = {};
            var len = 0;

            // Filter for specific tags if requested.
            for (var i = 0, el; el = els[i]; i++) {
                if (tagName == el.nodeName) {
                    arrayLike[len++] = el;
                }
            }
            arrayLike.length = len;

            return arrayLike;
        } else {
            return els;
        }
    }

    var els = parent.getElementsByTagName(tagName || '*');

    if (opt_class) {
        var arrayLike = {};
        var len = 0;
        for (var i = 0, el; el = els[i]; i++) {
            var className = el.className;
            // Check if className has a split function since SVG className does not.
            if (typeof className.split == 'function' &&
                goog.array.contains(className.split(/\s+/), opt_class)) {
                arrayLike[len++] = el;
            }
        }
        arrayLike.length = len;
        return arrayLike;
    } else {
        return els;
    }
};


/**
 * Alias for {@code getElementsByTagNameAndClass}.
 * @param {?string=} opt_tag Element tag name.
 * @param {?string=} opt_class Optional class name.
 * @param {Element=} opt_el Optional element to look in.
 * @return { {length: number} } Array-like list of elements (only a length
 *     property and numerical indices are guaranteed to exist).
 * @deprecated Use {@link goog.dom.getElementsByTagNameAndClass} instead.
 */
goog.dom.$$ = goog.dom.getElementsByTagNameAndClass;


/**
 * Sets multiple properties on a node.
 * @param {Element} element DOM node to set properties on.
 * @param {Object} properties Hash of property:value pairs.
 */
goog.dom.setProperties = function (element, properties) {
    goog.object.forEach(properties, function (val, key) {
        if (key == 'style') {
            element.style.cssText = val;
        } else if (key == 'class') {
            element.className = val;
        } else if (key == 'for') {
            element.htmlFor = val;
        } else if (key in goog.dom.DIRECT_ATTRIBUTE_MAP_) {
            element.setAttribute(goog.dom.DIRECT_ATTRIBUTE_MAP_[key], val);
        } else if (goog.string.startsWith(key, 'aria-') ||
            goog.string.startsWith(key, 'data-')) {
            element.setAttribute(key, val);
        } else {
            element[key] = val;
        }
    });
};


/**
 * Map of attributes that should be set using
 * element.setAttribute(key, val) instead of element[key] = val.  Used
 * by goog.dom.setProperties.
 *
 * @type {Object}
 * @private
 */
goog.dom.DIRECT_ATTRIBUTE_MAP_ = {
    'cellpadding': 'cellPadding',
    'cellspacing': 'cellSpacing',
    'colspan': 'colSpan',
    'frameborder': 'frameBorder',
    'height': 'height',
    'maxlength': 'maxLength',
    'role': 'role',
    'rowspan': 'rowSpan',
    'type': 'type',
    'usemap': 'useMap',
    'valign': 'vAlign',
    'width': 'width'
};


/**
 * Gets the dimensions of the viewport.
 *
 * Gecko Standards mode:
 * docEl.clientWidth  Width of viewport excluding scrollbar.
 * win.innerWidth     Width of viewport including scrollbar.
 * body.clientWidth   Width of body element.
 *
 * docEl.clientHeight Height of viewport excluding scrollbar.
 * win.innerHeight    Height of viewport including scrollbar.
 * body.clientHeight  Height of document.
 *
 * Gecko Backwards compatible mode:
 * docEl.clientWidth  Width of viewport excluding scrollbar.
 * win.innerWidth     Width of viewport including scrollbar.
 * body.clientWidth   Width of viewport excluding scrollbar.
 *
 * docEl.clientHeight Height of document.
 * win.innerHeight    Height of viewport including scrollbar.
 * body.clientHeight  Height of viewport excluding scrollbar.
 *
 * IE6/7 Standards mode:
 * docEl.clientWidth  Width of viewport excluding scrollbar.
 * win.innerWidth     Undefined.
 * body.clientWidth   Width of body element.
 *
 * docEl.clientHeight Height of viewport excluding scrollbar.
 * win.innerHeight    Undefined.
 * body.clientHeight  Height of document element.
 *
 * IE5 + IE6/7 Backwards compatible mode:
 * docEl.clientWidth  0.
 * win.innerWidth     Undefined.
 * body.clientWidth   Width of viewport excluding scrollbar.
 *
 * docEl.clientHeight 0.
 * win.innerHeight    Undefined.
 * body.clientHeight  Height of viewport excluding scrollbar.
 *
 * Opera 9 Standards and backwards compatible mode:
 * docEl.clientWidth  Width of viewport excluding scrollbar.
 * win.innerWidth     Width of viewport including scrollbar.
 * body.clientWidth   Width of viewport excluding scrollbar.
 *
 * docEl.clientHeight Height of document.
 * win.innerHeight    Height of viewport including scrollbar.
 * body.clientHeight  Height of viewport excluding scrollbar.
 *
 * WebKit:
 * Safari 2
 * docEl.clientHeight Same as scrollHeight.
 * docEl.clientWidth  Same as innerWidth.
 * win.innerWidth     Width of viewport excluding scrollbar.
 * win.innerHeight    Height of the viewport including scrollbar.
 * frame.innerHeight  Height of the viewport exluding scrollbar.
 *
 * Safari 3 (tested in 522)
 *
 * docEl.clientWidth  Width of viewport excluding scrollbar.
 * docEl.clientHeight Height of viewport excluding scrollbar in strict mode.
 * body.clientHeight  Height of viewport excluding scrollbar in quirks mode.
 *
 * @param {Window=} opt_window Optional window element to test.
 * @return {!goog.math.Size} Object with values 'width' and 'height'.
 */
goog.dom.getViewportSize = function (opt_window) {
    // TODO(arv): This should not take an argument
    return goog.dom.getViewportSize_(opt_window || window);
};


/**
 * Helper for {@code getViewportSize}.
 * @param {Window} win The window to get the view port size for.
 * @return {!goog.math.Size} Object with values 'width' and 'height'.
 * @private
 */
goog.dom.getViewportSize_ = function (win) {
    var doc = win.document;
    var el = goog.dom.isCss1CompatMode_(doc) ? doc.documentElement : doc.body;
    return new goog.math.Size(el.clientWidth, el.clientHeight);
};


/**
 * Calculates the height of the document.
 *
 * @return {number} The height of the current document.
 */
goog.dom.getDocumentHeight = function () {
    return goog.dom.getDocumentHeight_(window);
};


/**
 * Calculates the height of the document of the given window.
 *
 * Function code copied from the opensocial gadget api:
 *   gadgets.window.adjustHeight(opt_height)
 *
 * @private
 * @param {Window} win The window whose document height to retrieve.
 * @return {number} The height of the document of the given window.
 */
goog.dom.getDocumentHeight_ = function (win) {
    // NOTE(eae): This method will return the window size rather than the document
    // size in webkit quirks mode.
    var doc = win.document;
    var height = 0;

    if (doc) {
        // Calculating inner content height is hard and different between
        // browsers rendering in Strict vs. Quirks mode.  We use a combination of
        // three properties within document.body and document.documentElement:
        // - scrollHeight
        // - offsetHeight
        // - clientHeight
        // These values differ significantly between browsers and rendering modes.
        // But there are patterns.  It just takes a lot of time and persistence
        // to figure out.

        // Get the height of the viewport
        var vh = goog.dom.getViewportSize_(win).height;
        var body = doc.body;
        var docEl = doc.documentElement;
        if (goog.dom.isCss1CompatMode_(doc) && docEl.scrollHeight) {
            // In Strict mode:
            // The inner content height is contained in either:
            //    document.documentElement.scrollHeight
            //    document.documentElement.offsetHeight
            // Based on studying the values output by different browsers,
            // use the value that's NOT equal to the viewport height found above.
            height = docEl.scrollHeight != vh ?
                docEl.scrollHeight : docEl.offsetHeight;
        } else {
            // In Quirks mode:
            // documentElement.clientHeight is equal to documentElement.offsetHeight
            // except in IE.  In most browsers, document.documentElement can be used
            // to calculate the inner content height.
            // However, in other browsers (e.g. IE), document.body must be used
            // instead.  How do we know which one to use?
            // If document.documentElement.clientHeight does NOT equal
            // document.documentElement.offsetHeight, then use document.body.
            var sh = docEl.scrollHeight;
            var oh = docEl.offsetHeight;
            if (docEl.clientHeight != oh) {
                sh = body.scrollHeight;
                oh = body.offsetHeight;
            }

            // Detect whether the inner content height is bigger or smaller
            // than the bounding box (viewport).  If bigger, take the larger
            // value.  If smaller, take the smaller value.
            if (sh > vh) {
                // Content is larger
                height = sh > oh ? sh : oh;
            } else {
                // Content is smaller
                height = sh < oh ? sh : oh;
            }
        }
    }

    return height;
};


/**
 * Gets the page scroll distance as a coordinate object.
 *
 * @param {Window=} opt_window Optional window element to test.
 * @return {!goog.math.Coordinate} Object with values 'x' and 'y'.
 * @deprecated Use {@link goog.dom.getDocumentScroll} instead.
 */
goog.dom.getPageScroll = function (opt_window) {
    var win = opt_window || goog.global || window;
    return goog.dom.getDomHelper(win.document).getDocumentScroll();
};


/**
 * Gets the document scroll distance as a coordinate object.
 *
 * @return {!goog.math.Coordinate} Object with values 'x' and 'y'.
 */
goog.dom.getDocumentScroll = function () {
    return goog.dom.getDocumentScroll_(document);
};


/**
 * Helper for {@code getDocumentScroll}.
 *
 * @param {!Document} doc The document to get the scroll for.
 * @return {!goog.math.Coordinate} Object with values 'x' and 'y'.
 * @private
 */
goog.dom.getDocumentScroll_ = function (doc) {
    var el = goog.dom.getDocumentScrollElement_(doc);
    var win = goog.dom.getWindow_(doc);
    if (goog.userAgent.IE && goog.userAgent.isVersionOrHigher('10') &&
        win.pageYOffset != el.scrollTop) {
        // The keyboard on IE10 touch devices shifts the page using the pageYOffset
        // without modifying scrollTop. For this case, we want the body scroll
        // offsets.
        return new goog.math.Coordinate(el.scrollLeft, el.scrollTop);
    }
    return new goog.math.Coordinate(win.pageXOffset || el.scrollLeft,
        win.pageYOffset || el.scrollTop);
};


/**
 * Gets the document scroll element.
 * @return {Element} Scrolling element.
 */
goog.dom.getDocumentScrollElement = function () {
    return goog.dom.getDocumentScrollElement_(document);
};


/**
 * Helper for {@code getDocumentScrollElement}.
 * @param {!Document} doc The document to get the scroll element for.
 * @return {Element} Scrolling element.
 * @private
 */
goog.dom.getDocumentScrollElement_ = function (doc) {
    // Safari (2 and 3) needs body.scrollLeft in both quirks mode and strict mode.
    return !goog.userAgent.WEBKIT && goog.dom.isCss1CompatMode_(doc) ?
        doc.documentElement : doc.body;
};


/**
 * Gets the window object associated with the given document.
 *
 * @param {Document=} opt_doc  Document object to get window for.
 * @return {!Window} The window associated with the given document.
 */
goog.dom.getWindow = function (opt_doc) {
    // TODO(arv): This should not take an argument.
    return opt_doc ? goog.dom.getWindow_(opt_doc) : window;
};


/**
 * Helper for {@code getWindow}.
 *
 * @param {!Document} doc  Document object to get window for.
 * @return {!Window} The window associated with the given document.
 * @private
 */
goog.dom.getWindow_ = function (doc) {
    return doc.parentWindow || doc.defaultView;
};


/**
 * Returns a dom node with a set of attributes.  This function accepts varargs
 * for subsequent nodes to be added.  Subsequent nodes will be added to the
 * first node as childNodes.
 *
 * So:
 * <code>createDom('div', null, createDom('p'), createDom('p'));</code>
 * would return a div with two child paragraphs
 *
 * @param {string} tagName Tag to create.
 * @param {(Object|Array.<string>|string)=} opt_attributes If object, then a map
 *     of name-value pairs for attributes. If a string, then this is the
 *     className of the new element. If an array, the elements will be joined
 *     together as the className of the new element.
 * @param {...(Object|string|Array|NodeList)} var_args Further DOM nodes or
 *     strings for text nodes. If one of the var_args is an array or NodeList,i
 *     its elements will be added as childNodes instead.
 * @return {!Element} Reference to a DOM node.
 */
goog.dom.createDom = function (tagName, opt_attributes, var_args) {
    return goog.dom.createDom_(document, arguments);
};


/**
 * Helper for {@code createDom}.
 * @param {!Document} doc The document to create the DOM in.
 * @param {!Arguments} args Argument object passed from the callers. See
 *     {@code goog.dom.createDom} for details.
 * @return {!Element} Reference to a DOM node.
 * @private
 */
goog.dom.createDom_ = function (doc, args) {
    var tagName = args[0];
    var attributes = args[1];

    // Internet Explorer is dumb: http://msdn.microsoft.com/workshop/author/
    //                            dhtml/reference/properties/name_2.asp
    // Also does not allow setting of 'type' attribute on 'input' or 'button'.
    if (!goog.dom.BrowserFeature.CAN_ADD_NAME_OR_TYPE_ATTRIBUTES && attributes &&
        (attributes.name || attributes.type)) {
        var tagNameArr = ['<', tagName];
        if (attributes.name) {
            tagNameArr.push(' name="', goog.string.htmlEscape(attributes.name),
                '"');
        }
        if (attributes.type) {
            tagNameArr.push(' type="', goog.string.htmlEscape(attributes.type),
                '"');

            // Clone attributes map to remove 'type' without mutating the input.
            var clone = {};
            goog.object.extend(clone, attributes);

            // JSCompiler can't see how goog.object.extend added this property,
            // because it was essentially added by reflection.
            // So it needs to be quoted.
            delete clone['type'];

            attributes = clone;
        }
        tagNameArr.push('>');
        tagName = tagNameArr.join('');
    }

    var element = doc.createElement(tagName);

    if (attributes) {
        if (goog.isString(attributes)) {
            element.className = attributes;
        } else if (goog.isArray(attributes)) {
            goog.dom.classes.add.apply(null, [element].concat(attributes));
        } else {
            goog.dom.setProperties(element, attributes);
        }
    }

    if (args.length > 2) {
        goog.dom.append_(doc, element, args, 2);
    }

    return element;
};


/**
 * Appends a node with text or other nodes.
 * @param {!Document} doc The document to create new nodes in.
 * @param {!Node} parent The node to append nodes to.
 * @param {!Arguments} args The values to add. See {@code goog.dom.append}.
 * @param {number} startIndex The index of the array to start from.
 * @private
 */
goog.dom.append_ = function (doc, parent, args, startIndex) {
    function childHandler(child) {
        // TODO(user): More coercion, ala MochiKit?
        if (child) {
            parent.appendChild(goog.isString(child) ?
                doc.createTextNode(child) : child);
        }
    }

    for (var i = startIndex; i < args.length; i++) {
        var arg = args[i];
        // TODO(attila): Fix isArrayLike to return false for a text node.
        if (goog.isArrayLike(arg) && !goog.dom.isNodeLike(arg)) {
            // If the argument is a node list, not a real array, use a clone,
            // because forEach can't be used to mutate a NodeList.
            goog.array.forEach(goog.dom.isNodeList(arg) ?
                goog.array.toArray(arg) : arg,
                childHandler);
        } else {
            childHandler(arg);
        }
    }
};


/**
 * Alias for {@code createDom}.
 * @param {string} tagName Tag to create.
 * @param {(string|Object)=} opt_attributes If object, then a map of name-value
 *     pairs for attributes. If a string, then this is the className of the new
 *     element.
 * @param {...(Object|string|Array|NodeList)} var_args Further DOM nodes or
 *     strings for text nodes. If one of the var_args is an array, its
 *     children will be added as childNodes instead.
 * @return {!Element} Reference to a DOM node.
 * @deprecated Use {@link goog.dom.createDom} instead.
 */
goog.dom.$dom = goog.dom.createDom;


/**
 * Creates a new element.
 * @param {string} name Tag name.
 * @return {!Element} The new element.
 */
goog.dom.createElement = function (name) {
    return document.createElement(name);
};


/**
 * Creates a new text node.
 * @param {number|string} content Content.
 * @return {!Text} The new text node.
 */
goog.dom.createTextNode = function (content) {
    return document.createTextNode(String(content));
};


/**
 * Create a table.
 * @param {number} rows The number of rows in the table.  Must be >= 1.
 * @param {number} columns The number of columns in the table.  Must be >= 1.
 * @param {boolean=} opt_fillWithNbsp If true, fills table entries with nsbps.
 * @return {!Element} The created table.
 */
goog.dom.createTable = function (rows, columns, opt_fillWithNbsp) {
    return goog.dom.createTable_(document, rows, columns, !!opt_fillWithNbsp);
};


/**
 * Create a table.
 * @param {!Document} doc Document object to use to create the table.
 * @param {number} rows The number of rows in the table.  Must be >= 1.
 * @param {number} columns The number of columns in the table.  Must be >= 1.
 * @param {boolean} fillWithNbsp If true, fills table entries with nsbps.
 * @return {!Element} The created table.
 * @private
 */
goog.dom.createTable_ = function (doc, rows, columns, fillWithNbsp) {
    var rowHtml = ['<tr>'];
    for (var i = 0; i < columns; i++) {
        rowHtml.push(fillWithNbsp ? '<td>&nbsp;</td>' : '<td></td>');
    }
    rowHtml.push('</tr>');
    rowHtml = rowHtml.join('');
    var totalHtml = ['<table>'];
    for (i = 0; i < rows; i++) {
        totalHtml.push(rowHtml);
    }
    totalHtml.push('</table>');

    var elem = doc.createElement(goog.dom.TagName.DIV);
    elem.innerHTML = totalHtml.join('');
    return /** @type {!Element} */ (elem.removeChild(elem.firstChild));
};


/**
 * Converts an HTML string into a document fragment. The string must be
 * sanitized in order to avoid cross-site scripting. For example
 * {@code goog.dom.htmlToDocumentFragment('&lt;img src=x onerror=alert(0)&gt;')}
 * triggers an alert in all browsers, even if the returned document fragment
 * is thrown away immediately.
 *
 * @param {string} htmlString The HTML string to convert.
 * @return {!Node} The resulting document fragment.
 */
goog.dom.htmlToDocumentFragment = function (htmlString) {
    return goog.dom.htmlToDocumentFragment_(document, htmlString);
};


/**
 * Helper for {@code htmlToDocumentFragment}.
 *
 * @param {!Document} doc The document.
 * @param {string} htmlString The HTML string to convert.
 * @return {!Node} The resulting document fragment.
 * @private
 */
goog.dom.htmlToDocumentFragment_ = function (doc, htmlString) {
    var tempDiv = doc.createElement('div');
    if (goog.dom.BrowserFeature.INNER_HTML_NEEDS_SCOPED_ELEMENT) {
        tempDiv.innerHTML = '<br>' + htmlString;
        tempDiv.removeChild(tempDiv.firstChild);
    } else {
        tempDiv.innerHTML = htmlString;
    }
    if (tempDiv.childNodes.length == 1) {
        return /** @type {!Node} */ (tempDiv.removeChild(tempDiv.firstChild));
    } else {
        var fragment = doc.createDocumentFragment();
        while (tempDiv.firstChild) {
            fragment.appendChild(tempDiv.firstChild);
        }
        return fragment;
    }
};


/**
 * Returns the compatMode of the document.
 * @return {string} The result is either CSS1Compat or BackCompat.
 * @deprecated use goog.dom.isCss1CompatMode instead.
 */
goog.dom.getCompatMode = function () {
    return goog.dom.isCss1CompatMode() ? 'CSS1Compat' : 'BackCompat';
};


/**
 * Returns true if the browser is in "CSS1-compatible" (standards-compliant)
 * mode, false otherwise.
 * @return {boolean} True if in CSS1-compatible mode.
 */
goog.dom.isCss1CompatMode = function () {
    return goog.dom.isCss1CompatMode_(document);
};


/**
 * Returns true if the browser is in "CSS1-compatible" (standards-compliant)
 * mode, false otherwise.
 * @param {Document} doc The document to check.
 * @return {boolean} True if in CSS1-compatible mode.
 * @private
 */
goog.dom.isCss1CompatMode_ = function (doc) {
    if (goog.dom.COMPAT_MODE_KNOWN_) {
        return goog.dom.ASSUME_STANDARDS_MODE;
    }

    return doc.compatMode == 'CSS1Compat';
};


/**
 * Determines if the given node can contain children, intended to be used for
 * HTML generation.
 *
 * IE natively supports node.canHaveChildren but has inconsistent behavior.
 * Prior to IE8 the base tag allows children and in IE9 all nodes return true
 * for canHaveChildren.
 *
 * In practice all non-IE browsers allow you to add children to any node, but
 * the behavior is inconsistent:
 *
 * <pre>
 *   var a = document.createElement('br');
 *   a.appendChild(document.createTextNode('foo'));
 *   a.appendChild(document.createTextNode('bar'));
 *   console.log(a.childNodes.length);  // 2
 *   console.log(a.innerHTML);  // Chrome: "", IE9: "foobar", FF3.5: "foobar"
 * </pre>
 *
 * For more information, see:
 * http://dev.w3.org/html5/markup/syntax.html#syntax-elements
 *
 * TODO(user): Rename shouldAllowChildren() ?
 *
 * @param {Node} node The node to check.
 * @return {boolean} Whether the node can contain children.
 */
goog.dom.canHaveChildren = function (node) {
    if (node.nodeType != goog.dom.NodeType.ELEMENT) {
        return false;
    }
    switch (node.tagName) {
        case goog.dom.TagName.APPLET:
        case goog.dom.TagName.AREA:
        case goog.dom.TagName.BASE:
        case goog.dom.TagName.BR:
        case goog.dom.TagName.COL:
        case goog.dom.TagName.COMMAND:
        case goog.dom.TagName.EMBED:
        case goog.dom.TagName.FRAME:
        case goog.dom.TagName.HR:
        case goog.dom.TagName.IMG:
        case goog.dom.TagName.INPUT:
        case goog.dom.TagName.IFRAME:
        case goog.dom.TagName.ISINDEX:
        case goog.dom.TagName.KEYGEN:
        case goog.dom.TagName.LINK:
        case goog.dom.TagName.NOFRAMES:
        case goog.dom.TagName.NOSCRIPT:
        case goog.dom.TagName.META:
        case goog.dom.TagName.OBJECT:
        case goog.dom.TagName.PARAM:
        case goog.dom.TagName.SCRIPT:
        case goog.dom.TagName.SOURCE:
        case goog.dom.TagName.STYLE:
        case goog.dom.TagName.TRACK:
        case goog.dom.TagName.WBR:
            return false;
    }
    return true;
};


/**
 * Appends a child to a node.
 * @param {Node} parent Parent.
 * @param {Node} child Child.
 */
goog.dom.appendChild = function (parent, child) {
    parent.appendChild(child);
};


/**
 * Appends a node with text or other nodes.
 * @param {!Node} parent The node to append nodes to.
 * @param {...goog.dom.Appendable} var_args The things to append to the node.
 *     If this is a Node it is appended as is.
 *     If this is a string then a text node is appended.
 *     If this is an array like object then fields 0 to length - 1 are appended.
 */
goog.dom.append = function (parent, var_args) {
    goog.dom.append_(goog.dom.getOwnerDocument(parent), parent, arguments, 1);
};


/**
 * Removes all the child nodes on a DOM node.
 * @param {Node} node Node to remove children from.
 */
goog.dom.removeChildren = function (node) {
    // Note: Iterations over live collections can be slow, this is the fastest
    // we could find. The double parenthesis are used to prevent JsCompiler and
    // strict warnings.
    var child;
    while ((child = node.firstChild)) {
        node.removeChild(child);
    }
};


/**
 * Inserts a new node before an existing reference node (i.e. as the previous
 * sibling). If the reference node has no parent, then does nothing.
 * @param {Node} newNode Node to insert.
 * @param {Node} refNode Reference node to insert before.
 */
goog.dom.insertSiblingBefore = function (newNode, refNode) {
    if (refNode.parentNode) {
        refNode.parentNode.insertBefore(newNode, refNode);
    }
};


/**
 * Inserts a new node after an existing reference node (i.e. as the next
 * sibling). If the reference node has no parent, then does nothing.
 * @param {Node} newNode Node to insert.
 * @param {Node} refNode Reference node to insert after.
 */
goog.dom.insertSiblingAfter = function (newNode, refNode) {
    if (refNode.parentNode) {
        refNode.parentNode.insertBefore(newNode, refNode.nextSibling);
    }
};


/**
 * Insert a child at a given index. If index is larger than the number of child
 * nodes that the parent currently has, the node is inserted as the last child
 * node.
 * @param {Element} parent The element into which to insert the child.
 * @param {Node} child The element to insert.
 * @param {number} index The index at which to insert the new child node. Must
 *     not be negative.
 */
goog.dom.insertChildAt = function (parent, child, index) {
    // Note that if the second argument is null, insertBefore
    // will append the child at the end of the list of children.
    parent.insertBefore(child, parent.childNodes[index] || null);
};


/**
 * Removes a node from its parent.
 * @param {Node} node The node to remove.
 * @return {Node} The node removed if removed; else, null.
 */
goog.dom.removeNode = function (node) {
    return node && node.parentNode ? node.parentNode.removeChild(node) : null;
};


/**
 * Replaces a node in the DOM tree. Will do nothing if {@code oldNode} has no
 * parent.
 * @param {Node} newNode Node to insert.
 * @param {Node} oldNode Node to replace.
 */
goog.dom.replaceNode = function (newNode, oldNode) {
    var parent = oldNode.parentNode;
    if (parent) {
        parent.replaceChild(newNode, oldNode);
    }
};


/**
 * Flattens an element. That is, removes it and replace it with its children.
 * Does nothing if the element is not in the document.
 * @param {Element} element The element to flatten.
 * @return {Element|undefined} The original element, detached from the document
 *     tree, sans children; or undefined, if the element was not in the document
 *     to begin with.
 */
goog.dom.flattenElement = function (element) {
    var child, parent = element.parentNode;
    if (parent && parent.nodeType != goog.dom.NodeType.DOCUMENT_FRAGMENT) {
        // Use IE DOM method (supported by Opera too) if available
        if (element.removeNode) {
            return /** @type {Element} */ (element.removeNode(false));
        } else {
            // Move all children of the original node up one level.
            while ((child = element.firstChild)) {
                parent.insertBefore(child, element);
            }

            // Detach the original element.
            return /** @type {Element} */ (goog.dom.removeNode(element));
        }
    }
};


/**
 * Returns an array containing just the element children of the given element.
 * @param {Element} element The element whose element children we want.
 * @return {!(Array|NodeList)} An array or array-like list of just the element
 *     children of the given element.
 */
goog.dom.getChildren = function (element) {
    // We check if the children attribute is supported for child elements
    // since IE8 misuses the attribute by also including comments.
    if (goog.dom.BrowserFeature.CAN_USE_CHILDREN_ATTRIBUTE &&
        element.children != undefined) {
        return element.children;
    }
    // Fall back to manually filtering the element's child nodes.
    return goog.array.filter(element.childNodes, function (node) {
        return node.nodeType == goog.dom.NodeType.ELEMENT;
    });
};


/**
 * Returns the first child node that is an element.
 * @param {Node} node The node to get the first child element of.
 * @return {Element} The first child node of {@code node} that is an element.
 */
goog.dom.getFirstElementChild = function (node) {
    if (node.firstElementChild != undefined) {
        return /** @type {Element} */(node).firstElementChild;
    }
    return goog.dom.getNextElementNode_(node.firstChild, true);
};


/**
 * Returns the last child node that is an element.
 * @param {Node} node The node to get the last child element of.
 * @return {Element} The last child node of {@code node} that is an element.
 */
goog.dom.getLastElementChild = function (node) {
    if (node.lastElementChild != undefined) {
        return /** @type {Element} */(node).lastElementChild;
    }
    return goog.dom.getNextElementNode_(node.lastChild, false);
};


/**
 * Returns the first next sibling that is an element.
 * @param {Node} node The node to get the next sibling element of.
 * @return {Element} The next sibling of {@code node} that is an element.
 */
goog.dom.getNextElementSibling = function (node) {
    if (node.nextElementSibling != undefined) {
        return /** @type {Element} */(node).nextElementSibling;
    }
    return goog.dom.getNextElementNode_(node.nextSibling, true);
};


/**
 * Returns the first previous sibling that is an element.
 * @param {Node} node The node to get the previous sibling element of.
 * @return {Element} The first previous sibling of {@code node} that is
 *     an element.
 */
goog.dom.getPreviousElementSibling = function (node) {
    if (node.previousElementSibling != undefined) {
        return /** @type {Element} */(node).previousElementSibling;
    }
    return goog.dom.getNextElementNode_(node.previousSibling, false);
};


/**
 * Returns the first node that is an element in the specified direction,
 * starting with {@code node}.
 * @param {Node} node The node to get the next element from.
 * @param {boolean} forward Whether to look forwards or backwards.
 * @return {Element} The first element.
 * @private
 */
goog.dom.getNextElementNode_ = function (node, forward) {
    while (node && node.nodeType != goog.dom.NodeType.ELEMENT) {
        node = forward ? node.nextSibling : node.previousSibling;
    }

    return /** @type {Element} */ (node);
};


/**
 * Returns the next node in source order from the given node.
 * @param {Node} node The node.
 * @return {Node} The next node in the DOM tree, or null if this was the last
 *     node.
 */
goog.dom.getNextNode = function (node) {
    if (!node) {
        return null;
    }

    if (node.firstChild) {
        return node.firstChild;
    }

    while (node && !node.nextSibling) {
        node = node.parentNode;
    }

    return node ? node.nextSibling : null;
};


/**
 * Returns the previous node in source order from the given node.
 * @param {Node} node The node.
 * @return {Node} The previous node in the DOM tree, or null if this was the
 *     first node.
 */
goog.dom.getPreviousNode = function (node) {
    if (!node) {
        return null;
    }

    if (!node.previousSibling) {
        return node.parentNode;
    }

    node = node.previousSibling;
    while (node && node.lastChild) {
        node = node.lastChild;
    }

    return node;
};


/**
 * Whether the object looks like a DOM node.
 * @param {*} obj The object being tested for node likeness.
 * @return {boolean} Whether the object looks like a DOM node.
 */
goog.dom.isNodeLike = function (obj) {
    return goog.isObject(obj) && obj.nodeType > 0;
};


/**
 * Whether the object looks like an Element.
 * @param {*} obj The object being tested for Element likeness.
 * @return {boolean} Whether the object looks like an Element.
 */
goog.dom.isElement = function (obj) {
    return goog.isObject(obj) && obj.nodeType == goog.dom.NodeType.ELEMENT;
};


/**
 * Returns true if the specified value is a Window object. This includes the
 * global window for HTML pages, and iframe windows.
 * @param {*} obj Variable to test.
 * @return {boolean} Whether the variable is a window.
 */
goog.dom.isWindow = function (obj) {
    return goog.isObject(obj) && obj['window'] == obj;
};


/**
 * Returns an element's parent, if it's an Element.
 * @param {Element} element The DOM element.
 * @return {Element} The parent, or null if not an Element.
 */
goog.dom.getParentElement = function (element) {
    if (goog.dom.BrowserFeature.CAN_USE_PARENT_ELEMENT_PROPERTY) {
        var isIe9 = goog.userAgent.IE &&
            goog.userAgent.isVersionOrHigher('9') && !goog.userAgent.isVersionOrHigher('10');
        // SVG elements in IE9 can't use the parentElement property.
        // goog.global['SVGElement'] is not defined in IE9 quirks mode.
        if (!(isIe9 && goog.global['SVGElement'] &&
            element instanceof goog.global['SVGElement'])) {
            return element.parentElement;
        }
    }
    var parent = element.parentNode;
    return goog.dom.isElement(parent) ? /** @type {!Element} */ (parent) : null;
};


/**
 * Whether a node contains another node.
 * @param {Node} parent The node that should contain the other node.
 * @param {Node} descendant The node to test presence of.
 * @return {boolean} Whether the parent node contains the descendent node.
 */
goog.dom.contains = function (parent, descendant) {
    // We use browser specific methods for this if available since it is faster
    // that way.

    // IE DOM
    if (parent.contains && descendant.nodeType == goog.dom.NodeType.ELEMENT) {
        return parent == descendant || parent.contains(descendant);
    }

    // W3C DOM Level 3
    if (typeof parent.compareDocumentPosition != 'undefined') {
        return parent == descendant ||
            Boolean(parent.compareDocumentPosition(descendant) & 16);
    }

    // W3C DOM Level 1
    while (descendant && parent != descendant) {
        descendant = descendant.parentNode;
    }
    return descendant == parent;
};


/**
 * Compares the document order of two nodes, returning 0 if they are the same
 * node, a negative number if node1 is before node2, and a positive number if
 * node2 is before node1.  Note that we compare the order the tags appear in the
 * document so in the tree <b><i>text</i></b> the B node is considered to be
 * before the I node.
 *
 * @param {Node} node1 The first node to compare.
 * @param {Node} node2 The second node to compare.
 * @return {number} 0 if the nodes are the same node, a negative number if node1
 *     is before node2, and a positive number if node2 is before node1.
 */
goog.dom.compareNodeOrder = function (node1, node2) {
    // Fall out quickly for equality.
    if (node1 == node2) {
        return 0;
    }

    // Use compareDocumentPosition where available
    if (node1.compareDocumentPosition) {
        // 4 is the bitmask for FOLLOWS.
        return node1.compareDocumentPosition(node2) & 2 ? 1 : -1;
    }

    // Special case for document nodes on IE 7 and 8.
    if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9)) {
        if (node1.nodeType == goog.dom.NodeType.DOCUMENT) {
            return -1;
        }
        if (node2.nodeType == goog.dom.NodeType.DOCUMENT) {
            return 1;
        }
    }

    // Process in IE using sourceIndex - we check to see if the first node has
    // a source index or if its parent has one.
    if ('sourceIndex' in node1 ||
        (node1.parentNode && 'sourceIndex' in node1.parentNode)) {
        var isElement1 = node1.nodeType == goog.dom.NodeType.ELEMENT;
        var isElement2 = node2.nodeType == goog.dom.NodeType.ELEMENT;

        if (isElement1 && isElement2) {
            return node1.sourceIndex - node2.sourceIndex;
        } else {
            var parent1 = node1.parentNode;
            var parent2 = node2.parentNode;

            if (parent1 == parent2) {
                return goog.dom.compareSiblingOrder_(node1, node2);
            }

            if (!isElement1 && goog.dom.contains(parent1, node2)) {
                return -1 * goog.dom.compareParentsDescendantNodeIe_(node1, node2);
            }


            if (!isElement2 && goog.dom.contains(parent2, node1)) {
                return goog.dom.compareParentsDescendantNodeIe_(node2, node1);
            }

            return (isElement1 ? node1.sourceIndex : parent1.sourceIndex) -
                (isElement2 ? node2.sourceIndex : parent2.sourceIndex);
        }
    }

    // For Safari, we compare ranges.
    var doc = goog.dom.getOwnerDocument(node1);

    var range1, range2;
    range1 = doc.createRange();
    range1.selectNode(node1);
    range1.collapse(true);

    range2 = doc.createRange();
    range2.selectNode(node2);
    range2.collapse(true);

    return range1.compareBoundaryPoints(goog.global['Range'].START_TO_END,
        range2);
};


/**
 * Utility function to compare the position of two nodes, when
 * {@code textNode}'s parent is an ancestor of {@code node}.  If this entry
 * condition is not met, this function will attempt to reference a null object.
 * @param {Node} textNode The textNode to compare.
 * @param {Node} node The node to compare.
 * @return {number} -1 if node is before textNode, +1 otherwise.
 * @private
 */
goog.dom.compareParentsDescendantNodeIe_ = function (textNode, node) {
    var parent = textNode.parentNode;
    if (parent == node) {
        // If textNode is a child of node, then node comes first.
        return -1;
    }
    var sibling = node;
    while (sibling.parentNode != parent) {
        sibling = sibling.parentNode;
    }
    return goog.dom.compareSiblingOrder_(sibling, textNode);
};


/**
 * Utility function to compare the position of two nodes known to be non-equal
 * siblings.
 * @param {Node} node1 The first node to compare.
 * @param {Node} node2 The second node to compare.
 * @return {number} -1 if node1 is before node2, +1 otherwise.
 * @private
 */
goog.dom.compareSiblingOrder_ = function (node1, node2) {
    var s = node2;
    while ((s = s.previousSibling)) {
        if (s == node1) {
            // We just found node1 before node2.
            return -1;
        }
    }

    // Since we didn't find it, node1 must be after node2.
    return 1;
};


/**
 * Find the deepest common ancestor of the given nodes.
 * @param {...Node} var_args The nodes to find a common ancestor of.
 * @return {Node} The common ancestor of the nodes, or null if there is none.
 *     null will only be returned if two or more of the nodes are from different
 *     documents.
 */
goog.dom.findCommonAncestor = function (var_args) {
    var i, count = arguments.length;
    if (!count) {
        return null;
    } else if (count == 1) {
        return arguments[0];
    }

    var paths = [];
    var minLength = Infinity;
    for (i = 0; i < count; i++) {
        // Compute the list of ancestors.
        var ancestors = [];
        var node = arguments[i];
        while (node) {
            ancestors.unshift(node);
            node = node.parentNode;
        }

        // Save the list for comparison.
        paths.push(ancestors);
        minLength = Math.min(minLength, ancestors.length);
    }
    var output = null;
    for (i = 0; i < minLength; i++) {
        var first = paths[0][i];
        for (var j = 1; j < count; j++) {
            if (first != paths[j][i]) {
                return output;
            }
        }
        output = first;
    }
    return output;
};


/**
 * Returns the owner document for a node.
 * @param {Node|Window} node The node to get the document for.
 * @return {!Document} The document owning the node.
 */
goog.dom.getOwnerDocument = function (node) {
    // TODO(arv): Remove IE5 code.
    // IE5 uses document instead of ownerDocument
    return /** @type {!Document} */ (
        node.nodeType == goog.dom.NodeType.DOCUMENT ? node :
            node.ownerDocument || node.document);
};


/**
 * Cross-browser function for getting the document element of a frame or iframe.
 * @param {Element} frame Frame element.
 * @return {!Document} The frame content document.
 */
goog.dom.getFrameContentDocument = function (frame) {
    var doc = frame.contentDocument || frame.contentWindow.document;
    return doc;
};


/**
 * Cross-browser function for getting the window of a frame or iframe.
 * @param {Element} frame Frame element.
 * @return {Window} The window associated with the given frame.
 */
goog.dom.getFrameContentWindow = function (frame) {
    return frame.contentWindow ||
        goog.dom.getWindow(goog.dom.getFrameContentDocument(frame));
};


/**
 * Cross-browser function for setting the text content of an element.
 * @param {Element} element The element to change the text content of.
 * @param {string|number} text The string that should replace the current
 *     element content.
 */
goog.dom.setTextContent = function (element, text) {
    if ('textContent' in element) {
        element.textContent = text;
    } else if (element.firstChild &&
        element.firstChild.nodeType == goog.dom.NodeType.TEXT) {
        // If the first child is a text node we just change its data and remove the
        // rest of the children.
        while (element.lastChild != element.firstChild) {
            element.removeChild(element.lastChild);
        }
        element.firstChild.data = text;
    } else {
        goog.dom.removeChildren(element);
        var doc = goog.dom.getOwnerDocument(element);
        element.appendChild(doc.createTextNode(String(text)));
    }
};


/**
 * Gets the outerHTML of a node, which islike innerHTML, except that it
 * actually contains the HTML of the node itself.
 * @param {Element} element The element to get the HTML of.
 * @return {string} The outerHTML of the given element.
 */
goog.dom.getOuterHtml = function (element) {
    // IE, Opera and WebKit all have outerHTML.
    if ('outerHTML' in element) {
        return element.outerHTML;
    } else {
        var doc = goog.dom.getOwnerDocument(element);
        var div = doc.createElement('div');
        div.appendChild(element.cloneNode(true));
        return div.innerHTML;
    }
};


/**
 * Finds the first descendant node that matches the filter function, using
 * a depth first search. This function offers the most general purpose way
 * of finding a matching element. You may also wish to consider
 * {@code goog.dom.query} which can express many matching criteria using
 * CSS selector expressions. These expressions often result in a more
 * compact representation of the desired result.
 * @see goog.dom.query
 *
 * @param {Node} root The root of the tree to search.
 * @param {function(Node) : boolean} p The filter function.
 * @return {Node|undefined} The found node or undefined if none is found.
 */
goog.dom.findNode = function (root, p) {
    var rv = [];
    var found = goog.dom.findNodes_(root, p, rv, true);
    return found ? rv[0] : undefined;
};


/**
 * Finds all the descendant nodes that match the filter function, using a
 * a depth first search. This function offers the most general-purpose way
 * of finding a set of matching elements. You may also wish to consider
 * {@code goog.dom.query} which can express many matching criteria using
 * CSS selector expressions. These expressions often result in a more
 * compact representation of the desired result.

 * @param {Node} root The root of the tree to search.
 * @param {function(Node) : boolean} p The filter function.
 * @return {!Array.<!Node>} The found nodes or an empty array if none are found.
 */
goog.dom.findNodes = function (root, p) {
    var rv = [];
    goog.dom.findNodes_(root, p, rv, false);
    return rv;
};


/**
 * Finds the first or all the descendant nodes that match the filter function,
 * using a depth first search.
 * @param {Node} root The root of the tree to search.
 * @param {function(Node) : boolean} p The filter function.
 * @param {!Array.<!Node>} rv The found nodes are added to this array.
 * @param {boolean} findOne If true we exit after the first found node.
 * @return {boolean} Whether the search is complete or not. True in case findOne
 *     is true and the node is found. False otherwise.
 * @private
 */
goog.dom.findNodes_ = function (root, p, rv, findOne) {
    if (root != null) {
        var child = root.firstChild;
        while (child) {
            if (p(child)) {
                rv.push(child);
                if (findOne) {
                    return true;
                }
            }
            if (goog.dom.findNodes_(child, p, rv, findOne)) {
                return true;
            }
            child = child.nextSibling;
        }
    }
    return false;
};


/**
 * Map of tags whose content to ignore when calculating text length.
 * @type {Object}
 * @private
 */
goog.dom.TAGS_TO_IGNORE_ = {
    'SCRIPT': 1,
    'STYLE': 1,
    'HEAD': 1,
    'IFRAME': 1,
    'OBJECT': 1
};


/**
 * Map of tags which have predefined values with regard to whitespace.
 * @type {Object}
 * @private
 */
goog.dom.PREDEFINED_TAG_VALUES_ = {'IMG': ' ', 'BR': '\n'};


/**
 * Returns true if the element has a tab index that allows it to receive
 * keyboard focus (tabIndex >= 0), false otherwise.  Note that form elements
 * natively support keyboard focus, even if they have no tab index.
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element has a tab index that allows keyboard
 *     focus.
 * @see http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
 */
goog.dom.isFocusableTabIndex = function (element) {
    return goog.dom.hasSpecifiedTabIndex_(element) &&
        goog.dom.isTabIndexFocusable_(element);
};


/**
 * Enables or disables keyboard focus support on the element via its tab index.
 * Only elements for which {@link goog.dom.isFocusableTabIndex} returns true
 * (or elements that natively support keyboard focus, like form elements) can
 * receive keyboard focus.  See http://go/tabindex for more info.
 * @param {Element} element Element whose tab index is to be changed.
 * @param {boolean} enable Whether to set or remove a tab index on the element
 *     that supports keyboard focus.
 */
goog.dom.setFocusableTabIndex = function (element, enable) {
    if (enable) {
        element.tabIndex = 0;
    } else {
        // Set tabIndex to -1 first, then remove it. This is a workaround for
        // Safari (confirmed in version 4 on Windows). When removing the attribute
        // without setting it to -1 first, the element remains keyboard focusable
        // despite not having a tabIndex attribute anymore.
        element.tabIndex = -1;
        element.removeAttribute('tabIndex'); // Must be camelCase!
    }
};


/**
 * Returns true if the element can be focused, i.e. it has a tab index that
 * allows it to receive keyboard focus (tabIndex >= 0), or it is a form element
 * that natively supports keyboard focus.
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element allows keyboard focus.
 */
goog.dom.isFocusable = function (element) {
    var focusable;
    // Form elements can have unspecified tab index.
    if (goog.dom.isFormElement_(element)) {
        // Make sure the element is not disabled ...
        focusable = !element.disabled &&
            // ... and if a tab index is specified, it allows focus.
            (!goog.dom.hasSpecifiedTabIndex_(element) ||
                goog.dom.isTabIndexFocusable_(element));
    } else {
        focusable = goog.dom.isFocusableTabIndex(element);
    }

    // IE requires elements to be visible in order to focus them.
    return focusable && goog.userAgent.IE ?
        goog.dom.hasNonZeroBoundingRect_(element) : focusable;
};


/**
 * Returns true if the element has a specified tab index.
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element has a specified tab index.
 * @private
 */
goog.dom.hasSpecifiedTabIndex_ = function (element) {
    // IE returns 0 for an unset tabIndex, so we must use getAttributeNode(),
    // which returns an object with a 'specified' property if tabIndex is
    // specified.  This works on other browsers, too.
    var attrNode = element.getAttributeNode('tabindex'); // Must be lowercase!
    return goog.isDefAndNotNull(attrNode) && attrNode.specified;
};


/**
 * Returns true if the element's tab index allows the element to be focused.
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element's tab index allows focus.
 * @private
 */
goog.dom.isTabIndexFocusable_ = function (element) {
    var index = element.tabIndex;
    // NOTE: IE9 puts tabIndex in 16-bit int, e.g. -2 is 65534.
    return goog.isNumber(index) && index >= 0 && index < 32768;
};


/**
 * Returns true if the element is a form element.
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element is a form element.
 * @private
 */
goog.dom.isFormElement_ = function (element) {
    return element.tagName == goog.dom.TagName.INPUT ||
        element.tagName == goog.dom.TagName.TEXTAREA ||
        element.tagName == goog.dom.TagName.SELECT ||
        element.tagName == goog.dom.TagName.BUTTON;
};


/**
 * Returns true if the element has a bounding rectangle that would be visible
 * (i.e. its width and height are greater than zero).
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element has a non-zero bounding rectangle.
 * @private
 */
goog.dom.hasNonZeroBoundingRect_ = function (element) {
    var rect = goog.isFunction(element['getBoundingClientRect']) ?
        element.getBoundingClientRect() :
    {'height': element.offsetHeight, 'width': element.offsetWidth};
    return goog.isDefAndNotNull(rect) && rect.height > 0 && rect.width > 0;
};


/**
 * Returns the text content of the current node, without markup and invisible
 * symbols. New lines are stripped and whitespace is collapsed,
 * such that each character would be visible.
 *
 * In browsers that support it, innerText is used.  Other browsers attempt to
 * simulate it via node traversal.  Line breaks are canonicalized in IE.
 *
 * @param {Node} node The node from which we are getting content.
 * @return {string} The text content.
 */
goog.dom.getTextContent = function (node) {
    var textContent;
    // Note(arv): IE9, Opera, and Safari 3 support innerText but they include
    // text nodes in script tags. So we revert to use a user agent test here.
    if (goog.dom.BrowserFeature.CAN_USE_INNER_TEXT && ('innerText' in node)) {
        textContent = goog.string.canonicalizeNewlines(node.innerText);
        // Unfortunately .innerText() returns text with &shy; symbols
        // We need to filter it out and then remove duplicate whitespaces
    } else {
        var buf = [];
        goog.dom.getTextContent_(node, buf, true);
        textContent = buf.join('');
    }

    // Strip &shy; entities. goog.format.insertWordBreaks inserts them in Opera.
    textContent = textContent.replace(/ \xAD /g, ' ').replace(/\xAD/g, '');
    // Strip &#8203; entities. goog.format.insertWordBreaks inserts them in IE8.
    textContent = textContent.replace(/\u200B/g, '');

    // Skip this replacement on old browsers with working innerText, which
    // automatically turns &nbsp; into ' ' and / +/ into ' ' when reading
    // innerText.
    if (!goog.dom.BrowserFeature.CAN_USE_INNER_TEXT) {
        textContent = textContent.replace(/ +/g, ' ');
    }
    if (textContent != ' ') {
        textContent = textContent.replace(/^\s*/, '');
    }

    return textContent;
};


/**
 * Returns the text content of the current node, without markup.
 *
 * Unlike {@code getTextContent} this method does not collapse whitespaces
 * or normalize lines breaks.
 *
 * @param {Node} node The node from which we are getting content.
 * @return {string} The raw text content.
 */
goog.dom.getRawTextContent = function (node) {
    var buf = [];
    goog.dom.getTextContent_(node, buf, false);

    return buf.join('');
};


/**
 * Recursive support function for text content retrieval.
 *
 * @param {Node} node The node from which we are getting content.
 * @param {Array} buf string buffer.
 * @param {boolean} normalizeWhitespace Whether to normalize whitespace.
 * @private
 */
goog.dom.getTextContent_ = function (node, buf, normalizeWhitespace) {
    if (node.nodeName in goog.dom.TAGS_TO_IGNORE_) {
        // ignore certain tags
    } else if (node.nodeType == goog.dom.NodeType.TEXT) {
        if (normalizeWhitespace) {
            buf.push(String(node.nodeValue).replace(/(\r\n|\r|\n)/g, ''));
        } else {
            buf.push(node.nodeValue);
        }
    } else if (node.nodeName in goog.dom.PREDEFINED_TAG_VALUES_) {
        buf.push(goog.dom.PREDEFINED_TAG_VALUES_[node.nodeName]);
    } else {
        var child = node.firstChild;
        while (child) {
            goog.dom.getTextContent_(child, buf, normalizeWhitespace);
            child = child.nextSibling;
        }
    }
};


/**
 * Returns the text length of the text contained in a node, without markup. This
 * is equivalent to the selection length if the node was selected, or the number
 * of cursor movements to traverse the node. Images & BRs take one space.  New
 * lines are ignored.
 *
 * @param {Node} node The node whose text content length is being calculated.
 * @return {number} The length of {@code node}'s text content.
 */
goog.dom.getNodeTextLength = function (node) {
    return goog.dom.getTextContent(node).length;
};


/**
 * Returns the text offset of a node relative to one of its ancestors. The text
 * length is the same as the length calculated by goog.dom.getNodeTextLength.
 *
 * @param {Node} node The node whose offset is being calculated.
 * @param {Node=} opt_offsetParent The node relative to which the offset will
 *     be calculated. Defaults to the node's owner document's body.
 * @return {number} The text offset.
 */
goog.dom.getNodeTextOffset = function (node, opt_offsetParent) {
    var root = opt_offsetParent || goog.dom.getOwnerDocument(node).body;
    var buf = [];
    while (node && node != root) {
        var cur = node;
        while ((cur = cur.previousSibling)) {
            buf.unshift(goog.dom.getTextContent(cur));
        }
        node = node.parentNode;
    }
    // Trim left to deal with FF cases when there might be line breaks and empty
    // nodes at the front of the text
    return goog.string.trimLeft(buf.join('')).replace(/ +/g, ' ').length;
};


/**
 * Returns the node at a given offset in a parent node.  If an object is
 * provided for the optional third parameter, the node and the remainder of the
 * offset will stored as properties of this object.
 * @param {Node} parent The parent node.
 * @param {number} offset The offset into the parent node.
 * @param {Object=} opt_result Object to be used to store the return value. The
 *     return value will be stored in the form {node: Node, remainder: number}
 *     if this object is provided.
 * @return {Node} The node at the given offset.
 */
goog.dom.getNodeAtOffset = function (parent, offset, opt_result) {
    var stack = [parent], pos = 0, cur = null;
    while (stack.length > 0 && pos < offset) {
        cur = stack.pop();
        if (cur.nodeName in goog.dom.TAGS_TO_IGNORE_) {
            // ignore certain tags
        } else if (cur.nodeType == goog.dom.NodeType.TEXT) {
            var text = cur.nodeValue.replace(/(\r\n|\r|\n)/g, '').replace(/ +/g, ' ');
            pos += text.length;
        } else if (cur.nodeName in goog.dom.PREDEFINED_TAG_VALUES_) {
            pos += goog.dom.PREDEFINED_TAG_VALUES_[cur.nodeName].length;
        } else {
            for (var i = cur.childNodes.length - 1; i >= 0; i--) {
                stack.push(cur.childNodes[i]);
            }
        }
    }
    if (goog.isObject(opt_result)) {
        opt_result.remainder = cur ? cur.nodeValue.length + offset - pos - 1 : 0;
        opt_result.node = cur;
    }

    return cur;
};


/**
 * Returns true if the object is a {@code NodeList}.  To qualify as a NodeList,
 * the object must have a numeric length property and an item function (which
 * has type 'string' on IE for some reason).
 * @param {Object} val Object to test.
 * @return {boolean} Whether the object is a NodeList.
 */
goog.dom.isNodeList = function (val) {
    // TODO(attila): Now the isNodeList is part of goog.dom we can use
    // goog.userAgent to make this simpler.
    // A NodeList must have a length property of type 'number' on all platforms.
    if (val && typeof val.length == 'number') {
        // A NodeList is an object everywhere except Safari, where it's a function.
        if (goog.isObject(val)) {
            // A NodeList must have an item function (on non-IE platforms) or an item
            // property of type 'string' (on IE).
            return typeof val.item == 'function' || typeof val.item == 'string';
        } else if (goog.isFunction(val)) {
            // On Safari, a NodeList is a function with an item property that is also
            // a function.
            return typeof val.item == 'function';
        }
    }

    // Not a NodeList.
    return false;
};


/**
 * Walks up the DOM hierarchy returning the first ancestor that has the passed
 * tag name and/or class name. If the passed element matches the specified
 * criteria, the element itself is returned.
 * @param {Node} element The DOM node to start with.
 * @param {?(goog.dom.TagName|string)=} opt_tag The tag name to match (or
 *     null/undefined to match only based on class name).
 * @param {?string=} opt_class The class name to match (or null/undefined to
 *     match only based on tag name).
 * @return {Element} The first ancestor that matches the passed criteria, or
 *     null if no match is found.
 */
goog.dom.getAncestorByTagNameAndClass = function (element, opt_tag, opt_class) {
    if (!opt_tag && !opt_class) {
        return null;
    }
    var tagName = opt_tag ? opt_tag.toUpperCase() : null;
    return /** @type {Element} */ (goog.dom.getAncestor(element,
        function (node) {
            return (!tagName || node.nodeName == tagName) &&
                (!opt_class || goog.dom.classes.has(node, opt_class));
        }, true));
};


/**
 * Walks up the DOM hierarchy returning the first ancestor that has the passed
 * class name. If the passed element matches the specified criteria, the
 * element itself is returned.
 * @param {Node} element The DOM node to start with.
 * @param {string} className The class name to match.
 * @return {Element} The first ancestor that matches the passed criteria, or
 *     null if none match.
 */
goog.dom.getAncestorByClass = function (element, className) {
    return goog.dom.getAncestorByTagNameAndClass(element, null, className);
};


/**
 * Walks up the DOM hierarchy returning the first ancestor that passes the
 * matcher function.
 * @param {Node} element The DOM node to start with.
 * @param {function(Node) : boolean} matcher A function that returns true if the
 *     passed node matches the desired criteria.
 * @param {boolean=} opt_includeNode If true, the node itself is included in
 *     the search (the first call to the matcher will pass startElement as
 *     the node to test).
 * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the
 *     dom.
 * @return {Node} DOM node that matched the matcher, or null if there was
 *     no match.
 */
goog.dom.getAncestor = function (element, matcher, opt_includeNode, opt_maxSearchSteps) {
    if (!opt_includeNode) {
        element = element.parentNode;
    }
    var ignoreSearchSteps = opt_maxSearchSteps == null;
    var steps = 0;
    while (element && (ignoreSearchSteps || steps <= opt_maxSearchSteps)) {
        if (matcher(element)) {
            return element;
        }
        element = element.parentNode;
        steps++;
    }
    // Reached the root of the DOM without a match
    return null;
};


/**
 * Determines the active element in the given document.
 * @param {Document} doc The document to look in.
 * @return {Element} The active element.
 */
goog.dom.getActiveElement = function (doc) {
    try {
        return doc && doc.activeElement;
    } catch (e) {
        // NOTE(nicksantos): Sometimes, evaluating document.activeElement in IE
        // throws an exception. I'm not 100% sure why, but I suspect it chokes
        // on document.activeElement if the activeElement has been recently
        // removed from the DOM by a JS operation.
        //
        // We assume that an exception here simply means
        // "there is no active element."
    }

    return null;
};


/**
 * @private {number} Cached version of the devicePixelRatio.
 */
goog.dom.devicePixelRatio_;


/**
 * Gives the devicePixelRatio, or attempts to determine if not present.
 *
 * By default, this is the same value given by window.devicePixelRatio. If
 * devicePixelRatio is not defined, the ratio is calculated with
 * window.matchMedia, if present. Otherwise, gives 1.0.
 *
 * This function is cached so that the pixel ratio is calculated only once
 * and only calculated when first requested.
 *
 * @return {number} The number of actual pixels per virtual pixel.
 */
goog.dom.getPixelRatio = goog.functions.cacheReturnValue(function () {
    var win = goog.dom.getWindow();

    // devicePixelRatio does not work on Mobile firefox.
    // TODO(user): Enable this check on a known working mobile Gecko version.
    // Filed a bug: https://bugzilla.mozilla.org/show_bug.cgi?id=896804
    var isFirefoxMobile = goog.userAgent.GECKO && goog.userAgent.MOBILE;

    if (goog.isDef(win.devicePixelRatio) && !isFirefoxMobile) {
        return win.devicePixelRatio;
    } else if (win.matchMedia) {
        return goog.dom.matchesPixelRatio_(.75) ||
            goog.dom.matchesPixelRatio_(1.5) ||
            goog.dom.matchesPixelRatio_(2) ||
            goog.dom.matchesPixelRatio_(3) || 1;
    }
    return 1;
});


/**
 * Calculates a mediaQuery to check if the current device supports the
 * given actual to virtual pixel ratio.
 * @param {number} pixelRatio The ratio of actual pixels to virtual pixels.
 * @return {number} pixelRatio if applicable, otherwise 0.
 * @private
 */
goog.dom.matchesPixelRatio_ = function (pixelRatio) {
    var win = goog.dom.getWindow();
    var query = ('(-webkit-min-device-pixel-ratio: ' + pixelRatio + '),' +
        '(min--moz-device-pixel-ratio: ' + pixelRatio + '),' +
        '(min-resolution: ' + pixelRatio + 'dppx)');
    return win.matchMedia(query).matches ? pixelRatio : 0;
};


/**
 * Create an instance of a DOM helper with a new document object.
 * @param {Document=} opt_document Document object to associate with this
 *     DOM helper.
 * @constructor
 */
goog.dom.DomHelper = function (opt_document) {
    /**
     * Reference to the document object to use
     * @type {!Document}
     * @private
     */
    this.document_ = opt_document || goog.global.document || document;
};


/**
 * Gets the dom helper object for the document where the element resides.
 * @param {Node=} opt_node If present, gets the DomHelper for this node.
 * @return {!goog.dom.DomHelper} The DomHelper.
 */
goog.dom.DomHelper.prototype.getDomHelper = goog.dom.getDomHelper;


/**
 * Sets the document object.
 * @param {!Document} document Document object.
 */
goog.dom.DomHelper.prototype.setDocument = function (document) {
    this.document_ = document;
};


/**
 * Gets the document object being used by the dom library.
 * @return {!Document} Document object.
 */
goog.dom.DomHelper.prototype.getDocument = function () {
    return this.document_;
};


/**
 * Alias for {@code getElementById}. If a DOM node is passed in then we just
 * return that.
 * @param {string|Element} element Element ID or a DOM node.
 * @return {Element} The element with the given ID, or the node passed in.
 */
goog.dom.DomHelper.prototype.getElement = function (element) {
    return goog.dom.getElementHelper_(this.document_, element);
};


/**
 * Gets an element by id, asserting that the element is found.
 *
 * This is used when an element is expected to exist, and should fail with
 * an assertion error if it does not (if assertions are enabled).
 *
 * @param {string} id Element ID.
 * @return {!Element} The element with the given ID, if it exists.
 */
goog.dom.DomHelper.prototype.getRequiredElement = function (id) {
    return goog.dom.getRequiredElementHelper_(this.document_, id);
};


/**
 * Alias for {@code getElement}.
 * @param {string|Element} element Element ID or a DOM node.
 * @return {Element} The element with the given ID, or the node passed in.
 * @deprecated Use {@link goog.dom.DomHelper.prototype.getElement} instead.
 */
goog.dom.DomHelper.prototype.$ = goog.dom.DomHelper.prototype.getElement;


/**
 * Looks up elements by both tag and class name, using browser native functions
 * ({@code querySelectorAll}, {@code getElementsByTagName} or
 * {@code getElementsByClassName}) where possible. The returned array is a live
 * NodeList or a static list depending on the code path taken.
 *
 * @see goog.dom.query
 *
 * @param {?string=} opt_tag Element tag name or * for all tags.
 * @param {?string=} opt_class Optional class name.
 * @param {(Document|Element)=} opt_el Optional element to look in.
 * @return { {length: number} } Array-like list of elements (only a length
 *     property and numerical indices are guaranteed to exist).
 */
goog.dom.DomHelper.prototype.getElementsByTagNameAndClass = function (opt_tag, opt_class, opt_el) {
    return goog.dom.getElementsByTagNameAndClass_(this.document_, opt_tag,
        opt_class, opt_el);
};


/**
 * Returns an array of all the elements with the provided className.
 * @see {goog.dom.query}
 * @param {string} className the name of the class to look for.
 * @param {Element|Document=} opt_el Optional element to look in.
 * @return { {length: number} } The items found with the class name provided.
 */
goog.dom.DomHelper.prototype.getElementsByClass = function (className, opt_el) {
    var doc = opt_el || this.document_;
    return goog.dom.getElementsByClass(className, doc);
};


/**
 * Returns the first element we find matching the provided class name.
 * @see {goog.dom.query}
 * @param {string} className the name of the class to look for.
 * @param {(Element|Document)=} opt_el Optional element to look in.
 * @return {Element} The first item found with the class name provided.
 */
goog.dom.DomHelper.prototype.getElementByClass = function (className, opt_el) {
    var doc = opt_el || this.document_;
    return goog.dom.getElementByClass(className, doc);
};


/**
 * Alias for {@code getElementsByTagNameAndClass}.
 * @deprecated Use DomHelper getElementsByTagNameAndClass.
 * @see goog.dom.query
 *
 * @param {?string=} opt_tag Element tag name.
 * @param {?string=} opt_class Optional class name.
 * @param {Element=} opt_el Optional element to look in.
 * @return { {length: number} } Array-like list of elements (only a length
 *     property and numerical indices are guaranteed to exist).
 */
goog.dom.DomHelper.prototype.$$ =
    goog.dom.DomHelper.prototype.getElementsByTagNameAndClass;


/**
 * Sets a number of properties on a node.
 * @param {Element} element DOM node to set properties on.
 * @param {Object} properties Hash of property:value pairs.
 */
goog.dom.DomHelper.prototype.setProperties = goog.dom.setProperties;


/**
 * Gets the dimensions of the viewport.
 * @param {Window=} opt_window Optional window element to test. Defaults to
 *     the window of the Dom Helper.
 * @return {!goog.math.Size} Object with values 'width' and 'height'.
 */
goog.dom.DomHelper.prototype.getViewportSize = function (opt_window) {
    // TODO(arv): This should not take an argument. That breaks the rule of a
    // a DomHelper representing a single frame/window/document.
    return goog.dom.getViewportSize(opt_window || this.getWindow());
};


/**
 * Calculates the height of the document.
 *
 * @return {number} The height of the document.
 */
goog.dom.DomHelper.prototype.getDocumentHeight = function () {
    return goog.dom.getDocumentHeight_(this.getWindow());
};


/**
 * Typedef for use with goog.dom.createDom and goog.dom.append.
 * @typedef {Object|string|Array|NodeList}
 */
goog.dom.Appendable;


/**
 * Returns a dom node with a set of attributes.  This function accepts varargs
 * for subsequent nodes to be added.  Subsequent nodes will be added to the
 * first node as childNodes.
 *
 * So:
 * <code>createDom('div', null, createDom('p'), createDom('p'));</code>
 * would return a div with two child paragraphs
 *
 * An easy way to move all child nodes of an existing element to a new parent
 * element is:
 * <code>createDom('div', null, oldElement.childNodes);</code>
 * which will remove all child nodes from the old element and add them as
 * child nodes of the new DIV.
 *
 * @param {string} tagName Tag to create.
 * @param {Object|string=} opt_attributes If object, then a map of name-value
 *     pairs for attributes. If a string, then this is the className of the new
 *     element.
 * @param {...goog.dom.Appendable} var_args Further DOM nodes or
 *     strings for text nodes. If one of the var_args is an array or
 *     NodeList, its elements will be added as childNodes instead.
 * @return {!Element} Reference to a DOM node.
 */
goog.dom.DomHelper.prototype.createDom = function (tagName, opt_attributes, var_args) {
    return goog.dom.createDom_(this.document_, arguments);
};


/**
 * Alias for {@code createDom}.
 * @param {string} tagName Tag to create.
 * @param {(Object|string)=} opt_attributes If object, then a map of name-value
 *     pairs for attributes. If a string, then this is the className of the new
 *     element.
 * @param {...goog.dom.Appendable} var_args Further DOM nodes or strings for
 *     text nodes.  If one of the var_args is an array, its children will be
 *     added as childNodes instead.
 * @return {!Element} Reference to a DOM node.
 * @deprecated Use {@link goog.dom.DomHelper.prototype.createDom} instead.
 */
goog.dom.DomHelper.prototype.$dom = goog.dom.DomHelper.prototype.createDom;


/**
 * Creates a new element.
 * @param {string} name Tag name.
 * @return {!Element} The new element.
 */
goog.dom.DomHelper.prototype.createElement = function (name) {
    return this.document_.createElement(name);
};


/**
 * Creates a new text node.
 * @param {number|string} content Content.
 * @return {!Text} The new text node.
 */
goog.dom.DomHelper.prototype.createTextNode = function (content) {
    return this.document_.createTextNode(String(content));
};


/**
 * Create a table.
 * @param {number} rows The number of rows in the table.  Must be >= 1.
 * @param {number} columns The number of columns in the table.  Must be >= 1.
 * @param {boolean=} opt_fillWithNbsp If true, fills table entries with nsbps.
 * @return {!Element} The created table.
 */
goog.dom.DomHelper.prototype.createTable = function (rows, columns, opt_fillWithNbsp) {
    return goog.dom.createTable_(this.document_, rows, columns,
        !!opt_fillWithNbsp);
};


/**
 * Converts an HTML string into a node or a document fragment.  A single Node
 * is used if the {@code htmlString} only generates a single node.  If the
 * {@code htmlString} generates multiple nodes then these are put inside a
 * {@code DocumentFragment}.
 *
 * @param {string} htmlString The HTML string to convert.
 * @return {!Node} The resulting node.
 */
goog.dom.DomHelper.prototype.htmlToDocumentFragment = function (htmlString) {
    return goog.dom.htmlToDocumentFragment_(this.document_, htmlString);
};


/**
 * Returns the compatMode of the document.
 * @return {string} The result is either CSS1Compat or BackCompat.
 * @deprecated use goog.dom.DomHelper.prototype.isCss1CompatMode instead.
 */
goog.dom.DomHelper.prototype.getCompatMode = function () {
    return this.isCss1CompatMode() ? 'CSS1Compat' : 'BackCompat';
};


/**
 * Returns true if the browser is in "CSS1-compatible" (standards-compliant)
 * mode, false otherwise.
 * @return {boolean} True if in CSS1-compatible mode.
 */
goog.dom.DomHelper.prototype.isCss1CompatMode = function () {
    return goog.dom.isCss1CompatMode_(this.document_);
};


/**
 * Gets the window object associated with the document.
 * @return {!Window} The window associated with the given document.
 */
goog.dom.DomHelper.prototype.getWindow = function () {
    return goog.dom.getWindow_(this.document_);
};


/**
 * Gets the document scroll element.
 * @return {Element} Scrolling element.
 */
goog.dom.DomHelper.prototype.getDocumentScrollElement = function () {
    return goog.dom.getDocumentScrollElement_(this.document_);
};


/**
 * Gets the document scroll distance as a coordinate object.
 * @return {!goog.math.Coordinate} Object with properties 'x' and 'y'.
 */
goog.dom.DomHelper.prototype.getDocumentScroll = function () {
    return goog.dom.getDocumentScroll_(this.document_);
};


/**
 * Determines the active element in the given document.
 * @param {Document=} opt_doc The document to look in.
 * @return {Element} The active element.
 */
goog.dom.DomHelper.prototype.getActiveElement = function (opt_doc) {
    return goog.dom.getActiveElement(opt_doc || this.document_);
};


/**
 * Appends a child to a node.
 * @param {Node} parent Parent.
 * @param {Node} child Child.
 */
goog.dom.DomHelper.prototype.appendChild = goog.dom.appendChild;


/**
 * Appends a node with text or other nodes.
 * @param {!Node} parent The node to append nodes to.
 * @param {...goog.dom.Appendable} var_args The things to append to the node.
 *     If this is a Node it is appended as is.
 *     If this is a string then a text node is appended.
 *     If this is an array like object then fields 0 to length - 1 are appended.
 */
goog.dom.DomHelper.prototype.append = goog.dom.append;


/**
 * Determines if the given node can contain children, intended to be used for
 * HTML generation.
 *
 * @param {Node} node The node to check.
 * @return {boolean} Whether the node can contain children.
 */
goog.dom.DomHelper.prototype.canHaveChildren = goog.dom.canHaveChildren;


/**
 * Removes all the child nodes on a DOM node.
 * @param {Node} node Node to remove children from.
 */
goog.dom.DomHelper.prototype.removeChildren = goog.dom.removeChildren;


/**
 * Inserts a new node before an existing reference node (i.e., as the previous
 * sibling). If the reference node has no parent, then does nothing.
 * @param {Node} newNode Node to insert.
 * @param {Node} refNode Reference node to insert before.
 */
goog.dom.DomHelper.prototype.insertSiblingBefore = goog.dom.insertSiblingBefore;


/**
 * Inserts a new node after an existing reference node (i.e., as the next
 * sibling). If the reference node has no parent, then does nothing.
 * @param {Node} newNode Node to insert.
 * @param {Node} refNode Reference node to insert after.
 */
goog.dom.DomHelper.prototype.insertSiblingAfter = goog.dom.insertSiblingAfter;


/**
 * Insert a child at a given index. If index is larger than the number of child
 * nodes that the parent currently has, the node is inserted as the last child
 * node.
 * @param {Element} parent The element into which to insert the child.
 * @param {Node} child The element to insert.
 * @param {number} index The index at which to insert the new child node. Must
 *     not be negative.
 */
goog.dom.DomHelper.prototype.insertChildAt = goog.dom.insertChildAt;


/**
 * Removes a node from its parent.
 * @param {Node} node The node to remove.
 * @return {Node} The node removed if removed; else, null.
 */
goog.dom.DomHelper.prototype.removeNode = goog.dom.removeNode;


/**
 * Replaces a node in the DOM tree. Will do nothing if {@code oldNode} has no
 * parent.
 * @param {Node} newNode Node to insert.
 * @param {Node} oldNode Node to replace.
 */
goog.dom.DomHelper.prototype.replaceNode = goog.dom.replaceNode;


/**
 * Flattens an element. That is, removes it and replace it with its children.
 * @param {Element} element The element to flatten.
 * @return {Element|undefined} The original element, detached from the document
 *     tree, sans children, or undefined if the element was already not in the
 *     document.
 */
goog.dom.DomHelper.prototype.flattenElement = goog.dom.flattenElement;


/**
 * Returns an array containing just the element children of the given element.
 * @param {Element} element The element whose element children we want.
 * @return {!(Array|NodeList)} An array or array-like list of just the element
 *     children of the given element.
 */
goog.dom.DomHelper.prototype.getChildren = goog.dom.getChildren;


/**
 * Returns the first child node that is an element.
 * @param {Node} node The node to get the first child element of.
 * @return {Element} The first child node of {@code node} that is an element.
 */
goog.dom.DomHelper.prototype.getFirstElementChild =
    goog.dom.getFirstElementChild;


/**
 * Returns the last child node that is an element.
 * @param {Node} node The node to get the last child element of.
 * @return {Element} The last child node of {@code node} that is an element.
 */
goog.dom.DomHelper.prototype.getLastElementChild = goog.dom.getLastElementChild;


/**
 * Returns the first next sibling that is an element.
 * @param {Node} node The node to get the next sibling element of.
 * @return {Element} The next sibling of {@code node} that is an element.
 */
goog.dom.DomHelper.prototype.getNextElementSibling =
    goog.dom.getNextElementSibling;


/**
 * Returns the first previous sibling that is an element.
 * @param {Node} node The node to get the previous sibling element of.
 * @return {Element} The first previous sibling of {@code node} that is
 *     an element.
 */
goog.dom.DomHelper.prototype.getPreviousElementSibling =
    goog.dom.getPreviousElementSibling;


/**
 * Returns the next node in source order from the given node.
 * @param {Node} node The node.
 * @return {Node} The next node in the DOM tree, or null if this was the last
 *     node.
 */
goog.dom.DomHelper.prototype.getNextNode = goog.dom.getNextNode;


/**
 * Returns the previous node in source order from the given node.
 * @param {Node} node The node.
 * @return {Node} The previous node in the DOM tree, or null if this was the
 *     first node.
 */
goog.dom.DomHelper.prototype.getPreviousNode = goog.dom.getPreviousNode;


/**
 * Whether the object looks like a DOM node.
 * @param {*} obj The object being tested for node likeness.
 * @return {boolean} Whether the object looks like a DOM node.
 */
goog.dom.DomHelper.prototype.isNodeLike = goog.dom.isNodeLike;


/**
 * Whether the object looks like an Element.
 * @param {*} obj The object being tested for Element likeness.
 * @return {boolean} Whether the object looks like an Element.
 */
goog.dom.DomHelper.prototype.isElement = goog.dom.isElement;


/**
 * Returns true if the specified value is a Window object. This includes the
 * global window for HTML pages, and iframe windows.
 * @param {*} obj Variable to test.
 * @return {boolean} Whether the variable is a window.
 */
goog.dom.DomHelper.prototype.isWindow = goog.dom.isWindow;


/**
 * Returns an element's parent, if it's an Element.
 * @param {Element} element The DOM element.
 * @return {Element} The parent, or null if not an Element.
 */
goog.dom.DomHelper.prototype.getParentElement = goog.dom.getParentElement;


/**
 * Whether a node contains another node.
 * @param {Node} parent The node that should contain the other node.
 * @param {Node} descendant The node to test presence of.
 * @return {boolean} Whether the parent node contains the descendent node.
 */
goog.dom.DomHelper.prototype.contains = goog.dom.contains;


/**
 * Compares the document order of two nodes, returning 0 if they are the same
 * node, a negative number if node1 is before node2, and a positive number if
 * node2 is before node1.  Note that we compare the order the tags appear in the
 * document so in the tree <b><i>text</i></b> the B node is considered to be
 * before the I node.
 *
 * @param {Node} node1 The first node to compare.
 * @param {Node} node2 The second node to compare.
 * @return {number} 0 if the nodes are the same node, a negative number if node1
 *     is before node2, and a positive number if node2 is before node1.
 */
goog.dom.DomHelper.prototype.compareNodeOrder = goog.dom.compareNodeOrder;


/**
 * Find the deepest common ancestor of the given nodes.
 * @param {...Node} var_args The nodes to find a common ancestor of.
 * @return {Node} The common ancestor of the nodes, or null if there is none.
 *     null will only be returned if two or more of the nodes are from different
 *     documents.
 */
goog.dom.DomHelper.prototype.findCommonAncestor = goog.dom.findCommonAncestor;


/**
 * Returns the owner document for a node.
 * @param {Node} node The node to get the document for.
 * @return {!Document} The document owning the node.
 */
goog.dom.DomHelper.prototype.getOwnerDocument = goog.dom.getOwnerDocument;


/**
 * Cross browser function for getting the document element of an iframe.
 * @param {Element} iframe Iframe element.
 * @return {!Document} The frame content document.
 */
goog.dom.DomHelper.prototype.getFrameContentDocument =
    goog.dom.getFrameContentDocument;


/**
 * Cross browser function for getting the window of a frame or iframe.
 * @param {Element} frame Frame element.
 * @return {Window} The window associated with the given frame.
 */
goog.dom.DomHelper.prototype.getFrameContentWindow =
    goog.dom.getFrameContentWindow;


/**
 * Cross browser function for setting the text content of an element.
 * @param {Element} element The element to change the text content of.
 * @param {string} text The string that should replace the current element
 *     content with.
 */
goog.dom.DomHelper.prototype.setTextContent = goog.dom.setTextContent;


/**
 * Gets the outerHTML of a node, which islike innerHTML, except that it
 * actually contains the HTML of the node itself.
 * @param {Element} element The element to get the HTML of.
 * @return {string} The outerHTML of the given element.
 */
goog.dom.DomHelper.prototype.getOuterHtml = goog.dom.getOuterHtml;


/**
 * Finds the first descendant node that matches the filter function. This does
 * a depth first search.
 * @param {Node} root The root of the tree to search.
 * @param {function(Node) : boolean} p The filter function.
 * @return {Node|undefined} The found node or undefined if none is found.
 */
goog.dom.DomHelper.prototype.findNode = goog.dom.findNode;


/**
 * Finds all the descendant nodes that matches the filter function. This does a
 * depth first search.
 * @param {Node} root The root of the tree to search.
 * @param {function(Node) : boolean} p The filter function.
 * @return {Array.<Node>} The found nodes or an empty array if none are found.
 */
goog.dom.DomHelper.prototype.findNodes = goog.dom.findNodes;


/**
 * Returns true if the element has a tab index that allows it to receive
 * keyboard focus (tabIndex >= 0), false otherwise.  Note that form elements
 * natively support keyboard focus, even if they have no tab index.
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element has a tab index that allows keyboard
 *     focus.
 */
goog.dom.DomHelper.prototype.isFocusableTabIndex = goog.dom.isFocusableTabIndex;


/**
 * Enables or disables keyboard focus support on the element via its tab index.
 * Only elements for which {@link goog.dom.isFocusableTabIndex} returns true
 * (or elements that natively support keyboard focus, like form elements) can
 * receive keyboard focus.  See http://go/tabindex for more info.
 * @param {Element} element Element whose tab index is to be changed.
 * @param {boolean} enable Whether to set or remove a tab index on the element
 *     that supports keyboard focus.
 */
goog.dom.DomHelper.prototype.setFocusableTabIndex =
    goog.dom.setFocusableTabIndex;


/**
 * Returns true if the element can be focused, i.e. it has a tab index that
 * allows it to receive keyboard focus (tabIndex >= 0), or it is a form element
 * that natively supports keyboard focus.
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element allows keyboard focus.
 */
goog.dom.DomHelper.prototype.isFocusable = goog.dom.isFocusable;


/**
 * Returns the text contents of the current node, without markup. New lines are
 * stripped and whitespace is collapsed, such that each character would be
 * visible.
 *
 * In browsers that support it, innerText is used.  Other browsers attempt to
 * simulate it via node traversal.  Line breaks are canonicalized in IE.
 *
 * @param {Node} node The node from which we are getting content.
 * @return {string} The text content.
 */
goog.dom.DomHelper.prototype.getTextContent = goog.dom.getTextContent;


/**
 * Returns the text length of the text contained in a node, without markup. This
 * is equivalent to the selection length if the node was selected, or the number
 * of cursor movements to traverse the node. Images & BRs take one space.  New
 * lines are ignored.
 *
 * @param {Node} node The node whose text content length is being calculated.
 * @return {number} The length of {@code node}'s text content.
 */
goog.dom.DomHelper.prototype.getNodeTextLength = goog.dom.getNodeTextLength;


/**
 * Returns the text offset of a node relative to one of its ancestors. The text
 * length is the same as the length calculated by
 * {@code goog.dom.getNodeTextLength}.
 *
 * @param {Node} node The node whose offset is being calculated.
 * @param {Node=} opt_offsetParent Defaults to the node's owner document's body.
 * @return {number} The text offset.
 */
goog.dom.DomHelper.prototype.getNodeTextOffset = goog.dom.getNodeTextOffset;


/**
 * Returns the node at a given offset in a parent node.  If an object is
 * provided for the optional third parameter, the node and the remainder of the
 * offset will stored as properties of this object.
 * @param {Node} parent The parent node.
 * @param {number} offset The offset into the parent node.
 * @param {Object=} opt_result Object to be used to store the return value. The
 *     return value will be stored in the form {node: Node, remainder: number}
 *     if this object is provided.
 * @return {Node} The node at the given offset.
 */
goog.dom.DomHelper.prototype.getNodeAtOffset = goog.dom.getNodeAtOffset;


/**
 * Returns true if the object is a {@code NodeList}.  To qualify as a NodeList,
 * the object must have a numeric length property and an item function (which
 * has type 'string' on IE for some reason).
 * @param {Object} val Object to test.
 * @return {boolean} Whether the object is a NodeList.
 */
goog.dom.DomHelper.prototype.isNodeList = goog.dom.isNodeList;


/**
 * Walks up the DOM hierarchy returning the first ancestor that has the passed
 * tag name and/or class name. If the passed element matches the specified
 * criteria, the element itself is returned.
 * @param {Node} element The DOM node to start with.
 * @param {?(goog.dom.TagName|string)=} opt_tag The tag name to match (or
 *     null/undefined to match only based on class name).
 * @param {?string=} opt_class The class name to match (or null/undefined to
 *     match only based on tag name).
 * @return {Element} The first ancestor that matches the passed criteria, or
 *     null if no match is found.
 */
goog.dom.DomHelper.prototype.getAncestorByTagNameAndClass =
    goog.dom.getAncestorByTagNameAndClass;


/**
 * Walks up the DOM hierarchy returning the first ancestor that has the passed
 * class name. If the passed element matches the specified criteria, the
 * element itself is returned.
 * @param {Node} element The DOM node to start with.
 * @param {string} class The class name to match.
 * @return {Element} The first ancestor that matches the passed criteria, or
 *     null if none match.
 */
goog.dom.DomHelper.prototype.getAncestorByClass =
    goog.dom.getAncestorByClass;


/**
 * Walks up the DOM hierarchy returning the first ancestor that passes the
 * matcher function.
 * @param {Node} element The DOM node to start with.
 * @param {function(Node) : boolean} matcher A function that returns true if the
 *     passed node matches the desired criteria.
 * @param {boolean=} opt_includeNode If true, the node itself is included in
 *     the search (the first call to the matcher will pass startElement as
 *     the node to test).
 * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the
 *     dom.
 * @return {Node} DOM node that matched the matcher, or null if there was
 *     no match.
 */
goog.dom.DomHelper.prototype.getAncestor = goog.dom.getAncestor;

// Input 20
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview Node utilities.
 */

goog.provide('wgxpath.Node');

goog.require('goog.array');
goog.require('goog.dom.NodeType');
goog.require('goog.userAgent');
goog.require('wgxpath.IEAttrWrapper');
goog.require('wgxpath.userAgent');


/** @typedef {!(Node|wgxpath.IEAttrWrapper)} */
wgxpath.Node = {};


/**
 * Returns whether two nodes are equal.
 *
 * @param {wgxpath.Node} a The first node.
 * @param {wgxpath.Node} b The second node.
 * @return {boolean} Whether the nodes are equal.
 */
wgxpath.Node.equal = function (a, b) {
    return (a == b) || (a instanceof wgxpath.IEAttrWrapper &&
        b instanceof wgxpath.IEAttrWrapper && a.getNode() ==
        b.getNode());
};


/**
 * Returns the string-value of the required type from a node.
 *
 * @param {!wgxpath.Node} node The node to get value from.
 * @return {string} The value required.
 */
wgxpath.Node.getValueAsString = function (node) {
    var t = null, type = node.nodeType;
    // Old IE title problem.
    var needTitleFix = function (node) {
        return wgxpath.userAgent.IE_DOC_PRE_9 &&
            node.nodeName.toLowerCase() == 'title';
    };
    // goog.dom.getTextContent doesn't seem to work
    if (type == goog.dom.NodeType.ELEMENT) {
        t = node.textContent;
        t = (t == undefined || t == null) ? node.innerText : t;
        t = (t == undefined || t == null) ? '' : t;
    }
    if (typeof t != 'string') {
        if (needTitleFix(node) && type == goog.dom.NodeType.ELEMENT) {
            t = node.text;
        } else if (type == goog.dom.NodeType.DOCUMENT ||
            type == goog.dom.NodeType.ELEMENT) {
            node = (type == goog.dom.NodeType.DOCUMENT) ?
                node.documentElement : node.firstChild;
            var i = 0, stack = [];
            for (t = ''; node;) {
                do {
                    if (node.nodeType != goog.dom.NodeType.ELEMENT) {
                        t += node.nodeValue;
                    }
                    if (needTitleFix(node)) {
                        t += node.text;
                    }
                    stack[i++] = node; // push
                } while (node = node.firstChild);
                while (i && !(node = stack[--i].nextSibling)) {
                }
            }
        } else {
            t = node.nodeValue;
        }
    }
    return '' + t;
};


/**
 * Returns the string-value of the required type from a node, casted to number.
 *
 * @param {!wgxpath.Node} node The node to get value from.
 * @return {number} The value required.
 */
wgxpath.Node.getValueAsNumber = function (node) {
    return +wgxpath.Node.getValueAsString(node);
};


/**
 * Returns the string-value of the required type from a node, casted to boolean.
 *
 * @param {!wgxpath.Node} node The node to get value from.
 * @return {boolean} The value required.
 */
wgxpath.Node.getValueAsBool = function (node) {
    return !!wgxpath.Node.getValueAsString(node);
};


/**
 * Returns if the attribute matches the given value.
 *
 * @param {!wgxpath.Node} node The node to get value from.
 * @param {?string} name The attribute name to match, if any.
 * @param {?string} value The attribute value to match, if any.
 * @return {boolean} Whether the node matches the attribute, if any.
 */
wgxpath.Node.attrMatches = function (node, name, value) {
    // No attribute.
    if (goog.isNull(name)) {
        return true;
    }
    // TODO(user): If possible, figure out why this throws an exception in some
    // cases on IE < 9.
    try {
        if (!node.getAttribute) {
            return false;
        }
    } catch (e) {
        return false;
    }
    if (wgxpath.userAgent.IE_DOC_PRE_8 && name == 'class') {
        name = 'className';
    }
    return value == null ? !!node.getAttribute(name) :
        (node.getAttribute(name, 2) == value);
};


/**
 * Returns the descendants of a node.
 *
 * @param {!wgxpath.NodeTest} test A NodeTest for matching nodes.
 * @param {!wgxpath.Node} node The node to get descendants from.
 * @param {?string=} opt_attrName The attribute name to match, if any.
 * @param {?string=} opt_attrValue The attribute value to match, if any.
 * @param {!wgxpath.NodeSet=} opt_nodeset The node set to add descendants to.
 * @return {!wgxpath.NodeSet} The nodeset with descendants.
 */
wgxpath.Node.getDescendantNodes = function (test, node, opt_attrName, opt_attrValue, opt_nodeset) {
    var nodeset = opt_nodeset || new wgxpath.NodeSet();
    var func = wgxpath.userAgent.IE_DOC_PRE_9 ?
        wgxpath.Node.getDescendantNodesIEPre9_ :
        wgxpath.Node.getDescendantNodesGeneric_;
    var attrName = goog.isString(opt_attrName) ? opt_attrName : null;
    var attrValue = goog.isString(opt_attrValue) ? opt_attrValue : null;
    return func.call(null, test, node, attrName, attrValue, nodeset);
};


/**
 * Returns the descendants of a node for IE.
 *
 * @private
 * @param {!wgxpath.NodeTest} test A NodeTest for matching nodes.
 * @param {!wgxpath.Node} node The node to get descendants from.
 * @param {?string} attrName The attribute name to match, if any.
 * @param {?string} attrValue The attribute value to match, if any.
 * @param {!wgxpath.NodeSet} nodeset The node set to add descendants to.
 * @return {!wgxpath.NodeSet} The nodeset with descendants.
 */
wgxpath.Node.getDescendantNodesIEPre9_ = function (test, node, attrName, attrValue, nodeset) {
    if (wgxpath.Node.doesNeedSpecialHandlingIEPre9_(test, attrName)) {
        var descendants = node.all;
        if (!descendants) {
            return nodeset;
        }
        var name = wgxpath.Node.getNameFromTestIEPre9_(test);
        // all.tags not working.
        if (name != '*') {
            descendants = node.getElementsByTagName(name);
            if (!descendants) {
                return nodeset;
            }
        }
        if (attrName) {
            /**
             * The length property of the "all" collection is overwritten
             * if there exists an element with id="length", therefore we
             * have to iterate without knowing the length.
             */
            var result = [];
            var i = 0;
            while (node = descendants[i++]) {
                if (wgxpath.Node.attrMatches(node, attrName, attrValue)) {
                    result.push(node);
                }
            }
            descendants = result;
        }
        var i = 0;
        while (node = descendants[i++]) {
            if (name != '*' || node.tagName != '!') {
                nodeset.add(node);
            }
        }
        return nodeset;
    }
    wgxpath.Node.doRecursiveAttrMatch_(test, node, attrName,
        attrValue, nodeset);
    return nodeset;
};


/**
 * Returns the descendants of a node for browsers other than IE.
 *
 * @private
 * @param {!wgxpath.NodeTest} test A NodeTest for matching nodes.
 * @param {!wgxpath.Node} node The node to get descendants from.
 * @param {?string} attrName The attribute name to match, if any.
 * @param {?string} attrValue The attribute value to match, if any.
 * @param {!wgxpath.NodeSet} nodeset The node set to add descendants to.
 * @return {!wgxpath.NodeSet} The nodeset with descendants.
 */
wgxpath.Node.getDescendantNodesGeneric_ = function (test, node, attrName, attrValue, nodeset) {
    if (node.getElementsByName && attrValue && attrName == 'name' && !goog.userAgent.IE) {
        var nodes = node.getElementsByName(attrValue);
        goog.array.forEach(nodes, function (node) {
            if (test.matches(node)) {
                nodeset.add(node);
            }
        });
    } else if (node.getElementsByClassName && attrValue && attrName == 'class') {
        var nodes = node.getElementsByClassName(attrValue);
        goog.array.forEach(nodes, function (node) {
            if (node.className == attrValue && test.matches(node)) {
                nodeset.add(node);
            }
        });
    } else if (test instanceof wgxpath.KindTest) {
        wgxpath.Node.doRecursiveAttrMatch_(test, node, attrName,
            attrValue, nodeset);
    } else if (node.getElementsByTagName) {
        var nodes = node.getElementsByTagName(test.getName());
        goog.array.forEach(nodes, function (node) {
            if (wgxpath.Node.attrMatches(node, attrName, attrValue)) {
                nodeset.add(node);
            }
        });
    }
    return nodeset;
};


/**
 * Returns the child nodes of a node.
 *
 * @param {!wgxpath.NodeTest} test A NodeTest for matching nodes.
 * @param {!wgxpath.Node} node The node to get child nodes from.
 * @param {?string=} opt_attrName The attribute name to match, if any.
 * @param {?string=} opt_attrValue The attribute value to match, if any.
 * @param {!wgxpath.NodeSet=} opt_nodeset The node set to add child nodes to.
 * @return {!wgxpath.NodeSet} The nodeset with child nodes.
 */
wgxpath.Node.getChildNodes = function (test, node, opt_attrName, opt_attrValue, opt_nodeset) {
    var nodeset = opt_nodeset || new wgxpath.NodeSet();
    var func = wgxpath.userAgent.IE_DOC_PRE_9 ?
        wgxpath.Node.getChildNodesIEPre9_ : wgxpath.Node.getChildNodesGeneric_;
    var attrName = goog.isString(opt_attrName) ? opt_attrName : null;
    var attrValue = goog.isString(opt_attrValue) ? opt_attrValue : null;
    return func.call(null, test, node, attrName, attrValue, nodeset);
};


/**
 * Returns the child nodes of a node for IE browsers.
 *
 * @private
 * @param {!wgxpath.NodeTest} test A NodeTest for matching nodes.
 * @param {!wgxpath.Node} node The node to get child nodes from.
 * @param {?string} attrName The attribute name to match, if any.
 * @param {?string} attrValue The attribute value to match, if any.
 * @param {!wgxpath.NodeSet} nodeset The node set to add child nodes to.
 * @return {!wgxpath.NodeSet} The nodeset with child nodes.
 */
wgxpath.Node.getChildNodesIEPre9_ = function (test, node, attrName, attrValue, nodeset) {
    var children;
    if (wgxpath.Node.doesNeedSpecialHandlingIEPre9_(test, attrName) &&
        (children = node.childNodes)) { // node.children seems buggy.
        var name = wgxpath.Node.getNameFromTestIEPre9_(test);
        if (name != '*') {
            //children = children.tags(name); // children.tags seems buggy.
            children = goog.array.filter(children, function (child) {
                return child.tagName && child.tagName.toLowerCase() == name;
            });
            if (!children) {
                return nodeset;
            }
        }
        if (attrName) {
            // TODO(user): See if an optimization is possible.
            children = goog.array.filter(children, function (n) {
                return wgxpath.Node.attrMatches(n, attrName, attrValue);
            });
        }
        goog.array.forEach(children, function (node) {
            if (name != '*' || node.tagName != '!' && !(name == '*' && node.nodeType != goog.dom.NodeType.ELEMENT)) {
                nodeset.add(node);
            }
        });
        return nodeset;
    }
    return wgxpath.Node.getChildNodesGeneric_(test, node, attrName,
        attrValue, nodeset);
};


/**
 * Returns the child nodes of a node genericly.
 *
 * @private
 * @param {!wgxpath.NodeTest} test A NodeTest for matching nodes.
 * @param {!wgxpath.Node} node The node to get child nodes from.
 * @param {?string} attrName The attribute name to match, if any.
 * @param {?string} attrValue The attribute value to match, if any.
 * @param {!wgxpath.NodeSet} nodeset The node set to add child nodes to.
 * @return {!wgxpath.NodeSet} The nodeset with child nodes.
 */
wgxpath.Node.getChildNodesGeneric_ = function (test, node, attrName, attrValue, nodeset) {
    for (var current = node.firstChild; current; current = current.nextSibling) {
        if (wgxpath.Node.attrMatches(current, attrName, attrValue)) {
            if (test.matches(current)) {
                nodeset.add(current);
            }
        }
    }
    return nodeset;
};


/**
 * Returns whether a getting descendants/children call
 * needs special handling on IE browsers.
 *
 * @private
 * @param {!wgxpath.NodeTest} test A NodeTest for matching nodes.
 * @param {!wgxpath.Node} node The root node to start the recursive call on.
 * @param {?string} attrName The attribute name to match, if any.
 * @param {?string} attrValue The attribute value to match, if any.
 * @param {!wgxpath.NodeSet} nodeset The NodeSet to add nodes to.
 */
wgxpath.Node.doRecursiveAttrMatch_ = function (test, node, attrName, attrValue, nodeset) {
    for (var n = node.firstChild; n; n = n.nextSibling) {
        if (wgxpath.Node.attrMatches(n, attrName, attrValue) &&
            test.matches(n)) {
            nodeset.add(n);
        }
        wgxpath.Node.doRecursiveAttrMatch_(test, n, attrName,
            attrValue, nodeset);
    }
};


/**
 * Returns whether a getting descendants/children call
 * needs special handling on IE browsers.
 *
 * @private
 * @param {!wgxpath.NodeTest} test A NodeTest for matching nodes.
 * @param {?string} attrName The attribute name to match, if any.
 * @return {boolean} Whether the call needs special handling.
 */
wgxpath.Node.doesNeedSpecialHandlingIEPre9_ = function (test, attrName) {
    return test instanceof wgxpath.NameTest ||
        test.getType() == goog.dom.NodeType.COMMENT ||
        (!!attrName && goog.isNull(test.getType()));
};


/**
 * Returns a fixed name of a NodeTest for IE browsers.
 *
 * @private
 * @param {!wgxpath.NodeTest} test A NodeTest.
 * @return {string} The name of the NodeTest.
 */
wgxpath.Node.getNameFromTestIEPre9_ = function (test) {
    if (test instanceof wgxpath.KindTest) {
        if (test.getType() == goog.dom.NodeType.COMMENT) {
            return '!';
        } else if (goog.isNull(test.getType())) {
            return '*';
        }
    }
    return test.getName();
};

// Input 21
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview Context information about nodes in their nodeset.
 */

goog.provide('wgxpath.NodeSet');

goog.require('goog.dom');
goog.require('wgxpath.Node');


/**
 * A set of nodes sorted by their prefix order in the document.
 *
 * @constructor
 */
wgxpath.NodeSet = function () {
    // In violation of standard Closure practice, we initialize properties to
    // immutable constants in the constructor instead of on the prototype,
    // because we have empirically measured better performance by doing so.

    /**
     * A pointer to the first node in the linked list.
     *
     * @private
     * @type {wgxpath.NodeSet.Entry_}
     */
    this.first_ = null;

    /**
     * A pointer to the last node in the linked list.
     *
     * @private
     * @type {wgxpath.NodeSet.Entry_}
     */
    this.last_ = null;

    /**
     * Length of the linked list.
     *
     * @private
     * @type {number}
     */
    this.length_ = 0;
};


/**
 * A entry for a node in a linked list
 *
 * @param {!wgxpath.Node} node The node to be added.
 * @constructor
 * @private
 */
wgxpath.NodeSet.Entry_ = function (node) {
    // In violation of standard Closure practice, we initialize properties to
    // immutable constants in the constructor instead of on the prototype,
    // because we have empirically measured better performance by doing so.

    /**
     * @type {!wgxpath.Node}
     */
    this.node = node;

    /**
     * @type {wgxpath.NodeSet.Entry_}
     */
    this.prev = null;

    /**
     * @type {wgxpath.NodeSet.Entry_}
     */
    this.next = null;
};


/**
 * Merges two nodesets, removing duplicates. This function may modify both
 * nodesets, and will return a reference to one of the two.
 *
 * <p> Note: We assume that the two nodesets are already sorted in DOM order.
 *
 * @param {!wgxpath.NodeSet} a The first nodeset.
 * @param {!wgxpath.NodeSet} b The second nodeset.
 * @return {!wgxpath.NodeSet} The merged nodeset.
 */
wgxpath.NodeSet.merge = function (a, b) {
    if (!a.first_) {
        return b;
    } else if (!b.first_) {
        return a;
    }
    var aCurr = a.first_;
    var bCurr = b.first_;
    var merged = a, tail = null, next = null, length = 0;
    while (aCurr && bCurr) {
        if (wgxpath.Node.equal(aCurr.node, bCurr.node)) {
            next = aCurr;
            aCurr = aCurr.next;
            bCurr = bCurr.next;
        } else {
            var compareResult = goog.dom.compareNodeOrder(
                /** @type {!Node} */ (aCurr.node),
                /** @type {!Node} */ (bCurr.node));
            if (compareResult > 0) {
                next = bCurr;
                bCurr = bCurr.next;
            } else {
                next = aCurr;
                aCurr = aCurr.next;
            }
        }
        next.prev = tail;
        if (tail) {
            tail.next = next;
        } else {
            merged.first_ = next;
        }
        tail = next;
        length++;
    }
    next = aCurr || bCurr;
    while (next) {
        next.prev = tail;
        tail.next = next;
        tail = next;
        length++;
        next = next.next;
    }
    merged.last_ = tail;
    merged.length_ = length;
    return merged;
};


/**
 * Prepends a node to this nodeset.
 *
 * @param {!wgxpath.Node} node The node to be added.
 */
wgxpath.NodeSet.prototype.unshift = function (node) {
    var entry = new wgxpath.NodeSet.Entry_(node);
    entry.next = this.first_;
    if (!this.last_) {
        this.first_ = this.last_ = entry;
    } else {
        this.first_.prev = entry;
    }
    this.first_ = entry;
    this.length_++;
};


/**
 * Adds a node to this nodeset.
 *
 * @param {!wgxpath.Node} node The node to be added.
 */
wgxpath.NodeSet.prototype.add = function (node) {
    var entry = new wgxpath.NodeSet.Entry_(node);
    entry.prev = this.last_;
    if (!this.first_) {
        this.first_ = this.last_ = entry;
    } else {
        this.last_.next = entry;
    }
    this.last_ = entry;
    this.length_++;
};


/**
 * Returns the first node of the nodeset.
 *
 * @return {?wgxpath.Node} The first node of the nodeset
 if the nodeset is non-empty;
 *     otherwise null.
 */
wgxpath.NodeSet.prototype.getFirst = function () {
    var first = this.first_;
    if (first) {
        return first.node;
    } else {
        return null;
    }
};


/**
 * Return the length of this nodeset.
 *
 * @return {number} The length of the nodeset.
 */
wgxpath.NodeSet.prototype.getLength = function () {
    return this.length_;
};


/**
 * Returns the string representation of this nodeset.
 *
 * @return {string} The string representation of this nodeset.
 */
wgxpath.NodeSet.prototype.string = function () {
    var value = '';
    var iterator = this.iterator();
    for (var node = iterator.next(); node; node = iterator.next()) {
        value += wgxpath.Node.getValueAsString(node);
    }
    return value;
};


/**
 * Returns the number representation of this nodeset.
 *
 * @return {number} The number representation of this nodeset.
 */
wgxpath.NodeSet.prototype.number = function () {
    return +this.string();
};


/**
 * Returns an iterator over this nodeset. Once this iterator is made, DO NOT
 *     add to this nodeset until the iterator is done.
 *
 * @param {boolean=} opt_reverse Whether to iterate right to left or vice versa.
 * @return {!wgxpath.NodeSet.Iterator} An iterator over the nodes.
 */
wgxpath.NodeSet.prototype.iterator = function (opt_reverse) {
    return new wgxpath.NodeSet.Iterator(this, !!opt_reverse);
};


/**
 * An iterator over the nodes of this nodeset.
 *
 * @param {!wgxpath.NodeSet} nodeset The nodeset to be iterated over.
 * @param {boolean} reverse Whether to iterate in ascending or descending
 *     order.
 * @constructor
 */
wgxpath.NodeSet.Iterator = function (nodeset, reverse) {
    // In violation of standard Closure practice, we initialize properties to
    // immutable constants in the constructor instead of on the prototype,
    // because we have empirically measured better performance by doing so.

    /**
     * @type {!wgxpath.NodeSet}
     * @private
     */
    this.nodeset_ = nodeset;

    /**
     * @type {boolean}
     * @private
     */
    this.reverse_ = reverse;

    /**
     * @type {wgxpath.NodeSet.Entry_}
     * @private
     */
    this.current_ = reverse ? nodeset.last_ : nodeset.first_;

    /**
     * @type {wgxpath.NodeSet.Entry_}
     * @private
     */
    this.lastReturned_ = null;
};


/**
 * Returns the next value of the iteration or null if passes the end.
 *
 * @return {?wgxpath.Node} The next node from this iterator.
 */
wgxpath.NodeSet.Iterator.prototype.next = function () {
    var current = this.current_;
    if (current == null) {
        return null;
    } else {
        var lastReturned = this.lastReturned_ = current;
        if (this.reverse_) {
            this.current_ = current.prev;
        } else {
            this.current_ = current.next;
        }
        return lastReturned.node;
    }
};


/**
 * Deletes the last node that was returned from this iterator.
 */
wgxpath.NodeSet.Iterator.prototype.remove = function () {
    var nodeset = this.nodeset_;
    var entry = this.lastReturned_;
    if (!entry) {
        throw Error('Next must be called at least once before remove.');
    }
    var prev = entry.prev;
    var next = entry.next;

    // Modify the pointers of prev and next
    if (prev) {
        prev.next = next;
    } else {
        // If there was no prev node entry must've been first_, so update first_.
        nodeset.first_ = next;
    }
    if (next) {
        next.prev = prev;
    } else {
        // If there was no prev node entry must've been last_, so update last_.
        nodeset.last_ = prev;
    }
    nodeset.length_--;
    this.lastReturned_ = null;
};

// Input 22
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview Enumeration of internal data types.
 */

goog.provide('wgxpath.DataType');


/**
 * Enum for data types.
 * @enum {number}
 */
wgxpath.DataType = {
    VOID: 0,
    NUMBER: 1,
    BOOLEAN: 2,
    STRING: 3,
    NODESET: 4
};

// Input 23
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview An abstract class representing basic expressions.
 */

goog.provide('wgxpath.Expr');

goog.require('wgxpath.NodeSet');


/**
 * Abstract constructor for an XPath expression.
 *
 * @param {!wgxpath.DataType} dataType The data type that the expression
 *                                    will be evaluated into.
 * @constructor
 */
wgxpath.Expr = function (dataType) {

    /**
     * @type {!wgxpath.DataType}
     * @private
     */
    this.dataType_ = dataType;

    /**
     * @type {boolean}
     * @private
     */
    this.needContextPosition_ = false;

    /**
     * @type {boolean}
     * @private
     */
    this.needContextNode_ = false;

    /**
     * @type {?{name: string, valueExpr: wgxpath.Expr}}
     * @private
     */
    this.quickAttr_ = null;
};


/**
 * Indentation method for pretty printing.
 *
 * @param {*} obj The object to return a string representation for.
 * @return {string} The string prepended with newline and two spaces.
 */
wgxpath.Expr.indent = function (obj) {
    return '\n  ' + obj.toString().split('\n').join('\n  ');
};


/**
 * Evaluates the expression.
 *
 * @param {!wgxpath.Context} ctx The context to evaluate the expression in.
 * @return {!(string|boolean|number|wgxpath.NodeSet)} The evaluation result.
 */
wgxpath.Expr.prototype.evaluate = goog.abstractMethod;


/**
 * @override
 */
wgxpath.Expr.prototype.toString = goog.abstractMethod;


/**
 * Returns the data type of the expression.
 *
 * @return {!wgxpath.DataType} The data type that the expression
 *                            will be evaluated into.
 */
wgxpath.Expr.prototype.getDataType = function () {
    return this.dataType_;
};


/**
 * Returns whether the expression needs context position to be evaluated.
 *
 * @return {boolean} Whether context position is needed.
 */
wgxpath.Expr.prototype.doesNeedContextPosition = function () {
    return this.needContextPosition_;
};


/**
 * Sets whether the expression needs context position to be evaluated.
 *
 * @param {boolean} flag Whether context position is needed.
 */
wgxpath.Expr.prototype.setNeedContextPosition = function (flag) {
    this.needContextPosition_ = flag;
};


/**
 * Returns whether the expression needs context node to be evaluated.
 *
 * @return {boolean} Whether context node is needed.
 */
wgxpath.Expr.prototype.doesNeedContextNode = function () {
    return this.needContextNode_;
};


/**
 * Sets whether the expression needs context node to be evaluated.
 *
 * @param {boolean} flag Whether context node is needed.
 */
wgxpath.Expr.prototype.setNeedContextNode = function (flag) {
    this.needContextNode_ = flag;
};


/**
 * Returns the quick attribute information, if exists.
 *
 * @return {?{name: string, valueExpr: wgxpath.Expr}} The attribute
 *         information.
 */
wgxpath.Expr.prototype.getQuickAttr = function () {
    return this.quickAttr_;
};


/**
 * Sets up the quick attribute info.
 *
 * @param {?{name: string, valueExpr: wgxpath.Expr}} attrInfo The attribute
 *        information.
 */
wgxpath.Expr.prototype.setQuickAttr = function (attrInfo) {
    this.quickAttr_ = attrInfo;
};


/**
 * Evaluate and interpret the result as a number.
 *
 * @param {!wgxpath.Context} ctx The context to evaluate the expression in.
 * @return {number} The evaluated number value.
 */
wgxpath.Expr.prototype.asNumber = function (ctx) {
    var exrs = this.evaluate(ctx);
    if (exrs instanceof wgxpath.NodeSet) {
        return exrs.number();
    }
    return +exrs;
};


/**
 * Evaluate and interpret the result as a string.
 *
 * @param {!wgxpath.Context} ctx The context to evaluate the expression in.
 * @return {string} The evaluated string.
 */
wgxpath.Expr.prototype.asString = function (ctx) {
    var exrs = this.evaluate(ctx);
    if (exrs instanceof wgxpath.NodeSet) {
        return exrs.string();
    }
    return '' + exrs;
};


/**
 * Evaluate and interpret the result as a boolean value.
 *
 * @param {!wgxpath.Context} ctx The context to evaluate the expression in.
 * @return {boolean} The evaluated boolean value.
 */
wgxpath.Expr.prototype.asBool = function (ctx) {
    var exrs = this.evaluate(ctx);
    if (exrs instanceof wgxpath.NodeSet) {
        return !!exrs.getLength();
    }
    return !!exrs;
};

// Input 24
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview A class representing operations on binary expressions.
 */


goog.provide('wgxpath.BinaryExpr');

goog.require('wgxpath.DataType');
goog.require('wgxpath.Expr');
goog.require('wgxpath.Node');


/**
 * Constructor for BinaryExpr.
 *
 * @param {!wgxpath.BinaryExpr.Op} op A binary operator.
 * @param {!wgxpath.Expr} left The left hand side of the expression.
 * @param {!wgxpath.Expr} right The right hand side of the expression.
 * @extends {wgxpath.Expr}
 * @constructor
 */
wgxpath.BinaryExpr = function (op, left, right) {
    var opCast = /** @type {!wgxpath.BinaryExpr.Op_} */ (op);
    wgxpath.Expr.call(this, opCast.dataType_);

    /**
     * @private
     * @type {!wgxpath.BinaryExpr.Op_}
     */
    this.op_ = opCast;

    /**
     * @private
     * @type {!wgxpath.Expr}
     */
    this.left_ = left;

    /**
     * @private
     * @type {!wgxpath.Expr}
     */
    this.right_ = right;

    this.setNeedContextPosition(left.doesNeedContextPosition() ||
        right.doesNeedContextPosition());
    this.setNeedContextNode(left.doesNeedContextNode() ||
        right.doesNeedContextNode());

    // Optimize [@id="foo"] and [@name="bar"]
    if (this.op_ == wgxpath.BinaryExpr.Op.EQUAL) {
        if (!right.doesNeedContextNode() && !right.doesNeedContextPosition() &&
            right.getDataType() != wgxpath.DataType.NODESET &&
            right.getDataType() != wgxpath.DataType.VOID && left.getQuickAttr()) {
            this.setQuickAttr({
                name: left.getQuickAttr().name,
                valueExpr: right});
        } else if (!left.doesNeedContextNode() && !left.doesNeedContextPosition() &&
            left.getDataType() != wgxpath.DataType.NODESET &&
            left.getDataType() != wgxpath.DataType.VOID && right.getQuickAttr()) {
            this.setQuickAttr({
                name: right.getQuickAttr().name,
                valueExpr: left});
        }
    }
};
goog.inherits(wgxpath.BinaryExpr, wgxpath.Expr);


/**
 * Performs comparison between the left hand side and the right hand side.
 *
 * @private
 * @param {function((string|number|boolean), (string|number|boolean))}
 *        comp A comparison function that takes two parameters.
 * @param {!wgxpath.Expr} lhs The left hand side of the expression.
 * @param {!wgxpath.Expr} rhs The right hand side of the expression.
 * @param {!wgxpath.Context} ctx The context to perform the comparison in.
 * @param {boolean=} opt_equChk Whether the comparison checks for equality.
 * @return {boolean} True if comp returns true, false otherwise.
 */
wgxpath.BinaryExpr.compare_ = function (comp, lhs, rhs, ctx, opt_equChk) {
    var left = lhs.evaluate(ctx);
    var right = rhs.evaluate(ctx);
    var lIter, rIter, lNode, rNode;
    if (left instanceof wgxpath.NodeSet && right instanceof wgxpath.NodeSet) {
        lIter = left.iterator();
        for (lNode = lIter.next(); lNode; lNode = lIter.next()) {
            rIter = right.iterator();
            for (rNode = rIter.next(); rNode; rNode = rIter.next()) {
                if (comp(wgxpath.Node.getValueAsString(lNode),
                    wgxpath.Node.getValueAsString(rNode))) {
                    return true;
                }
            }
        }
        return false;
    }
    if ((left instanceof wgxpath.NodeSet) ||
        (right instanceof wgxpath.NodeSet)) {
        var nodeset, primitive;
        if ((left instanceof wgxpath.NodeSet)) {
            nodeset = left, primitive = right;
        } else {
            nodeset = right, primitive = left;
        }
        var iter = nodeset.iterator();
        var type = typeof primitive;
        for (var node = iter.next(); node; node = iter.next()) {
            var stringValue;
            switch (type) {
                case 'number':
                    stringValue = wgxpath.Node.getValueAsNumber(node);
                    break;
                case 'boolean':
                    stringValue = wgxpath.Node.getValueAsBool(node);
                    break;
                case 'string':
                    stringValue = wgxpath.Node.getValueAsString(node);
                    break;
                default:
                    throw Error('Illegal primitive type for comparison.');
            }
            if (comp(stringValue,
                /** @type {(string|number|boolean)} */ (primitive))) {
                return true;
            }
        }
        return false;
    }
    if (opt_equChk) {
        if (typeof left == 'boolean' || typeof right == 'boolean') {
            return comp(!!left, !!right);
        }
        if (typeof left == 'number' || typeof right == 'number') {
            return comp(+left, +right);
        }
        return comp(left, right);
    }
    return comp(+left, +right);
};


/**
 * @override
 * @return {(boolean|number)} The boolean or number result.
 */
wgxpath.BinaryExpr.prototype.evaluate = function (ctx) {
    return this.op_.evaluate_(this.left_, this.right_, ctx);
};


/**
 * @override
 */
wgxpath.BinaryExpr.prototype.toString = function () {
    var text = 'Binary Expression: ' + this.op_;
    text += wgxpath.Expr.indent(this.left_);
    text += wgxpath.Expr.indent(this.right_);
    return text;
};


/**
 * A binary operator.
 *
 * @param {string} opString The operator string.
 * @param {number} precedence The precedence when evaluated.
 * @param {!wgxpath.DataType} dataType The dataType to return when evaluated.
 * @param {function(!wgxpath.Expr, !wgxpath.Expr, !wgxpath.Context)}
 *         evaluate An evaluation function.
 * @constructor
 * @private
 */
wgxpath.BinaryExpr.Op_ = function (opString, precedence, dataType, evaluate) {

    /**
     * @private
     * @type {string}
     */
    this.opString_ = opString;

    /**
     * @private
     * @type {number}
     */
    this.precedence_ = precedence;

    /**
     * @private
     * @type {!wgxpath.DataType}
     */
    this.dataType_ = dataType;

    /**
     * @private
     * @type {function(!wgxpath.Expr, !wgxpath.Expr, !wgxpath.Context)}
     */
    this.evaluate_ = evaluate;
};


/**
 * Returns the precedence for the operator.
 *
 * @return {number} The precedence.
 */
wgxpath.BinaryExpr.Op_.prototype.getPrecedence = function () {
    return this.precedence_;
};


/**
 * @override
 */
wgxpath.BinaryExpr.Op_.prototype.toString = function () {
    return this.opString_;
};


/**
 * A mapping from operator strings to operator objects.
 *
 * @private
 * @type {!Object.<string, !wgxpath.BinaryExpr.Op>}
 */
wgxpath.BinaryExpr.stringToOpMap_ = {};


/**
 * Creates a binary operator.
 *
 * @param {string} opString The operator string.
 * @param {number} precedence The precedence when evaluated.
 * @param {!wgxpath.DataType} dataType The dataType to return when evaluated.
 * @param {function(!wgxpath.Expr, !wgxpath.Expr, !wgxpath.Context)}
 *         evaluate An evaluation function.
 * @return {!wgxpath.BinaryExpr.Op} A binary expression operator.
 * @private
 */
wgxpath.BinaryExpr.createOp_ = function (opString, precedence, dataType, evaluate) {
    if (opString in wgxpath.BinaryExpr.stringToOpMap_) {
        throw new Error('Binary operator already created: ' + opString);
    }
    // The upcast and then downcast for the JSCompiler.
    var op = /** @type {!Object} */ (new wgxpath.BinaryExpr.Op_(
        opString, precedence, dataType, evaluate));
    op = /** @type {!wgxpath.BinaryExpr.Op} */ (op);
    wgxpath.BinaryExpr.stringToOpMap_[op.toString()] = op;
    return op;
};


/**
 * Returns the operator with this opString or null if none.
 *
 * @param {string} opString The opString.
 * @return {!wgxpath.BinaryExpr.Op} The operator.
 */
wgxpath.BinaryExpr.getOp = function (opString) {
    return wgxpath.BinaryExpr.stringToOpMap_[opString] || null;
};


/**
 * Binary operator enumeration.
 *
 * @enum {{getPrecedence: function(): number}}
 */
wgxpath.BinaryExpr.Op = {
    DIV: wgxpath.BinaryExpr.createOp_('div', 6, wgxpath.DataType.NUMBER,
        function (left, right, ctx) {
            return left.asNumber(ctx) / right.asNumber(ctx);
        }),
    MOD: wgxpath.BinaryExpr.createOp_('mod', 6, wgxpath.DataType.NUMBER,
        function (left, right, ctx) {
            return left.asNumber(ctx) % right.asNumber(ctx);
        }),
    MULT: wgxpath.BinaryExpr.createOp_('*', 6, wgxpath.DataType.NUMBER,
        function (left, right, ctx) {
            return left.asNumber(ctx) * right.asNumber(ctx);
        }),
    PLUS: wgxpath.BinaryExpr.createOp_('+', 5, wgxpath.DataType.NUMBER,
        function (left, right, ctx) {
            return left.asNumber(ctx) + right.asNumber(ctx);
        }),
    MINUS: wgxpath.BinaryExpr.createOp_('-', 5, wgxpath.DataType.NUMBER,
        function (left, right, ctx) {
            return left.asNumber(ctx) - right.asNumber(ctx);
        }),
    LESSTHAN: wgxpath.BinaryExpr.createOp_('<', 4, wgxpath.DataType.BOOLEAN,
        function (left, right, ctx) {
            return wgxpath.BinaryExpr.compare_(function (a, b) {
                    return a < b;
                },
                left, right, ctx);
        }),
    GREATERTHAN: wgxpath.BinaryExpr.createOp_('>', 4, wgxpath.DataType.BOOLEAN,
        function (left, right, ctx) {
            return wgxpath.BinaryExpr.compare_(function (a, b) {
                    return a > b;
                },
                left, right, ctx);
        }),
    LESSTHAN_EQUAL: wgxpath.BinaryExpr.createOp_(
        '<=', 4, wgxpath.DataType.BOOLEAN,
        function (left, right, ctx) {
            return wgxpath.BinaryExpr.compare_(function (a, b) {
                    return a <= b;
                },
                left, right, ctx);
        }),
    GREATERTHAN_EQUAL: wgxpath.BinaryExpr.createOp_('>=', 4,
        wgxpath.DataType.BOOLEAN, function (left, right, ctx) {
            return wgxpath.BinaryExpr.compare_(function (a, b) {
                    return a >= b;
                },
                left, right, ctx);
        }),
    EQUAL: wgxpath.BinaryExpr.createOp_('=', 3, wgxpath.DataType.BOOLEAN,
        function (left, right, ctx) {
            return wgxpath.BinaryExpr.compare_(function (a, b) {
                    return a == b;
                },
                left, right, ctx, true);
        }),
    NOT_EQUAL: wgxpath.BinaryExpr.createOp_('!=', 3, wgxpath.DataType.BOOLEAN,
        function (left, right, ctx) {
            return wgxpath.BinaryExpr.compare_(function (a, b) {
                    return a != b
                },
                left, right, ctx, true);
        }),
    AND: wgxpath.BinaryExpr.createOp_('and', 2, wgxpath.DataType.BOOLEAN,
        function (left, right, ctx) {
            return left.asBool(ctx) && right.asBool(ctx);
        }),
    OR: wgxpath.BinaryExpr.createOp_('or', 1, wgxpath.DataType.BOOLEAN,
        function (left, right, ctx) {
            return left.asBool(ctx) || right.asBool(ctx);
        })
};

// Input 25
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview A class representing operations on filter expressions.
 */

goog.provide('wgxpath.FilterExpr');

goog.require('wgxpath.Expr');


/**
 * Constructor for FilterExpr.
 *
 * @param {!wgxpath.Expr} primary The primary expression.
 * @param {!wgxpath.Predicates} predicates The predicates.
 * @extends {wgxpath.Expr}
 * @constructor
 */
wgxpath.FilterExpr = function (primary, predicates) {
    if (predicates.getLength() && primary.getDataType() !=
        wgxpath.DataType.NODESET) {
        throw Error('Primary expression must evaluate to nodeset ' +
            'if filter has predicate(s).');
    }
    wgxpath.Expr.call(this, primary.getDataType());

    /**
     * @type {!wgxpath.Expr}
     * @private
     */
    this.primary_ = primary;


    /**
     * @type {!wgxpath.Predicates}
     * @private
     */
    this.predicates_ = predicates;

    this.setNeedContextPosition(primary.doesNeedContextPosition());
    this.setNeedContextNode(primary.doesNeedContextNode());
};
goog.inherits(wgxpath.FilterExpr, wgxpath.Expr);


/**
 * @override
 * @return {!wgxpath.NodeSet} The nodeset result.
 */
wgxpath.FilterExpr.prototype.evaluate = function (ctx) {
    var result = this.primary_.evaluate(ctx);
    return this.predicates_.evaluatePredicates(
        /** @type {!wgxpath.NodeSet} */ (result));
};


/**
 * @override
 */
wgxpath.FilterExpr.prototype.toString = function () {
    var text = 'Filter:';
    text += wgxpath.Expr.indent(this.primary_);
    text += wgxpath.Expr.indent(this.predicates_);
    return text;
};

// Input 26
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview A function call expression.
 */

goog.provide('wgxpath.FunctionCall');

goog.require('goog.array');
goog.require('goog.dom');
goog.require('goog.dom.NodeType');
goog.require('goog.string');
goog.require('wgxpath.Expr');
goog.require('wgxpath.Node');
goog.require('wgxpath.NodeSet');
goog.require('wgxpath.userAgent');


/**
 * A function call expression.
 *
 * @constructor
 * @extends {wgxpath.Expr}
 * @param {!wgxpath.FunctionCall.Func} func Function.
 * @param {!Array.<!wgxpath.Expr>} args Arguments to the function.
 */
wgxpath.FunctionCall = function (func, args) {
    // Check the provided arguments match the function parameters.
    if (args.length < func.minArgs_) {
        throw new Error('Function ' + func.name_ + ' expects at least' +
            func.minArgs_ + ' arguments, ' + args.length + ' given');
    }
    if (!goog.isNull(func.maxArgs_) && args.length > func.maxArgs_) {
        throw new Error('Function ' + func.name_ + ' expects at most ' +
            func.maxArgs_ + ' arguments, ' + args.length + ' given');
    }
    if (func.nodesetsRequired_) {
        goog.array.forEach(args, function (arg, i) {
            if (arg.getDataType() != wgxpath.DataType.NODESET) {
                throw new Error('Argument ' + i + ' to function ' + func.name_ +
                    ' is not of type Nodeset: ' + arg);
            }
        });
    }
    wgxpath.Expr.call(this, func.dataType_);

    /**
     * @type {!wgxpath.FunctionCall.Func}
     * @private
     */
    this.func_ = func;

    /**
     * @type {!Array.<!wgxpath.Expr>}
     * @private
     */
    this.args_ = args;

    this.setNeedContextPosition(func.needContextPosition_ ||
        goog.array.some(args, function (arg) {
            return arg.doesNeedContextPosition();
        }));
    this.setNeedContextNode(
        (func.needContextNodeWithoutArgs_ && !args.length) ||
            (func.needContextNodeWithArgs_ && !!args.length) ||
            goog.array.some(args, function (arg) {
                return arg.doesNeedContextNode();
            }));
};
goog.inherits(wgxpath.FunctionCall, wgxpath.Expr);


/**
 * @override
 */
wgxpath.FunctionCall.prototype.evaluate = function (ctx) {
    var result = this.func_.evaluate_.apply(null,
        goog.array.concat(ctx, this.args_));
    return /** @type {!(string|boolean|number|wgxpath.NodeSet)} */ (result);
};


/**
 * @override
 */
wgxpath.FunctionCall.prototype.toString = function () {
    var text = 'Function: ' + this.func_;
    if (this.args_.length) {
        var args = goog.array.reduce(this.args_, function (prev, curr) {
            return prev + wgxpath.Expr.indent(curr);
        }, 'Arguments:');
        text += wgxpath.Expr.indent(args);
    }
    return text;
};


/**
 * A function in a function call expression.
 *
 * @constructor
 * @param {string} name Name of the function.
 * @param {wgxpath.DataType} dataType Datatype of the function return value.
 * @param {boolean} needContextPosition Whether the function needs a context
 *     position.
 * @param {boolean} needContextNodeWithoutArgs Whether the function needs a
 *     context node when not given arguments.
 * @param {boolean} needContextNodeWithArgs Whether the function needs a context
 *     node when the function is given arguments.
 * @param {function(!wgxpath.Context, ...[!wgxpath.Expr]):*} evaluate
 *     Evaluates the function in a context with any number of expression
 *     arguments.
 * @param {number} minArgs Minimum number of arguments accepted by the function.
 * @param {?number=} opt_maxArgs Maximum number of arguments accepted by the
 *     function; null means there is no max; defaults to minArgs.
 * @param {boolean=} opt_nodesetsRequired Whether the args must be nodesets.
 * @private
 */
wgxpath.FunctionCall.Func_ = function (name, dataType, needContextPosition, needContextNodeWithoutArgs, needContextNodeWithArgs, evaluate, minArgs, opt_maxArgs, opt_nodesetsRequired) {

    /**
     * @type {string}
     * @private
     */
    this.name_ = name;

    /**
     * @type {wgxpath.DataType}
     * @private
     */
    this.dataType_ = dataType;

    /**
     * @type {boolean}
     * @private
     */
    this.needContextPosition_ = needContextPosition;

    /**
     * @type {boolean}
     * @private
     */
    this.needContextNodeWithoutArgs_ = needContextNodeWithoutArgs;

    /**
     * @type {boolean}
     * @private
     */
    this.needContextNodeWithArgs_ = needContextNodeWithArgs;

    /**
     * @type {function(!wgxpath.Context, ...[!wgxpath.Expr]):*}
     * @private
     */
    this.evaluate_ = evaluate;

    /**
     * @type {number}
     * @private
     */
    this.minArgs_ = minArgs;

    /**
     * @type {?number}
     * @private
     */
    this.maxArgs_ = goog.isDef(opt_maxArgs) ? opt_maxArgs : minArgs;

    /**
     * @type {boolean}
     * @private
     */
    this.nodesetsRequired_ = !!opt_nodesetsRequired;
};


/**
 * @override
 */
wgxpath.FunctionCall.Func_.prototype.toString = function () {
    return this.name_;
};


/**
 * A mapping from function names to Func objects.
 *
 * @private
 * @type {!Object.<string, !wgxpath.FunctionCall.Func>}
 */
wgxpath.FunctionCall.nameToFuncMap_ = {};


/**
 * Constructs a Func and maps its name to it.
 *
 * @param {string} name Name of the function.
 * @param {wgxpath.DataType} dataType Datatype of the function return value.
 * @param {boolean} needContextPosition Whether the function needs a context
 *     position.
 * @param {boolean} needContextNodeWithoutArgs Whether the function needs a
 *     context node when not given arguments.
 * @param {boolean} needContextNodeWithArgs Whether the function needs a context
 *     node when the function is given arguments.
 * @param {function(!wgxpath.Context, ...[!wgxpath.Expr]):*} evaluate
 *     Evaluates the function in a context with any number of expression
 *     arguments.
 * @param {number} minArgs Minimum number of arguments accepted by the function.
 * @param {?number=} opt_maxArgs Maximum number of arguments accepted by the
 *     function; null means there is no max; defaults to minArgs.
 * @param {boolean=} opt_nodesetsRequired Whether the args must be nodesets.
 * @return {!wgxpath.FunctionCall.Func} The function created.
 * @private
 */
wgxpath.FunctionCall.createFunc_ = function (name, dataType, needContextPosition, needContextNodeWithoutArgs, needContextNodeWithArgs, evaluate, minArgs, opt_maxArgs, opt_nodesetsRequired) {
    if (name in wgxpath.FunctionCall.nameToFuncMap_) {
        throw new Error('Function already created: ' + name + '.');
    }
    var func = new wgxpath.FunctionCall.Func_(name, dataType,
        needContextPosition, needContextNodeWithoutArgs, needContextNodeWithArgs,
        evaluate, minArgs, opt_maxArgs, opt_nodesetsRequired);
    func = /** @type {!wgxpath.FunctionCall.Func} */ (func);
    wgxpath.FunctionCall.nameToFuncMap_[name] = func;
    return func;
};


/**
 * Returns the function object for this name.
 *
 * @param {string} name The function's name.
 * @return {wgxpath.FunctionCall.Func} The function object.
 */
wgxpath.FunctionCall.getFunc = function (name) {
    return wgxpath.FunctionCall.nameToFuncMap_[name] || null;
};


/**
 * An XPath function enumeration.
 *
 * <p>A list of XPath 1.0 functions:
 * http://www.w3.org/TR/xpath/#corelib
 *
 * @enum {!Object}
 */
wgxpath.FunctionCall.Func = {
    BOOLEAN: wgxpath.FunctionCall.createFunc_('boolean',
        wgxpath.DataType.BOOLEAN, false, false, false,
        function (ctx, expr) {
            return expr.asBool(ctx);
        }, 1),
    CEILING: wgxpath.FunctionCall.createFunc_('ceiling',
        wgxpath.DataType.NUMBER, false, false, false,
        function (ctx, expr) {
            return Math.ceil(expr.asNumber(ctx));
        }, 1),
    CONCAT: wgxpath.FunctionCall.createFunc_('concat',
        wgxpath.DataType.STRING, false, false, false,
        function (ctx, var_args) {
            if(arguments.length == 0) {
                return '';
            }
            var exprs = goog.array.slice(arguments, 1);
            return goog.array.reduce(exprs, function (prev, curr) {
                return prev + curr.asString(ctx);
            }, '');
        }, 0, null),
    CONTAINS: wgxpath.FunctionCall.createFunc_('contains',
        wgxpath.DataType.BOOLEAN, false, false, false,
        function (ctx, expr1, expr2) {
            return goog.string.contains(expr1.asString(ctx), expr2.asString(ctx));
        }, 2),
    COUNT: wgxpath.FunctionCall.createFunc_('count',
        wgxpath.DataType.NUMBER, false, false, false,
        function (ctx, expr) {
            return expr.evaluate(ctx).getLength();
        }, 1, 1, true),
    FALSE: wgxpath.FunctionCall.createFunc_('false',
        wgxpath.DataType.BOOLEAN, false, false, false,
        function (ctx) {
            return false;
        }, 0),
    FLOOR: wgxpath.FunctionCall.createFunc_('floor',
        wgxpath.DataType.NUMBER, false, false, false,
        function (ctx, expr) {
            return Math.floor(expr.asNumber(ctx));
        }, 1),
    ID: wgxpath.FunctionCall.createFunc_('id',
        wgxpath.DataType.NODESET, false, false, false,
        function (ctx, expr) {
            var ctxNode = ctx.getNode();
            var doc = ctxNode.nodeType == goog.dom.NodeType.DOCUMENT ? ctxNode :
                ctxNode.ownerDocument;
            var ids = expr.asString(ctx).split(/\s+/);
            var nsArray = [];
            goog.array.forEach(ids, function (id) {
                var elem = idSingle(id);
                if (elem && !goog.array.contains(nsArray, elem)) {
                    nsArray.push(elem);
                }
            });
            nsArray.sort(goog.dom.compareNodeOrder);
            var ns = new wgxpath.NodeSet();
            goog.array.forEach(nsArray, function (n) {
                ns.add(n);
            });
            return ns;

            function idSingle(id) {
                if (wgxpath.userAgent.IE_DOC_PRE_9) {
                    var allId = doc.all[id];
                    if (allId) {
                        if (allId.nodeType && id == allId.id) {
                            return allId;
                        } else if (allId.length) {
                            return goog.array.find(allId, function (elem) {
                                return id == elem.id;
                            });
                        }
                    }
                    return null;
                } else {
                    return doc.getElementById(id);
                }
            }
        }, 1),
    LANG: wgxpath.FunctionCall.createFunc_('lang',
        wgxpath.DataType.BOOLEAN, false, false, false,
        function (ctx, expr) {
            // TODO(user): Fully implement this.
            return false;
        }, 1),
    LAST: wgxpath.FunctionCall.createFunc_('last',
        wgxpath.DataType.NUMBER, true, false, false,
        function (ctx) {
            if (arguments.length != 1) {
                throw Error('Function last expects ()');
            }
            return ctx.getLast();
        }, 0),
    LOCAL_NAME: wgxpath.FunctionCall.createFunc_('local-name',
        wgxpath.DataType.STRING, false, true, false,
        function (ctx, opt_expr) {
            var node = opt_expr ? opt_expr.evaluate(ctx).getFirst() : ctx.getNode();
            return node ? node.nodeName.toLowerCase() : '';
        }, 0, 1, true),
    NAME: wgxpath.FunctionCall.createFunc_('name',
        wgxpath.DataType.STRING, false, true, false,
        function (ctx, opt_expr) {
            // TODO(user): Fully implement this.
            var node = opt_expr ? opt_expr.evaluate(ctx).getFirst() : ctx.getNode();
            return node ? node.nodeName.toLowerCase() : '';
        }, 0, 1, true),
    NAMESPACE_URI: wgxpath.FunctionCall.createFunc_('namespace-uri',
        wgxpath.DataType.STRING, true, false, false,
        function (ctx, opt_expr) {
            // TODO(user): Fully implement this.
            return '';
        }, 0, 1, true),
    NORMALIZE_SPACE: wgxpath.FunctionCall.createFunc_('normalize-space',
        wgxpath.DataType.STRING, false, true, false,
        function (ctx, opt_expr) {
            var str = opt_expr ? opt_expr.asString(ctx) :
                wgxpath.Node.getValueAsString(ctx.getNode());
            return goog.string.collapseWhitespace(str);
        }, 0, 1),
    NOT: wgxpath.FunctionCall.createFunc_('not',
        wgxpath.DataType.BOOLEAN, false, false, false,
        function (ctx, expr) {
            return !expr.asBool(ctx);
        }, 1),
    NUMBER: wgxpath.FunctionCall.createFunc_('number',
        wgxpath.DataType.NUMBER, false, true, false,
        function (ctx, opt_expr) {
            return opt_expr ? opt_expr.asNumber(ctx) :
                wgxpath.Node.getValueAsNumber(ctx.getNode());
        }, 0, 1),
    POSITION: wgxpath.FunctionCall.createFunc_('position',
        wgxpath.DataType.NUMBER, true, false, false,
        function (ctx) {
            return ctx.getPosition();
        }, 0),
    ROUND: wgxpath.FunctionCall.createFunc_('round',
        wgxpath.DataType.NUMBER, false, false, false,
        function (ctx, expr) {
            return Math.round(expr.asNumber(ctx));
        }, 1),
    STARTS_WITH: wgxpath.FunctionCall.createFunc_('starts-with',
        wgxpath.DataType.BOOLEAN, false, false, false,
        function (ctx, expr1, expr2) {
            return goog.string.startsWith(expr1.asString(ctx), expr2.asString(ctx));
        }, 2),
    STRING: wgxpath.FunctionCall.createFunc_(
        'string', wgxpath.DataType.STRING, false, true, false,
        function (ctx, opt_expr) {
            return opt_expr ? opt_expr.asString(ctx) :
                wgxpath.Node.getValueAsString(ctx.getNode());
        }, 0, 1),
    STRING_LENGTH: wgxpath.FunctionCall.createFunc_('string-length',
        wgxpath.DataType.NUMBER, false, true, false,
        function (ctx, opt_expr) {
            var str = opt_expr ? opt_expr.asString(ctx) :
                wgxpath.Node.getValueAsString(ctx.getNode());
            return str.length;
        }, 0, 1),
    SUBSTRING: wgxpath.FunctionCall.createFunc_('substring',
        wgxpath.DataType.STRING, false, false, false,
        function (ctx, expr1, expr2, opt_expr3) {
            var startRaw = expr2.asNumber(ctx);
            if (isNaN(startRaw) || startRaw == Infinity || startRaw == -Infinity) {
                return '';
            }
            var lengthRaw = opt_expr3 ? opt_expr3.asNumber(ctx) : Infinity;
            if (isNaN(lengthRaw) || lengthRaw === -Infinity) {
                return '';
            }

            // XPath indices are 1-based.
            var startInt = Math.round(startRaw) - 1;
            var start = Math.max(startInt, 0);
            var str = expr1.asString(ctx);

            if (lengthRaw == Infinity) {
                return str.substring(start);
            } else {
                var lengthInt = Math.round(lengthRaw);
                // Length is from startInt, not start!
                return str.substring(start, startInt + lengthInt);
            }
        }, 2, 3),
    SUBSTRING_AFTER: wgxpath.FunctionCall.createFunc_('substring-after',
        wgxpath.DataType.STRING, false, false, false,
        function (ctx, expr1, expr2) {
            var str1 = expr1.asString(ctx);
            var str2 = expr2.asString(ctx);
            var str2Index = str1.indexOf(str2);
            return str2Index == -1 ? '' : str1.substring(str2Index + str2.length);
        }, 2),
    SUBSTRING_BEFORE: wgxpath.FunctionCall.createFunc_('substring-before',
        wgxpath.DataType.STRING, false, false, false,
        function (ctx, expr1, expr2) {
            var str1 = expr1.asString(ctx);
            var str2 = expr2.asString(ctx);
            var str2Index = str1.indexOf(str2);
            return str2Index == -1 ? '' : str1.substring(0, str2Index);
        }, 2),
    SUM: wgxpath.FunctionCall.createFunc_('sum',
        wgxpath.DataType.NUMBER, false, false, false,
        function (ctx, expr) {
            var ns = expr.evaluate(ctx);
            var iter = ns.iterator();
            var prev = 0;
            for (var node = iter.next(); node; node = iter.next()) {
                prev += wgxpath.Node.getValueAsNumber(node);
            }
            return prev;
        }, 1, 1, true),
    TRANSLATE: wgxpath.FunctionCall.createFunc_('translate',
        wgxpath.DataType.STRING, false, false, false,
        function (ctx, expr1, expr2, expr3) {
            var str1 = expr1.asString(ctx);
            var str2 = expr2.asString(ctx);
            var str3 = expr3.asString(ctx);

            var map = [];
            for (var i = 0; i < str2.length; i++) {
                var ch = str2.charAt(i);
                if (!(ch in map)) {
                    // If i >= str3.length, charAt will return the empty string.
                    map[ch] = str3.charAt(i);
                }
            }

            var translated = '';
            for (var i = 0; i < str1.length; i++) {
                var ch = str1.charAt(i);
                translated += (ch in map) ? map[ch] : ch;
            }
            return translated;
        }, 3),
    TRUE: wgxpath.FunctionCall.createFunc_(
        'true', wgxpath.DataType.BOOLEAN, false, false, false,
        function (ctx) {
            return true;
        }, 0)
};

// Input 27
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview An interface for the NodeTest construct.
 */

goog.provide('wgxpath.NodeTest');


/**
 * The NodeTest interface to represent the NodeTest production
 * in the xpath grammar:
 * http://www.w3.org/TR/xpath-30/#prod-xpath30-NodeTest
 *
 * @interface
 */
wgxpath.NodeTest = function () {
};


/**
 * Tests if a node matches the stored characteristics.
 *
 * @param {wgxpath.Node} node The node to be tested.
 * @return {boolean} Whether the node passes the test.
 */
wgxpath.NodeTest.prototype.matches = goog.abstractMethod;


/**
 * Returns the name of the test.
 *
 * @return {string} The name, either nodename or type name.
 */
wgxpath.NodeTest.prototype.getName = goog.abstractMethod;


/**
 * @override
 */
wgxpath.NodeTest.prototype.toString = goog.abstractMethod;

// Input 28
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview A class implementing the xpath 1.0 subset of the
 *               KindTest construct.
 */

goog.provide('wgxpath.KindTest');

goog.require('goog.dom.NodeType');
goog.require('wgxpath.NodeTest');


/**
 * Constructs a subset of KindTest based on the xpath grammar:
 * http://www.w3.org/TR/xpath20/#prod-xpath-KindTest
 *
 * @param {string} typeName Type name to be tested.
 * @param {wgxpath.Literal=} opt_literal Optional literal for
 *        processing-instruction nodes.
 * @constructor
 * @implements {wgxpath.NodeTest}
 */
wgxpath.KindTest = function (typeName, opt_literal) {

    /**
     * @type {string}
     * @private
     */
    this.typeName_ = typeName;

    /**
     * @type {wgxpath.Literal}
     * @private
     */
    this.literal_ = goog.isDef(opt_literal) ? opt_literal : null;

    /**
     * @type {?goog.dom.NodeType}
     * @private
     */
    this.type_ = null;
    switch (typeName) {
        case 'comment':
            this.type_ = goog.dom.NodeType.COMMENT;
            break;
        case 'text':
            this.type_ = goog.dom.NodeType.TEXT;
            break;
        case 'processing-instruction':
            this.type_ = goog.dom.NodeType.PROCESSING_INSTRUCTION;
            break;
        case 'node':
            break;
        default:
            throw Error('Unexpected argument');
    }
};


/**
 * Checks if a type name is a valid KindTest parameter.
 *
 * @param {string} typeName The type name to be checked.
 * @return {boolean} Whether the type name is legal.
 */
wgxpath.KindTest.isValidType = function (typeName) {
    return typeName == 'comment' || typeName == 'text' ||
        typeName == 'processing-instruction' || typeName == 'node';
};


/**
 * @override
 */
wgxpath.KindTest.prototype.matches = function (node) {
    return goog.isNull(this.type_) || this.type_ == node.nodeType;
};


/**
 * Returns the type of the node.
 *
 * @return {?number} The type of the node, or null if any type.
 */
wgxpath.KindTest.prototype.getType = function () {
    return this.type_;
};


/**
 * @override
 */
wgxpath.KindTest.prototype.getName = function () {
    return this.typeName_;
};


/**
 * @override
 */
wgxpath.KindTest.prototype.toString = function () {
    var text = 'Kind Test: ' + this.typeName_;
    if (!goog.isNull(this.literal_)) {
        text += wgxpath.Expr.indent(this.literal_);
    }
    return text;
};

// Input 29
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview A class representing the string literals.
 */

goog.provide('wgxpath.Literal');

goog.require('wgxpath.Expr');


/**
 * Constructs a string literal expression.
 *
 * @param {string} text The text value of the literal.
 * @constructor
 * @extends {wgxpath.Expr}
 */
wgxpath.Literal = function (text) {
    wgxpath.Expr.call(this, wgxpath.DataType.STRING);

    /**
     * @type {string}
     * @private
     */
    this.text_ = text.substring(1, text.length - 1);
};
goog.inherits(wgxpath.Literal, wgxpath.Expr);


/**
 * @override
 * @return {string} The string result.
 */
wgxpath.Literal.prototype.evaluate = function (context) {
    return this.text_;
};


/**
 * @override
 */
wgxpath.Literal.prototype.toString = function () {
    return 'Literal: ' + this.text_;
};

// Input 30
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview A class implementing the NameTest construct.
 */

goog.provide('wgxpath.NameTest');

goog.require('goog.dom.NodeType');


/**
 * Constructs a NameTest based on the xpath grammar:
 * http://www.w3.org/TR/xpath/#NT-NameTest
 *
 * <p>If no namespace is provided, the default HTML namespace is used.
 *
 * @param {string} name Name to be tested.
 * @param {string=} opt_namespaceUri Namespace URI; defaults to HTML namespace.
 * @constructor
 * @implements {wgxpath.NodeTest}
 */
wgxpath.NameTest = function (name, opt_namespaceUri) {
    /**
     * @type {string}
     * @private
     */
    this.name_ = name.toLowerCase();

    /**
     * @type {string}
     * @private
     */
    this.namespaceUri_ = opt_namespaceUri ? opt_namespaceUri.toLowerCase() :
        wgxpath.NameTest.HTML_NAMESPACE_URI_;
};


/**
 * The default namespace URI for XHTML nodes.
 *
 * @const
 * @type {string}
 * @private
 */
wgxpath.NameTest.HTML_NAMESPACE_URI_ = 'http://www.w3.org/1999/xhtml';


/**
 * @override
 */
wgxpath.NameTest.prototype.matches = function (node) {
    var type = node.nodeType;
    if (type != goog.dom.NodeType.ELEMENT &&
        type != goog.dom.NodeType.ATTRIBUTE) {
        return false;
    }
    if (this.name_ != '*' && this.name_ != node.nodeName.toLowerCase()) {
        return false;
    } else {
        var namespaceUri = node.namespaceURI ? node.namespaceURI.toLowerCase() :
            wgxpath.NameTest.HTML_NAMESPACE_URI_;
        return this.namespaceUri_ == namespaceUri;
    }
};


/**
 * @override
 */
wgxpath.NameTest.prototype.getName = function () {
    return this.name_;
};


/**
 * Returns the namespace URI to be matched.
 *
 * @return {string} Namespace URI.
 */
wgxpath.NameTest.prototype.getNamespaceUri = function () {
    return this.namespaceUri_;
};


/**
 * @override
 */
wgxpath.NameTest.prototype.toString = function () {
    var prefix = this.namespaceUri_ == wgxpath.NameTest.HTML_NAMESPACE_URI_ ?
        '' : this.namespaceUri_ + ':';
    return 'Name Test: ' + prefix + this.name_;
};

// Input 31
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview A class representing number literals.
 */

goog.provide('wgxpath.Number');

goog.require('wgxpath.Expr');


/**
 * Constructs a number expression.
 *
 * @param {number} value The number value.
 * @constructor
 * @extends {wgxpath.Expr}
 */
wgxpath.Number = function (value) {
    wgxpath.Expr.call(this, wgxpath.DataType.NUMBER);

    /**
     * @type {number}
     * @private
     */
    this.value_ = value;
};
goog.inherits(wgxpath.Number, wgxpath.Expr);


/**
 * @override
 * @return {number} The number result.
 */
wgxpath.Number.prototype.evaluate = function (ctx) {
    return this.value_;
};


/**
 * @override
 */
wgxpath.Number.prototype.toString = function () {
    return 'Number: ' + this.value_;
};

// Input 32
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview An class representing operations on path expressions.
 */

goog.provide('wgxpath.PathExpr');


goog.require('goog.array');
goog.require('goog.dom.NodeType');
goog.require('wgxpath.DataType');
goog.require('wgxpath.Expr');
goog.require('wgxpath.NodeSet');


/**
 * Constructor for PathExpr.
 *
 * @param {!wgxpath.Expr} filter A filter expression.
 * @param {!Array.<!wgxpath.Step>} steps The steps in the location path.
 * @extends {wgxpath.Expr}
 * @constructor
 */
wgxpath.PathExpr = function (filter, steps) {
    wgxpath.Expr.call(this, filter.getDataType());

    /**
     * @type {!wgxpath.Expr}
     * @private
     */
    this.filter_ = filter;

    /**
     * @type {!Array.<!wgxpath.Step>}
     * @private
     */
    this.steps_ = steps;

    this.setNeedContextPosition(filter.doesNeedContextPosition());
    this.setNeedContextNode(filter.doesNeedContextNode());
    if (this.steps_.length == 1) {
        var firstStep = this.steps_[0];
        if (!firstStep.doesIncludeDescendants() &&
            firstStep.getAxis() == wgxpath.Step.Axis.ATTRIBUTE) {
            var test = firstStep.getTest();
            if (test.getName() != '*') {
                this.setQuickAttr({
                    name: test.getName(),
                    valueExpr: null
                });
            }
        }
    }
};
goog.inherits(wgxpath.PathExpr, wgxpath.Expr);


/**
 * Constructor for RootHelperExpr.
 *
 * @extends {wgxpath.Expr}
 * @constructor
 */
wgxpath.PathExpr.RootHelperExpr = function () {
    wgxpath.Expr.call(this, wgxpath.DataType.NODESET);
};
goog.inherits(wgxpath.PathExpr.RootHelperExpr, wgxpath.Expr);


/**
 * Evaluates the root-node helper expression.
 *
 * @param {!wgxpath.Context} ctx The context to evaluate the expression in.
 * @return {!wgxpath.NodeSet} The evaluation result.
 */
wgxpath.PathExpr.RootHelperExpr.prototype.evaluate = function (ctx) {
    var nodeset = new wgxpath.NodeSet();
    var node = ctx.getNode();
    if (node.nodeType == goog.dom.NodeType.DOCUMENT) {
        nodeset.add(node);
    } else {
        nodeset.add(/** @type {!Node} */ (node.ownerDocument));
    }
    return nodeset;
};


/**
 * @override
 */
wgxpath.PathExpr.RootHelperExpr.prototype.toString = function () {
    return 'Root Helper Expression';
};


/**
 * Constructor for ContextHelperExpr.
 *
 * @extends {wgxpath.Expr}
 * @constructor
 */
wgxpath.PathExpr.ContextHelperExpr = function () {
    wgxpath.Expr.call(this, wgxpath.DataType.NODESET);
};
goog.inherits(wgxpath.PathExpr.ContextHelperExpr, wgxpath.Expr);


/**
 * Evaluates the context-node helper expression.
 *
 * @param {!wgxpath.Context} ctx The context to evaluate the expression in.
 * @return {!wgxpath.NodeSet} The evaluation result.
 */
wgxpath.PathExpr.ContextHelperExpr.prototype.evaluate = function (ctx) {
    var nodeset = new wgxpath.NodeSet();
    nodeset.add(ctx.getNode());
    return nodeset;
};


/**
 * @override
 */
wgxpath.PathExpr.ContextHelperExpr.prototype.toString = function () {
    return 'Context Helper Expression';
};


/**
 * Returns whether the token is a valid PathExpr operator.
 *
 * @param {string} token The token to be checked.
 * @return {boolean} Whether the token is a valid operator.
 */
wgxpath.PathExpr.isValidOp = function (token) {
    return token == '/' || token == '//';
};


/**
 * @override
 * @return {!wgxpath.NodeSet} The nodeset result.
 */
wgxpath.PathExpr.prototype.evaluate = function (ctx) {
    var nodeset = this.filter_.evaluate(ctx);
    if (!(nodeset instanceof wgxpath.NodeSet)) {
        throw Error('Filter expression must evaluate to nodeset.');
    }
    var steps = this.steps_;
    for (var i = 0, l0 = steps.length; i < l0 && nodeset.getLength(); i++) {
        var step = steps[i];
        var reverse = step.getAxis().isReverse();
        var iter = nodeset.iterator(reverse);
        nodeset = null;
        var node, next;
        if (!step.doesNeedContextPosition() &&
            step.getAxis() == wgxpath.Step.Axis.FOLLOWING) {
            for (node = iter.next(); next = iter.next(); node = next) {
                if (node.contains && !node.contains(next)) {
                    break;
                } else {
                    if (!(next.compareDocumentPosition(/** @type {!Node} */ (node)) &
                        8)) {
                        break;
                    }
                }
            }
            nodeset = step.evaluate(new
                wgxpath.Context(/** @type {wgxpath.Node} */ (node)));
        } else if (!step.doesNeedContextPosition() &&
            step.getAxis() == wgxpath.Step.Axis.PRECEDING) {
            node = iter.next();
            nodeset = step.evaluate(new
                wgxpath.Context(/** @type {wgxpath.Node} */ (node)));
        } else {
            node = iter.next();
            nodeset = step.evaluate(new
                wgxpath.Context(/** @type {wgxpath.Node} */ (node)));
            while ((node = iter.next()) != null) {
                var result = step.evaluate(new
                    wgxpath.Context(/** @type {wgxpath.Node} */ (node)));
                nodeset = wgxpath.NodeSet.merge(nodeset, result);
            }
        }
    }
    return /** @type {!wgxpath.NodeSet} */ (nodeset);
};


/**
 * @override
 */
wgxpath.PathExpr.prototype.toString = function () {
    var text = 'Path Expression:';
    text += wgxpath.Expr.indent(this.filter_);
    if (this.steps_.length) {
        var steps = goog.array.reduce(this.steps_, function (prev, curr) {
            return prev + wgxpath.Expr.indent(curr);
        }, 'Steps:');
        text += wgxpath.Expr.indent(steps);
    }
    return text;
};

// Input 33
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview An abstract class representing expressions with predicates.
 *     baseExprWithPredictes are immutable objects that evaluate their
 *     predicates against nodesets and return the modified nodesets.
 *
 */


goog.provide('wgxpath.Predicates');

goog.require('goog.array');
goog.require('wgxpath.Context');
goog.require('wgxpath.Expr');


/**
 * An abstract class for expressions with predicates.
 *
 * @constructor
 * @param {!Array.<!wgxpath.Expr>} predicates The array of predicates.
 * @param {boolean=} opt_reverse Whether to iterate over the nodeset in reverse.
 */
wgxpath.Predicates = function (predicates, opt_reverse) {

    /**
     * List of predicates
     *
     * @private
     * @type {!Array.<!wgxpath.Expr>}
     */
    this.predicates_ = predicates;


    /**
     * Which direction to iterate over the predicates
     *
     * @private
     * @type {boolean}
     */
    this.reverse_ = !!opt_reverse;
};


/**
 * Evaluates the predicates against the given nodeset.
 *
 * @param {!wgxpath.NodeSet} nodeset The nodes against which to evaluate
 *     the predicates.
 * @param {number=} opt_start The index of the first predicate to evaluate,
 *     defaults to 0.
 * @return {!wgxpath.NodeSet} nodeset The filtered nodeset.
 */
wgxpath.Predicates.prototype.evaluatePredicates =
    function (nodeset, opt_start) {
        for (var i = opt_start || 0; i < this.predicates_.length; i++) {
            var predicate = this.predicates_[i];
            var iter = nodeset.iterator();
            var l = nodeset.getLength();
            var node;
            for (var j = 0; node = iter.next(); j++) {
                var position = this.reverse_ ? (l - j) : (j + 1);
                var exrs = predicate.evaluate(new
                    wgxpath.Context(/** @type {wgxpath.Node} */ (node), position, l));
                var keep;
                if (typeof exrs == 'number') {
                    keep = (position == exrs);
                } else if (typeof exrs == 'string' || typeof exrs == 'boolean') {
                    keep = !!exrs;
                } else if (exrs instanceof wgxpath.NodeSet) {
                    keep = (exrs.getLength() > 0);
                } else {
                    throw Error('Predicate.evaluate returned an unexpected type.');
                }
                if (!keep) {
                    iter.remove();
                }
            }
        }
        return nodeset;
    };


/**
 * Returns the quickAttr info.
 *
 * @return {?{name: string, valueExpr: wgxpath.Expr}}
 */
wgxpath.Predicates.prototype.getQuickAttr = function () {
    return this.predicates_.length > 0 ?
        this.predicates_[0].getQuickAttr() : null;
};


/**
 * Returns whether this set of predicates needs context position.
 *
 * @return {boolean} Whether something needs context position.
 */
wgxpath.Predicates.prototype.doesNeedContextPosition = function () {
    for (var i = 0; i < this.predicates_.length; i++) {
        var predicate = this.predicates_[i];
        if (predicate.doesNeedContextPosition() ||
            predicate.getDataType() == wgxpath.DataType.NUMBER ||
            predicate.getDataType() == wgxpath.DataType.VOID) {
            return true;
        }
    }
    return false;
};


/**
 * Returns the length of this set of predicates.
 *
 * @return {number} The number of expressions.
 */
wgxpath.Predicates.prototype.getLength = function () {
    return this.predicates_.length;
};


/**
 * Returns the set of predicates.
 *
 * @return {!Array.<!wgxpath.Expr>} The predicates.
 */
wgxpath.Predicates.prototype.getPredicates = function () {
    return this.predicates_;
};


/**
 * @override
 */
wgxpath.Predicates.prototype.toString = function () {
    return goog.array.reduce(this.predicates_, function (prev, curr) {
        return prev + wgxpath.Expr.indent(curr);
    }, 'Predicates:');
};

// Input 34
goog.provide('wgxpath.Step');

goog.require('goog.array');
goog.require('goog.dom.NodeType');
goog.require('wgxpath.DataType');
goog.require('wgxpath.Expr');
goog.require('wgxpath.KindTest');
goog.require('wgxpath.Node');
goog.require('wgxpath.Predicates');
goog.require('wgxpath.userAgent');


/**
 * Class for a step in a path expression
 * http://www.w3.org/TR/xpath20/#id-steps.
 *
 * @extends {wgxpath.Expr}
 * @constructor
 * @param {!wgxpath.Step.Axis} axis The axis for this Step.
 * @param {!wgxpath.NodeTest} test The test for this Step.
 * @param {!wgxpath.Predicates=} opt_predicates The predicates for this
 *     Step.
 * @param {boolean=} opt_descendants Whether descendants are to be included in
 *     this step ('//' vs '/').
 */
wgxpath.Step = function (axis, test, opt_predicates, opt_descendants) {
    var axisCast = /** @type {!wgxpath.Step.Axis_} */ (axis);
    wgxpath.Expr.call(this, wgxpath.DataType.NODESET);

    /**
     * @type {!wgxpath.Step.Axis_}
     * @private
     */
    this.axis_ = axisCast;


    /**
     * @type {!wgxpath.NodeTest}
     * @private
     */
    this.test_ = test;

    /**
     * @type {!wgxpath.Predicates}
     * @private
     */
    this.predicates_ = opt_predicates || new wgxpath.Predicates([]);


    /**
     * Whether decendants are included in this step
     *
     * @private
     * @type {boolean}
     */
    this.descendants_ = !!opt_descendants;

    var quickAttrInfo = this.predicates_.getQuickAttr();
    if (axis.supportsQuickAttr_ && quickAttrInfo) {
        var attrName = quickAttrInfo.name;
        attrName = wgxpath.userAgent.IE_DOC_PRE_9 ?
            attrName.toLowerCase() : attrName;
        var attrValueExpr = quickAttrInfo.valueExpr;
        this.setQuickAttr({
            name: attrName,
            valueExpr: attrValueExpr
        });
    }
    this.setNeedContextPosition(this.predicates_.doesNeedContextPosition());
};
goog.inherits(wgxpath.Step, wgxpath.Expr);


/**
 * @override
 * @return {!wgxpath.NodeSet} The nodeset result.
 */
wgxpath.Step.prototype.evaluate = function (ctx) {
    var node = ctx.getNode();
    var nodeset = null;
    var quickAttr = this.getQuickAttr();
    var attrName = null;
    var attrValue = null;
    var pstart = 0;
    if (quickAttr) {
        attrName = quickAttr.name;
        attrValue = quickAttr.valueExpr ?
            quickAttr.valueExpr.asString(ctx) : null;
        pstart = 1;
    }
    if (this.descendants_) {
        if (!this.doesNeedContextPosition() &&
            this.axis_ == wgxpath.Step.Axis.CHILD) {
            nodeset = wgxpath.Node.getDescendantNodes(this.test_, node,
                attrName, attrValue);
            nodeset = this.predicates_.evaluatePredicates(nodeset, pstart);
        } else {
            var step = new wgxpath.Step(wgxpath.Step.Axis.DESCENDANT_OR_SELF,
                new wgxpath.KindTest('node'));
            var iter = step.evaluate(ctx).iterator();
            var n = iter.next();
            if (!n) {
                nodeset = new wgxpath.NodeSet();
            } else {
                nodeset = this.evaluate_(/** @type {!wgxpath.Node} */ (n),
                    attrName, attrValue, pstart);
                while ((n = iter.next()) != null) {
                    nodeset = wgxpath.NodeSet.merge(nodeset,
                        this.evaluate_(/** @type {!wgxpath.Node} */ (n), attrName,
                            attrValue, pstart));
                }
            }
        }
    } else {
        nodeset = this.evaluate_(ctx.getNode(), attrName, attrValue, pstart);
    }
    return nodeset;
};


/**
 * Evaluates this step on the given context to a nodeset.
 *     (assumes this.descendants_ = false)
 *
 * @private
 * @param {!wgxpath.Node} node The context node.
 * @param {?string} attrName The name of the attribute.
 * @param {?string} attrValue The value of the attribute.
 * @param {number} pstart The first predicate to evaluate.
 * @return {!wgxpath.NodeSet} The nodeset from evaluating this Step.
 */
wgxpath.Step.prototype.evaluate_ = function (node, attrName, attrValue, pstart) {
    var nodeset = this.axis_.func_(this.test_, node, attrName, attrValue);
    nodeset = this.predicates_.evaluatePredicates(nodeset, pstart);
    return nodeset;
};


/**
 * Returns whether the step evaluation should include descendants.
 *
 * @return {boolean} Whether descendants are included.
 */
wgxpath.Step.prototype.doesIncludeDescendants = function () {
    return this.descendants_;
};


/**
 * Returns the step's axis.
 *
 * @return {!wgxpath.Step.Axis} The axis.
 */
wgxpath.Step.prototype.getAxis = function () {
    return /** @type {!wgxpath.Step.Axis} */ (this.axis_);
};


/**
 * Returns the test for this step.
 *
 * @return {!wgxpath.NodeTest} The test for this step.
 */
wgxpath.Step.prototype.getTest = function () {
    return this.test_;
};


/**
 * @override
 */
wgxpath.Step.prototype.toString = function () {
    var text = 'Step:';
    text += wgxpath.Expr.indent('Operator: ' + (this.descendants_ ? '//' : '/'));
    if (this.axis_.name_) {
        text += wgxpath.Expr.indent('Axis: ' + this.axis_);
    }
    text += wgxpath.Expr.indent(this.test_);
    if (this.predicates_.getLength()) {
        var predicates = goog.array.reduce(this.predicates_.getPredicates(),
            function (prev, curr) {
                return prev + wgxpath.Expr.indent(curr);
            }, 'Predicates:');
        text += wgxpath.Expr.indent(predicates);
    }
    return text;
};


/**
 * A step axis.
 *
 * @constructor
 * @param {string} name The axis name.
 * @param {function(!wgxpath.NodeTest, wgxpath.Node, ?string, ?string):
 *     !wgxpath.NodeSet} func The function for this axis.
 * @param {boolean} reverse Whether to iterate over the nodeset in reverse.
 * @param {boolean} supportsQuickAttr Whether quickAttr should be enabled for
 *     this axis.
 * @private
 */
wgxpath.Step.Axis_ = function (name, func, reverse, supportsQuickAttr) {

    /**
     * @private
     * @type {string}
     */
    this.name_ = name;

    /**
     * @private
     * @type {function(!wgxpath.NodeTest, wgxpath.Node, ?string, ?string):
   *     !wgxpath.NodeSet}
     */
    this.func_ = func;

    /**
     * @private
     * @type {boolean}
     */
    this.reverse_ = reverse;

    /**
     * @private
     * @type {boolean}
     */
    this.supportsQuickAttr_ = supportsQuickAttr;
};


/**
 * Returns whether the nodes in the step should be iterated over in reverse.
 *
 * @return {boolean} Whether the nodes should be iterated over in reverse.
 */
wgxpath.Step.Axis_.prototype.isReverse = function () {
    return this.reverse_;
};


/**
 * @override
 */
wgxpath.Step.Axis_.prototype.toString = function () {
    return this.name_;
};


/**
 * A map from axis name to Axis.
 *
 * @type {!Object.<string, !wgxpath.Step.Axis>}
 * @private
 */
wgxpath.Step.nameToAxisMap_ = {};


/**
 * Creates an axis and maps the axis's name to that axis.
 *
 * @param {string} name The axis name.
 * @param {function(!wgxpath.NodeTest, wgxpath.Node, ?string, ?string):
 *     !wgxpath.NodeSet} func The function for this axis.
 * @param {boolean} reverse Whether to iterate over nodesets in reverse.
 * @param {boolean=} opt_supportsQuickAttr Whether quickAttr can be enabled
 *     for this axis.
 * @return {!wgxpath.Step.Axis} The axis.
 * @private
 */
wgxpath.Step.createAxis_ =
    function (name, func, reverse, opt_supportsQuickAttr) {
        if (name in wgxpath.Step.nameToAxisMap_) {
            throw Error('Axis already created: ' + name);
        }
        // The upcast and then downcast for the JSCompiler.
        var axis = /** @type {!Object} */ (new wgxpath.Step.Axis_(
            name, func, reverse, !!opt_supportsQuickAttr));
        axis = /** @type {!wgxpath.Step.Axis} */ (axis);
        wgxpath.Step.nameToAxisMap_[name] = axis;
        return axis;
    };


/**
 * Returns the axis for this axisname or null if none.
 *
 * @param {string} name The axis name.
 * @return {wgxpath.Step.Axis} The axis.
 */
wgxpath.Step.getAxis = function (name) {
    return wgxpath.Step.nameToAxisMap_[name] || null;
};


/**
 * Axis enumeration.
 *
 * @enum {{isReverse: function(): boolean}}
 */
wgxpath.Step.Axis = {
    ANCESTOR: wgxpath.Step.createAxis_('ancestor',
        function (test, node) {
            var nodeset = new wgxpath.NodeSet();
            var parent = node;
            while (parent = parent.parentNode) {
                if (test.matches(parent)) {
                    nodeset.unshift(parent);
                }
            }
            return nodeset;
        }, true),
    ANCESTOR_OR_SELF: wgxpath.Step.createAxis_('ancestor-or-self',
        function (test, node) {
            var nodeset = new wgxpath.NodeSet();
            var toMatch = node;
            do {
                if (test.matches(toMatch)) {
                    nodeset.unshift(toMatch);
                }
            } while (toMatch = toMatch.parentNode);
            return nodeset;
        }, true),
    ATTRIBUTE: wgxpath.Step.createAxis_('attribute',
        function (test, node) {
            var nodeset = new wgxpath.NodeSet();
            var testName = test.getName();
            // IE8 doesn't allow access to the style attribute using getNamedItem.
            // It returns an object with nodeValue = null.
            if (testName == 'style' && node.style &&
                wgxpath.userAgent.IE_DOC_PRE_9) {
                nodeset.add(wgxpath.IEAttrWrapper.forStyleOf(
                    /** @type {!Node} */ (node), node.sourceIndex));
                return nodeset;
            }
            var attrs = node.attributes;
            if (attrs) {
                if ((test instanceof wgxpath.KindTest &&
                    goog.isNull(test.getType())) || testName == '*') {
                    var sourceIndex = node.sourceIndex;
                    for (var i = 0, attr; attr = attrs[i]; i++) {
                        if (wgxpath.userAgent.IE_DOC_PRE_9) {
                            if (attr.nodeValue) {
                                nodeset.add(wgxpath.IEAttrWrapper.forAttrOf(
                                    /** @type {!Node} */ (node), attr, sourceIndex));
                            }
                        } else {
                            nodeset.add(attr);
                        }
                    }
                } else {
                    var attr = attrs.getNamedItem(testName);
                    if (attr) {
                        if (wgxpath.userAgent.IE_DOC_PRE_9) {
                            if (attr.nodeValue) {
                                nodeset.add(wgxpath.IEAttrWrapper.forAttrOf(
                                    /** @type {!Node} */ (node), attr, node.sourceIndex));
                            }
                        } else {
                            nodeset.add(attr);
                        }
                    }
                }
            }
            return nodeset;
        }, false),
    CHILD: wgxpath.Step.createAxis_('child',
        wgxpath.Node.getChildNodes, false, true),
    DESCENDANT: wgxpath.Step.createAxis_('descendant',
        wgxpath.Node.getDescendantNodes, false, true),
    DESCENDANT_OR_SELF: wgxpath.Step.createAxis_('descendant-or-self',
        function (test, node, attrName, attrValue) {
            var nodeset = new wgxpath.NodeSet();
            if (wgxpath.Node.attrMatches(node, attrName, attrValue)) {
                if (test.matches(node)) {
                    nodeset.add(node);
                }
            }
            return wgxpath.Node.getDescendantNodes(test, node,
                attrName, attrValue, nodeset);
        }, false, true),
    FOLLOWING: wgxpath.Step.createAxis_('following',
        function (test, node, attrName, attrValue) {
            var nodeset = new wgxpath.NodeSet();
            var parent = node;
            do {
                var child = parent;
                while (child = child.nextSibling) {
                    if (wgxpath.Node.attrMatches(child, attrName, attrValue)) {
                        if (test.matches(child)) {
                            nodeset.add(child);
                        }
                    }
                    nodeset = wgxpath.Node.getDescendantNodes(test, child,
                        attrName, attrValue, nodeset);
                }
            } while (parent = parent.parentNode);
            return nodeset;
        }, false, true),
    FOLLOWING_SIBLING: wgxpath.Step.createAxis_('following-sibling',
        function (test, node) {
            var nodeset = new wgxpath.NodeSet();
            var toMatch = node;
            while (toMatch = toMatch.nextSibling) {
                if (test.matches(toMatch)) {
                    nodeset.add(toMatch);
                }
            }
            return nodeset;
        }, false),
    NAMESPACE: wgxpath.Step.createAxis_('namespace',
        function (test, node) {
            // not implemented
            return new wgxpath.NodeSet();
        }, false),
    PARENT: wgxpath.Step.createAxis_('parent',
        function (test, node) {
            var nodeset = new wgxpath.NodeSet();
            if (node.nodeType == goog.dom.NodeType.DOCUMENT) {
                return nodeset;
            } else if (node.nodeType == goog.dom.NodeType.ATTRIBUTE) {
                nodeset.add(node.ownerElement);
                return nodeset;
            }
            var parent = /** @type {!Node} */ (node.parentNode);
            if (test.matches(parent)) {
                nodeset.add(parent);
            }
            return nodeset;
        }, false),
    PRECEDING: wgxpath.Step.createAxis_('preceding',
        function (test, node, attrName, attrValue) {
            var nodeset = new wgxpath.NodeSet();
            var parents = [];
            var parent = node;
            do {
                parents.unshift(parent);
            } while (parent = parent.parentNode);
            for (var i = 1, l0 = parents.length; i < l0; i++) {
                var siblings = [];
                node = parents[i];
                while (node = node.previousSibling) {
                    siblings.unshift(node);
                }
                for (var j = 0, l1 = siblings.length; j < l1; j++) {
                    node = siblings[j];
                    if (wgxpath.Node.attrMatches(node, attrName, attrValue)) {
                        if (test.matches(node)) nodeset.add(node);
                    }
                    nodeset = wgxpath.Node.getDescendantNodes(test, node,
                        attrName, attrValue, nodeset);
                }
            }
            return nodeset;
        }, true, true),
    PRECEDING_SIBLING: wgxpath.Step.createAxis_('preceding-sibling',
        function (test, node) {
            var nodeset = new wgxpath.NodeSet();
            var toMatch = node;
            while (toMatch = toMatch.previousSibling) {
                if (test.matches(toMatch)) {
                    nodeset.unshift(toMatch);
                }
            }
            return nodeset;
        }, true),
    SELF: wgxpath.Step.createAxis_('self',
        function (test, node) {
            var nodeset = new wgxpath.NodeSet();
            if (test.matches(node)) {
                nodeset.add(node);
            }
            return nodeset;
        }, false)
};

// Input 35
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview A class representing operations on unary expressions.
 */

goog.provide('wgxpath.UnaryExpr');

goog.require('wgxpath.DataType');
goog.require('wgxpath.Expr');


/**
 * Constructor for UnaryExpr.
 *
 * @param {!wgxpath.Expr} expr The unary expression.
 * @extends {wgxpath.Expr}
 * @constructor
 */
wgxpath.UnaryExpr = function (expr) {
    wgxpath.Expr.call(this, wgxpath.DataType.NUMBER);

    /**
     * @private
     * @type {!wgxpath.Expr}
     */
    this.expr_ = expr;

    this.setNeedContextPosition(expr.doesNeedContextPosition());
    this.setNeedContextNode(expr.doesNeedContextNode());
};
goog.inherits(wgxpath.UnaryExpr, wgxpath.Expr);


/**
 * @override
 * @return {number} The number result.
 */
wgxpath.UnaryExpr.prototype.evaluate = function (ctx) {
    return -this.expr_.asNumber(ctx);
};


/**
 * @override
 */
wgxpath.UnaryExpr.prototype.toString = function () {
    return 'Unary Expression: -' + wgxpath.Expr.indent(this.expr_);
};

// Input 36
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview A class representing operations on union expressions.
 */

goog.provide('wgxpath.UnionExpr');

goog.require('goog.array');
goog.require('wgxpath.DataType');
goog.require('wgxpath.Expr');


/**
 * Constructor for UnionExpr.
 *
 * @param {!Array.<!wgxpath.Expr>} paths The paths in the union.
 * @extends {wgxpath.Expr}
 * @constructor
 */
wgxpath.UnionExpr = function (paths) {
    wgxpath.Expr.call(this, wgxpath.DataType.NODESET);

    /**
     * @type {!Array.<!wgxpath.Expr>}
     * @private
     */
    this.paths_ = paths;
    this.setNeedContextPosition(goog.array.some(this.paths_, function (p) {
        return p.doesNeedContextPosition();
    }));
    this.setNeedContextNode(goog.array.some(this.paths_, function (p) {
        return p.doesNeedContextNode();
    }));
};
goog.inherits(wgxpath.UnionExpr, wgxpath.Expr);


/**
 * @override
 * @return {!wgxpath.NodeSet} The nodeset result.
 */
wgxpath.UnionExpr.prototype.evaluate = function (ctx) {
    var nodeset = new wgxpath.NodeSet();
    goog.array.forEach(this.paths_, function (p) {
        var result = p.evaluate(ctx);
        if (!(result instanceof wgxpath.NodeSet)) {
            throw Error('Path expression must evaluate to NodeSet.');
        }
        nodeset = wgxpath.NodeSet.merge(nodeset, result);
    });
    return nodeset;
};


/**
 * @override
 */
wgxpath.UnionExpr.prototype.toString = function () {
    return goog.array.reduce(this.paths_, function (prev, curr) {
        return prev + wgxpath.Expr.indent(curr);
    }, 'Union Expression:');
};

// Input 37
// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview A recursive descent Parser.
 */

goog.provide('wgxpath.Parser');

goog.require('wgxpath.BinaryExpr');
goog.require('wgxpath.FilterExpr');
goog.require('wgxpath.FunctionCall');
goog.require('wgxpath.KindTest');
goog.require('wgxpath.Literal');
goog.require('wgxpath.NameTest');
goog.require('wgxpath.Number');
goog.require('wgxpath.PathExpr');
goog.require('wgxpath.Predicates');
goog.require('wgxpath.Step');
goog.require('wgxpath.UnaryExpr');
goog.require('wgxpath.UnionExpr');


/**
 * The recursive descent parser.
 *
 * @constructor
 * @param {!wgxpath.Lexer} lexer The lexer.
 * @param {function(string): ?string} nsResolver Namespace resolver.
 */
wgxpath.Parser = function (lexer, nsResolver) {

    /**
     * @private {!wgxpath.Lexer}
     */
    this.lexer_ = lexer;

    /**
     * @private {function(string): ?string}
     */
    this.nsResolver_ = nsResolver;
};


/**
 * Apply recursive descent parsing on the input to construct an
 * abstract syntax tree.
 *
 * @return {!wgxpath.Expr} The root of the constructed tree.
 */
wgxpath.Parser.prototype.parseExpr = function () {
    var expr, stack = [];
    while (true) {
        this.checkNotEmpty_('Missing right hand side of binary expression.');
        expr = this.parseUnaryExpr_(); // See if it's just a UnaryExpr.
        var opString = this.lexer_.next();
        if (!opString) {
            break; // Done, we have only a UnaryExpr.
        }

        var op = wgxpath.BinaryExpr.getOp(opString);
        var precedence = op && op.getPrecedence();
        if (!precedence) {
            this.lexer_.back();
            break;
        }
        // Precedence climbing
        while (stack.length &&
            precedence <= stack[stack.length - 1].getPrecedence()) {
            expr = new wgxpath.BinaryExpr(stack.pop(), stack.pop(), expr);
        }
        stack.push(expr, op);
    }
    while (stack.length) {
        expr = new wgxpath.BinaryExpr(stack.pop(), stack.pop(),
            /** @type {!wgxpath.Expr} */ (expr));
    }
    return /** @type {!wgxpath.Expr} */ (expr);
};


/**
 * Checks that the lexer is not empty,
 *     displays the given error message if it is.
 *
 * @private
 * @param {string} msg The error message to display.
 */
wgxpath.Parser.prototype.checkNotEmpty_ = function (msg) {
    if (this.lexer_.empty()) {
        throw Error(msg);
    }
};


/**
 * Checks that the next token of the error message is the expected token.
 *
 * @private
 * @param {string} expected The expected token.
 */
wgxpath.Parser.prototype.checkNextEquals_ = function (expected) {
    var got = this.lexer_.next();
    if (got != expected) {
        throw Error('Bad token, expected: ' + expected + ' got: ' + got);
    }
};


/**
 * Checks that the next token of the error message is not the given token.
 *
 * @private
 * @param {string} token The token.
 */
wgxpath.Parser.prototype.checkNextNotEquals_ = function (token) {
    var next = this.lexer_.next();
    if (next != token) {
        throw Error('Bad token: ' + next);
    }
};


/**
 * Attempts to parse the input as a FilterExpr.
 *
 * @private
 * @return {wgxpath.Expr} The root of the constructed tree.
 */
wgxpath.Parser.prototype.parseFilterExpr_ = function () {
    var expr;
    var token = this.lexer_.peek();
    var ch = token.charAt(0);
    switch (ch) {
        case '$':
            throw Error('Variable reference not allowed in HTML XPath');
        case '(':
            this.lexer_.next();
            expr = this.parseExpr();
            this.checkNotEmpty_('unclosed "("');
            this.checkNextEquals_(')');
            break;
        case '"':
        case "'":
            expr = this.parseLiteral_();
            break;
        default:
            if (!isNaN(+token)) {
                expr = this.parseNumber_();
            } else if (wgxpath.KindTest.isValidType(token)) {
                return null;
            } else if (/(?![0-9])[\w]/.test(ch) && this.lexer_.peek(1) == '(') {
                expr = this.parseFunctionCall_();
            } else {
                return null;
            }
    }
    if (this.lexer_.peek() != '[') {
        return expr;
    }
    var predicates = new wgxpath.Predicates(this.parsePredicates_());
    return new wgxpath.FilterExpr(expr, predicates);
};


/**
 * Parses FunctionCall.
 *
 * @private
 * @return {!wgxpath.FunctionCall} The parsed expression.
 */
wgxpath.Parser.prototype.parseFunctionCall_ = function () {
    var funcName = this.lexer_.next();
    var func = wgxpath.FunctionCall.getFunc(funcName);
    this.lexer_.next();

    var args = [];
    while (this.lexer_.peek() != ')') {
        this.checkNotEmpty_('Missing function argument list.');
        args.push(this.parseExpr());
        if (this.lexer_.peek() != ',') {
            break;
        }
        this.lexer_.next();
    }
    this.checkNotEmpty_('Unclosed function argument list.');
    this.checkNextNotEquals_(')');

    return new wgxpath.FunctionCall(func, args);
};


/**
 * Parses the input to construct a KindTest.
 *
 * @private
 * @return {!wgxpath.KindTest} The KindTest constructed.
 */
wgxpath.Parser.prototype.parseKindTest_ = function () {
    var typeName = this.lexer_.next();
    if (!wgxpath.KindTest.isValidType(typeName)) {
        throw Error('Invalid type name: ' + typeName);
    }
    this.checkNextEquals_('(');
    this.checkNotEmpty_('Bad nodetype');
    var ch = this.lexer_.peek().charAt(0);

    var literal = null;
    if (ch == '"' || ch == "'") {
        literal = this.parseLiteral_();
    }
    this.checkNotEmpty_('Bad nodetype');
    this.checkNextNotEquals_(')');
    return new wgxpath.KindTest(typeName, literal);
};


/**
 * Parses the input to construct a Literal.
 *
 * @private
 * @return {!wgxpath.Literal} The Literal constructed.
 */
wgxpath.Parser.prototype.parseLiteral_ = function () {
    var token = this.lexer_.next();
    if (token.length < 2) {
        throw Error('Unclosed literal string');
    }
    return new wgxpath.Literal(token);
};


/**
 * Parses the input to construct a NameTest.
 *
 * @private
 * @return {!wgxpath.NameTest} The NameTest constructed.
 */
wgxpath.Parser.prototype.parseNameTest_ = function () {
    var name = this.lexer_.next();

    // Check whether there's a namespace prefix.
    var colonIndex = name.indexOf(':');
    if (colonIndex == -1) {
        return new wgxpath.NameTest(name);
    } else {
        var namespacePrefix = name.substring(0, colonIndex);
        var namespaceUri = this.nsResolver_(namespacePrefix);
        if (!namespaceUri) {
            throw Error('Namespace prefix not declared: ' + namespacePrefix);
        }
        name = name.substr(colonIndex + 1);
        return new wgxpath.NameTest(name, namespaceUri);
    }
};


/**
 * Parses the input to construct a Number.
 *
 * @private
 * @return {!wgxpath.Number} The Number constructed.
 */
wgxpath.Parser.prototype.parseNumber_ = function () {
    return new wgxpath.Number(+this.lexer_.next());
};


/**
 * Attempts to parse the input as a PathExpr.
 *
 * @private
 * @return {!wgxpath.Expr} The root of the constructed tree.
 */
wgxpath.Parser.prototype.parsePathExpr_ = function () {
    var op, expr;
    var steps = [];
    var filterExpr;
    if (wgxpath.PathExpr.isValidOp(this.lexer_.peek())) {
        op = this.lexer_.next();
        var token = this.lexer_.peek();
        if (op == '/' && (this.lexer_.empty() ||
            (token != '.' && token != '..' && token != '@' && token != '*' && !/(?![0-9])[\w]/.test(token)))) {
            return new wgxpath.PathExpr.RootHelperExpr();
        }
        filterExpr = new wgxpath.PathExpr.RootHelperExpr();

        this.checkNotEmpty_('Missing next location step.');
        expr = this.parseStep_(op);
        steps.push(expr);
    } else {
        expr = this.parseFilterExpr_();
        if (!expr) {
            expr = this.parseStep_('/');
            filterExpr = new wgxpath.PathExpr.ContextHelperExpr();
            steps.push(expr);
        } else if (!wgxpath.PathExpr.isValidOp(this.lexer_.peek())) {
            return expr; // Done.
        } else {
            filterExpr = expr;
        }
    }
    while (true) {
        if (!wgxpath.PathExpr.isValidOp(this.lexer_.peek())) {
            break;
        }
        op = this.lexer_.next();
        this.checkNotEmpty_('Missing next location step.');
        expr = this.parseStep_(op);
        steps.push(expr);
    }
    return new wgxpath.PathExpr(filterExpr, steps);
};


/**
 * Parses Step.
 *
 * @private
 * @param {string} op The op for this step.
 * @return {!wgxpath.Step} The parsed expression.
 */
wgxpath.Parser.prototype.parseStep_ = function (op) {
    var test, step, token, predicates;
    if (op != '/' && op != '//') {
        throw Error('Step op should be "/" or "//"');
    }
    if (this.lexer_.peek() == '.') {
        step = new wgxpath.Step(wgxpath.Step.Axis.SELF,
            new wgxpath.KindTest('node'));
        this.lexer_.next();
        return step;
    }
    else if (this.lexer_.peek() == '..') {
        step = new wgxpath.Step(wgxpath.Step.Axis.PARENT,
            new wgxpath.KindTest('node'));
        this.lexer_.next();
        return step;
    } else {
        // Grab the axis.
        var axis;
        if (this.lexer_.peek() == '@') {
            axis = wgxpath.Step.Axis.ATTRIBUTE;
            this.lexer_.next();
            this.checkNotEmpty_('Missing attribute name');
        } else {
            if (this.lexer_.peek(1) == '::') {
                if (!/(?![0-9])[\w]/.test(this.lexer_.peek().charAt(0))) {
                    throw Error('Bad token: ' + this.lexer_.next());
                }
                var axisName = this.lexer_.next();
                axis = wgxpath.Step.getAxis(axisName);
                if (!axis) {
                    throw Error('No axis with name: ' + axisName);
                }
                this.lexer_.next();
                this.checkNotEmpty_('Missing node name');
            } else {
                axis = wgxpath.Step.Axis.CHILD;
            }
        }

        // Grab the test.
        token = this.lexer_.peek();
        if (!/(?![0-9])[\w]/.test(token.charAt(0))) {
            if (token == '*') {
                test = this.parseNameTest_();
            } else {
                throw Error('Bad token: ' + this.lexer_.next());
            }
        } else {
            if (this.lexer_.peek(1) == '(') {
                if (!wgxpath.KindTest.isValidType(token)) {
                    throw Error('Invalid node type: ' + token);
                }
                test = this.parseKindTest_();
            } else {
                test = this.parseNameTest_();
            }
        }
        predicates = new wgxpath.Predicates(this.parsePredicates_(),
            axis.isReverse());
        return step || new wgxpath.Step(axis, test, predicates, op == '//');
    }
};


/**
 * Parses and returns the predicates from the this.lexer_.
 *
 * @private
 * @return {!Array.<!wgxpath.Expr>} An array of the predicates.
 */
wgxpath.Parser.prototype.parsePredicates_ = function () {
    var predicates = [];
    while (this.lexer_.peek() == '[') {
        this.lexer_.next();
        this.checkNotEmpty_('Missing predicate expression.');
        var predicate = this.parseExpr();
        predicates.push(predicate);
        this.checkNotEmpty_('Unclosed predicate expression.');
        this.checkNextEquals_(']');
    }
    return predicates;
};


/**
 * Attempts to parse the input as a unary expression with
 * recursive descent parsing.
 *
 * @private
 * @return {!wgxpath.Expr} The root of the constructed tree.
 */
wgxpath.Parser.prototype.parseUnaryExpr_ = function () {
    if (this.lexer_.peek() == '-') {
        this.lexer_.next();
        return new wgxpath.UnaryExpr(this.parseUnaryExpr_());
    } else {
        return this.parseUnionExpr_();
    }
};


/**
 * Attempts to parse the input as a union expression with
 * recursive descent parsing.
 *
 * @private
 * @return {!wgxpath.Expr} The root of the constructed tree.
 */
wgxpath.Parser.prototype.parseUnionExpr_ = function () {
    var expr = this.parsePathExpr_();
    if (!(this.lexer_.peek() == '|')) {
        return expr;  // Not a UnionExpr, returning as is.
    }
    var paths = [expr];
    while (this.lexer_.next() == '|') {
        this.checkNotEmpty_('Missing next union location path.');
        paths.push(this.parsePathExpr_());
    }
    this.lexer_.back();
    return new wgxpath.UnionExpr(paths);
};

// Input 38
/*  JavaScript-XPath 0.1.11
 *  (c) 2007 Cybozu Labs, Inc.
 *
 *  JavaScript-XPath is freely distributable under the terms of an MIT-style
 *  license. For details, see the JavaScript-XPath web site:
 *  http://coderepos.org/share/wiki/JavaScript-XPath
 *
 /*--------------------------------------------------------------------------*/

// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * Wicked Good XPath
 *
 * @fileoverview A cross-browser XPath library forked from the
 * JavaScript-XPath project by Cybozu Labs.
 *
 */

goog.provide('wgxpath');

goog.require('wgxpath.Context');
goog.require('wgxpath.IEAttrWrapper');
goog.require('wgxpath.Lexer');
goog.require('wgxpath.NodeSet');
goog.require('wgxpath.Parser');


/**
 * Enum for XPathResult types.
 *
 * @private
 * @enum {number}
 */
wgxpath.XPathResultType_ = {
    ANY_TYPE: 0,
    NUMBER_TYPE: 1,
    STRING_TYPE: 2,
    BOOLEAN_TYPE: 3,
    UNORDERED_NODE_ITERATOR_TYPE: 4,
    ORDERED_NODE_ITERATOR_TYPE: 5,
    UNORDERED_NODE_SNAPSHOT_TYPE: 6,
    ORDERED_NODE_SNAPSHOT_TYPE: 7,
    ANY_UNORDERED_NODE_TYPE: 8,
    FIRST_ORDERED_NODE_TYPE: 9
};


/**
 * The exported XPathExpression type.
 *
 * @constructor
 * @extends {XPathExpression}
 * @param {string} expr The expression string.
 * @param {?(XPathNSResolver|function(string): ?string)} nsResolver
 *     XPath namespace resolver.
 * @private
 */
wgxpath.XPathExpression_ = function (expr, nsResolver) {
    if (!expr.length) {
        throw Error('Empty XPath expression.');
    }
    var lexer = wgxpath.Lexer.tokenize(expr);
    if (lexer.empty()) {
        throw Error('Invalid XPath expression.');
    }

    // nsResolver may either be an XPathNSResolver, which has a lookupNamespaceURI
    // function, a custom function, or null. Standardize it to a function.
    if (!nsResolver) {
        nsResolver = function (string) {
            return null;
        };
    } else if (!goog.isFunction(nsResolver)) {
        nsResolver = goog.bind(nsResolver.lookupNamespaceURI, nsResolver);
    }

    var gexpr = new wgxpath.Parser(lexer, nsResolver).parseExpr();
    if (!lexer.empty()) {
        throw Error('Bad token: ' + lexer.next());
    }
    this['evaluate'] = function (node, type) {
        var value = gexpr.evaluate(new wgxpath.Context(node));
        return new wgxpath.XPathResult_(value, type);
    };
};


/**
 * The exported XPathResult type.
 *
 * @constructor
 * @extends {XPathResult}
 * @param {(!wgxpath.NodeSet|number|string|boolean)} value The result value.
 * @param {number} type The result type.
 * @private
 */
wgxpath.XPathResult_ = function (value, type) {
    if (type == wgxpath.XPathResultType_.ANY_TYPE) {
        if (value instanceof wgxpath.NodeSet) {
            type = wgxpath.XPathResultType_.UNORDERED_NODE_ITERATOR_TYPE;
        } else if (typeof value == 'string') {
            type = wgxpath.XPathResultType_.STRING_TYPE;
        } else if (typeof value == 'number') {
            type = wgxpath.XPathResultType_.NUMBER_TYPE;
        } else if (typeof value == 'boolean') {
            type = wgxpath.XPathResultType_.BOOLEAN_TYPE;
        } else {
            throw Error('Unexpected evaluation result.');
        }
    }
    if (type != wgxpath.XPathResultType_.STRING_TYPE &&
        type != wgxpath.XPathResultType_.NUMBER_TYPE &&
        type != wgxpath.XPathResultType_.BOOLEAN_TYPE && !(value instanceof wgxpath.NodeSet)) {
        throw Error('value could not be converted to the specified type');
    }
    this['resultType'] = type;
    var nodes;
    switch (type) {
        case wgxpath.XPathResultType_.STRING_TYPE:
            this['stringValue'] = (value instanceof wgxpath.NodeSet) ?
                value.string() : '' + value;
            break;
        case wgxpath.XPathResultType_.NUMBER_TYPE:
            this['numberValue'] = (value instanceof wgxpath.NodeSet) ?
                value.number() : +value;
            break;
        case wgxpath.XPathResultType_.BOOLEAN_TYPE:
            this['booleanValue'] = (value instanceof wgxpath.NodeSet) ?
                value.getLength() > 0 : !!value;
            break;
        case wgxpath.XPathResultType_.UNORDERED_NODE_ITERATOR_TYPE:
        case wgxpath.XPathResultType_.ORDERED_NODE_ITERATOR_TYPE:
        case wgxpath.XPathResultType_.UNORDERED_NODE_SNAPSHOT_TYPE:
        case wgxpath.XPathResultType_.ORDERED_NODE_SNAPSHOT_TYPE:
            var iter = value.iterator();
            nodes = [];
            for (var node = iter.next(); node; node = iter.next()) {
                nodes.push(node instanceof wgxpath.IEAttrWrapper ?
                    node.getNode() : node);
            }
            this['snapshotLength'] = value.getLength();
            this['invalidIteratorState'] = false;
            break;
        case wgxpath.XPathResultType_.ANY_UNORDERED_NODE_TYPE:
        case wgxpath.XPathResultType_.FIRST_ORDERED_NODE_TYPE:
            var firstNode = value.getFirst();
            this['singleNodeValue'] =
                firstNode instanceof wgxpath.IEAttrWrapper ?
                    firstNode.getNode() : firstNode;
            break;
        default:
            throw Error('Unknown XPathResult type.');
    }
    var index = 0;
    this['iterateNext'] = function () {
        if (type != wgxpath.XPathResultType_.UNORDERED_NODE_ITERATOR_TYPE &&
            type != wgxpath.XPathResultType_.ORDERED_NODE_ITERATOR_TYPE) {
            throw Error('iterateNext called with wrong result type');
        }
        return (index >= nodes.length) ? null : nodes[index++];
    };
    this['snapshotItem'] = function (i) {
        if (type != wgxpath.XPathResultType_.UNORDERED_NODE_SNAPSHOT_TYPE &&
            type != wgxpath.XPathResultType_.ORDERED_NODE_SNAPSHOT_TYPE) {
            throw Error('snapshotItem called with wrong result type');
        }
        return (i >= nodes.length || i < 0) ? null : nodes[i];
    };
};
wgxpath.XPathResult_['ANY_TYPE'] = wgxpath.XPathResultType_.ANY_TYPE;
wgxpath.XPathResult_['NUMBER_TYPE'] = wgxpath.XPathResultType_.NUMBER_TYPE;
wgxpath.XPathResult_['STRING_TYPE'] = wgxpath.XPathResultType_.STRING_TYPE;
wgxpath.XPathResult_['BOOLEAN_TYPE'] = wgxpath.XPathResultType_.BOOLEAN_TYPE;
wgxpath.XPathResult_['UNORDERED_NODE_ITERATOR_TYPE'] =
    wgxpath.XPathResultType_.UNORDERED_NODE_ITERATOR_TYPE;
wgxpath.XPathResult_['ORDERED_NODE_ITERATOR_TYPE'] =
    wgxpath.XPathResultType_.ORDERED_NODE_ITERATOR_TYPE;
wgxpath.XPathResult_['UNORDERED_NODE_SNAPSHOT_TYPE'] =
    wgxpath.XPathResultType_.UNORDERED_NODE_SNAPSHOT_TYPE;
wgxpath.XPathResult_['ORDERED_NODE_SNAPSHOT_TYPE'] =
    wgxpath.XPathResultType_.ORDERED_NODE_SNAPSHOT_TYPE;
wgxpath.XPathResult_['ANY_UNORDERED_NODE_TYPE'] =
    wgxpath.XPathResultType_.ANY_UNORDERED_NODE_TYPE;
wgxpath.XPathResult_['FIRST_ORDERED_NODE_TYPE'] =
    wgxpath.XPathResultType_.FIRST_ORDERED_NODE_TYPE;


/**
 * Installs the library. Overwrites native XPath if available.
 *
 * @param {Window=} opt_win The window to install the library on.
 */
wgxpath.install = function (opt_win) {
    var win = opt_win || goog.global;
    var doc = win.document;

    // Installation, overwriting native XPath (if exists).
    win['XPathResult'] = wgxpath.XPathResult_;
    doc['evaluate'] = function (expr, context, nsResolver, type, result) {
        return new wgxpath.XPathExpression_(expr, nsResolver).
            evaluate(context, type);
    };
    doc['createExpression'] = function (expr, nsResolver) {
        return new wgxpath.XPathExpression_(expr, nsResolver);
    };
};

// Input 39
/*  JavaScript-XPath 0.1.11
 *  (c) 2007 Cybozu Labs, Inc.
 *
 *  JavaScript-XPath is freely distributable under the terms of an MIT-style
 *  license. For details, see the JavaScript-XPath web site:
 *  http://coderepos.org/share/wiki/JavaScript-XPath
 *
 /*--------------------------------------------------------------------------*/

// Copyright 2012 Google Inc. All Rights Reserved.

/**
 * @fileoverview Exports the wgxpath.install function.
 *
 */

goog.require('wgxpath');

goog.exportSymbol('wgxpath.install', wgxpath.install);

